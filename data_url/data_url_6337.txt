The natural progression of qubit masking type selectability in recent PRs (#607) is toward totally independent unsigned integer masking and floating point precision choices, among all "fp" and "uint" primitive types commonly available. This will include all combinations of {half/float/double} and {ushort/uint/ulong}, at least. uchar for masking seems needless, at the moment, but the selection options will naturally encompass it on demand.
Like the CMake QBCAPPOW integer option to choose the maximum number of "global, "paged" qubits, (under QPager or QUnit,) there will be equivalent arguments for float and uint choices. -DFLOATPOW=n for 2<=n<=4 corresponds to {half/float/double}. -DUINTPOW=n for 4<=n<=6 corresponds to {ushort/uint/ulong}. Both CPU and GPU types will store amplitude precision and qubit address masks per these same build arguments, as will be necessary for "hybridized" CPU/GPU types.
This will be added within the next day, as it's not particularly hard, and it should be done before benchmarks on FP16-optimized GPUs. I will update the Qiskit plugin and ProjectQ support as necessary to accommodate the new build options. Q# and XACC support do not need an update, but I will confirm that.
C++11 does not have a native half type, but I plan to use another optional Boost header, <boost/cstdfloat.hpp>, as the big integer header for uint types already.
FLOATPOW seems like it might be reserved, so FPPOW instead, equivalently, for a name.
The boost::float16_t type has to reference a type otherwise available in the compiler, it seems like, but switching macros for this type could let us either use it directly, or otherwise use 32-bit float types for QEngineCPU while using the native OpenCL half type if available, independently. (This might preclude the use of QHybrid under this build option, at least for now.) This makes implementation slightly more complicated, but it's still not more than a day of work, from here.
-DFPPOW=n and -DUINTPOW=n will both run over 4<=n<=6, for 16 through 64 bit primitives, correspondingly.
The build interface design described above works. Researching more, systems must natively support Boost half precision types. I'll review and accept the build interface, and I'll leave the Boost header precision switch in for pollyanna. Sorry if I falsely excited anyone, but half seems to be hardware specific, for now.
Closed by #621.
