The new Electron.wait_for() method allows users to instruct Covalent that a task (task B) should wait for another task (task A) to return before being dispatched. This is needed in some instances because Covalent normally infers the dependency relations between electrons just from their inputs and outputs and therefore would not be able to handle scenarios where task B depends only on a side-effect of task A.
However, when users construct a function describing their workflow, invoking the wait_for() method on an electron causes the workflow function to no longer be callable:
When workflow_function is called, res1 and res2 are the return values of task_1 and task_2, not Electrons, so Python function cannot evaluate the third statement.
This behavior is unintuitive because workflow functions are Python functions, and functions are expected to be callable. The ct.lattice decorator is not relevant here because:
Suggestion: Instead of exposing the Electron.wait_for method directly to users, we can treat that a private method like the other methods that manipulate the transport graph (e.g. Electron.connect_node_with_others()), and expose a static wrapper function that invokes Electron.wait_for only in the context of an active lattice (during graph building and postprocessing). For example:
Then the following modified workflow function can both be called and dispatched:
