The current deprecation wrapper for functions and classes @deprecate_func is a bit awkward to use with dataclasses. If it's added to __post_init__(), Sphinx won't render the deprecation warning. Instead, the user has to populate __init__() and pass arguments using *args and **kwargs which is recommended by https://peps.python.org/pep-0557/#custom-init-method, but then the docs render *args and **kwargs as the inputs to the dataclass instead of the actual fields of the dataclass.
Perhaps a @deprecate_class wrapper is needed.
@jakelishman thoughts on @deprecate_class? It would dynamically modify the docstring of the class itself.
For normal classes, people could either keep using @deprecate_func on the __init__ or @deprecate_class. If we were concerned about that and want people to only use @deprecate_func on the __init__, then we could name the decorator @deprecate_dataclass?
This sounds reasonable to me, and I agree that modifying the class docstring would be the way to go from a documentation perspective.
It becomes a bit trickier to think about how we'd manage the warnings getting emitted from running code, I guess - it's not difficult to automatically wrap __init__, but how would we consider alternate constructors (e.g. dict.fromkeys or the like)?  Probably they'd need deprecating separately.  Considering a shade further: if we're deprecating dataclasses, it's not unreasonable that we'd want to deprecate an Enum in the future.  Those pose more problems for a potential deprecate_class decorator because the enumeration elements aren't instantiated when used since they're singletons.  I guess my concern is just that the more "magic" we make our tooling, the more surprising / tricky it becomes to work around deficiencies.
Probably Eric's idea of a specific deprecate_dataclass is the best for now; we don't need to worry about alternate constructors (because there aren't any), and should we add a fancier deprecate_class in the future, we'd be able to just alias _dataclass to _class for an easy upgrade path.
I agree with your hesitation on e.g. Enums, or people doing fancy things with __new__. We don't need to handle every edge case IMO: it remains an option to manually call warnings.warn and update the docstring. But, we should do our best to anticipate likely edge cases.
Probably Eric's idea of a specific deprecate_dataclass is the best for now; we don't need to worry about alternate constructors (because there aren't any), and should we add a fancier deprecate_class in the future, we'd be able to just alias _dataclass to _class for an easy upgrade path.
Yeah, the more I think about this, the more I agree that this is a good approach for now. It reduces the risk of the issues you describe, and it makes the API much clearer of when to use @deprecate_func vs this new decorator.
