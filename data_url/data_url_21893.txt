If setting the attenuation for a channel in a fresh experiment, all other channel attenuators are set to maximum attenuation. Expected behaviour would be to set only the channel in question and leave others unchanged.
This is due to the way the Urukul CPLD is initialised in urukul.py - the att_reg attribute is set to 0 during __init__ without checking the state of the hardware. Subsequent calls to set_att_mu use this initially empty register, hence setting all other channels fully attenuated.
get_att_mu also suffers, as it writes in att_reg to read out the last programmed state , meaning that calling this function without att_reg initialised also sets all the attenuators to maximum. I would expect this function to return the current state of the hardware without affecting it.
Using the below code (commenting/uncommenting the get() or set() lines as required):
Yes. The analogous issue (unsynchronized state) exists in a lot of other places as well. E.g. Sampler PGIA, Zotino LEDs, or if you changed some of the Urukul DDS settings (PLL N) manually. In this case you'll either have to explicitly set the attenuator register to the "expected" value (somewhat fragile), or load the value (that'll cost time).
Yes. The analogous issue (unsynchronized state) exists in a lot of other places as well. E.g. Sampler PGIA, Zotino LEDs, or if you changed some of the Urukul DDS settings (PLL N) manually. In this case you'll either have to explicitly set the attenuator register to the "expected" value (somewhat fragile), or load the value (that'll cost time).
Do you think it is worth adding a sentence to that effect in the documentation? This behavior is obvious when one thinks about it in the right way, but not clear from the current documentation, and easy for new users (not familiar with the HW) to get confused by.
The behavior of get_att_mu() can not be changed. It needs CS. But it should be documented.
On Sampler the behaviour could be changed (IIRC) by not asserting the PGIA_CS when reading.
Probably the best would be to documented throughout (get_att_mu() and every affected set...()) and offer overrides for those state defaults through the device DB. Also should be documented in best practices for coredevice drivers.
I agree that documentation is the way forward - loading the value into the register (if you mean via get_att_mu) isn't possible without affecting the output, and even if corrected immediately afterwards that would be highly undesirable behaviour!
Also happens easily with the spi2 driver's xfer_duration_mu (set by SPIMaster.set_config() from e.g. Sampler.init())
I understand the reasons why this issue has been closed, however I feel that this is still something that is sub-optimal with Urukul and requires annoying work-around (I have just hit this as an annoyance in some of our systems).
Would it be out of the question to add some logic into the CPLD to allow for state independent setting in the future? Something like adding some extra bits at the start of the shift register to allow the CPLD to store the last set state and dump it out if the right bits are set.
I don't see that this is necessary now since similar functionality can be made by running cpld.get_att_mu() at the start of a kernel and adding it now is a bit of a pain for compatibility. However, I think relying on the user knowing that they need to run this before changing the attenuator setting is not as nice for usability.
Yes. This is not an optimal design. For the attenuators, I don't see how this can be fixed without breaking up the daisy chain. The CPLD is pretty small and I am pretty sure that there are no resources left to implement a full backing state in the CPLD that could be mixed/masked on the fly with updates via SPI to allow single-attenuator updates without sideffects. But if you want, please do give it a try.
If you can't partition your channels so that you always know what the other attenuators are supposed to be (using the default backing state or functional partitioning of your AOM channels), then loading the current attenuator register should be done in your experiments and can be organized well into generic initialization methods that you will probably already have.
Something similar to get_att_mu() should be implemented for the CPLD cfg register (AFAIK that doesn't even require gateware changes).
