Distinguishing boolean values and measurement results in Quake will facilitate detecting when values are known only at quantum runtime. This is relevant for both giving diagnostics when kernel code cannot be executed on certain backends, and for code optimizations. See also the discussions on #227.
The PR #869 splits the Measurement operations into two phases. The first phase is considered in the quantum domain and has the semantics of capturing (destructively) the state of a qudit. The second phase, which is a pure operation, converts the captured state to an integral value, typically a bool. The first phase will be new Measurement operations with a new return type: !quake.measure. The second phase is a new operation, quake.discriminate that performs the conversion. For more information, see the PR.
The first case is when a measurement's result is not used. This will become trivial to detect with the new scheme as the pure discriminate operations will be erased when not used. A function with no discriminate operations doesn't use quantum information to inform later quantum operations.
The second case is when a measurement's result is not dead, but is not used by or to control any other quantum operations in the control flow of the quantum kernel. A trivial example is to read a number of qubits into a std::vector and return them as bool values to the CPU.
The third case is when a measurement's result is not dead, but is used by or to control other quantum operations in the kernel's execution. In this case, quantum operations are control- or data-dependent on other quantum operations in the same kernel, and this situation impacts how the circuit can be optimized, etc.
The proposal is to reimplement the current pass that attempts to distinguish case 2 and case 3 with a dataflow analysis over the CFG. (See Algorithm below.) By tracking the use chains of discriminate operations, one can prove that the value is or is not used by or to control other quantum operations.
It's unclear if this case will arise often or not at the time of this writing.
Since discriminate operations return integral values, those values can be stored in local (or potentially global) variables. A problematic case would be an aggregate variable (such as a std::vector<bool>) which would not be register promoted by memtoreg.
The author of the kernel may store a number of qubits to an aggregate variable and then use those values by reading them out of the std::vector to control later quantum operations, for example. The implicit effects of storing and loading values that are data-dependent on discriminate operations will need to be implemented for correctness or some sort of restrictions on reading variables written from measurements might be considered.
This case is not expected to happen, but is described for completeness and consideration.
If the result of a discriminate operation is used by values passed as arguments to call operations, it may not always be provable that the called function does, in fact, have quantum operations that are either control- or data-dependent on that value(s). The conservative assumption in this case would be to assume that the called function does have quantum operations which are somehow control- or data-dependent. Note that this only applies when the arguments to the call are themselves derived from discriminate operations. Values of other types would be considered safe.
QCQ dependence : when a quantum computation's result is translated to the classical compute domain as value, $\nu$. Let $U_{\nu}$ be the transitive closure set of all users of $\nu$. Now if there is a quantum computation that has either a control- or data-dependence on any value in $U_{\nu}$ then there is a QCQ dependence in the kernel.
For all operations, $\omicron$, of type quake.discriminate in a kernel, iteratively compute the transitive closure of all users for each $\omicron$. Each $\omicron$ will generate a set $U_{\omicron}$. (Note: see the section above about memory references.)
If a kernel has no operations $\omicron$, then the kernel clearly has no QCQ dependence.
Otherwise, for all operations $\gamma \in U_{\omicron}$:
If none of the previous conditions is true for any $\omicron$ in the kernel, there is no QCQ dependence in the kernel.
