with save
The reason for the odd behavior is that we used to modify the config file while pyrpl is running and therefore have some code supporting this. This has been essentially forbidden in the meantime since it is not clearly defined to what extent load_setup_attributes should be executed for all modules in this case or not. However, the code is still there in memory.py and it does not hurt to have it:
However, it is to be understood that all setup_attributes should only be modified through a running API, since otherwise the changes will likely be erased once setup_attributes from memory are written to the file. However, other config file entries will survive this procedure, for examle saved states or other, non-setup_attribute entries. This is therefore some sort of hidden feature of our memorytree object that is useful if memorytrees are used outside the scope of pyrpl.
Now, what happens when two running pyrpl instances access the same config file through different memorytrees is that each pyrpl instance will see the changes of the other one, reload the memorytree, and likely overwrite the possibly different setup_attributes of the other pyrpl instance. One remedy would be to implement a file lock that prevents other pyrpl instances to access an active memorytree. This is however annoying because we would have to make sure the lock doesnt prevent a user from starting pyrpl after a crash and so on. Another way is to somehow signal to the older pyrpl instance that it should terminate since a newer one is active. This is also good since the same hardware would be shared otherwise, another frequent source of bugs.
Anyways, this is a different issue and will receive an own ticket. The bug with two open memorytrees (without pyrpl) is not reproducible and tested in a new unittest from now on.
