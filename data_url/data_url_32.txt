Currently, the default behavior of nvq++ is to compile user code in library mode, i.e., the simple nvq++ <source> -o <exec> will compile <source> in library mode. The problem with this behavior is that this modes allows the user to use the full power of C++ within kernel code---something that is unlikely to be realistic when targeting real quantum devices.
We should create a default emulation target and make the use of the library mode should be a conscious choice by the user, say nvq++ --library-mode <source> -o <exec>, and the compiler should warn the user about its danger: mainly the fact that their kernel might not be able to target real (or emulated) devices.
I'm surprised this isn't already in the issues list. :)
Currently, the default behavior of nvq++ is to compile user code in library mode, i.e., the simple nvq++ <source> -o <exec> will compile <source> in library mode. The problem with this behavior is that this modes allows the user to use the full power of C++ within kernel code---something that is unlikely to be realistic when targeting real quantum devices.
We should create a default emulation target and make the use of the library mode should be a conscious choice by the user, say nvq++ --library-mode <source> -o <exec>, and the compiler should warn the user about its danger: mainly the fact that their kernel might not be able to target real (or emulated) devices.
I am curious, what does the kernel code that cannot be executed on real quantum devices look like? Can you please give me an example? Thank you very much.
And I noticed that in library mode, the tracer is executed first and then the sample is executed. I would like to ask what is the purpose of this tracer here? It is for mid-circuit measurement?
I am curious, what does the kernel code that cannot be executed on real quantum devices look like? Can you please give me an example? Thank you very much.
One example would be a quantum kernel operating on global data. Another would be a quantum kernel taking pointers as input or providing pointers as outputs. Both of these examples are invalid because it is assumed that a QPU and the host CPU will share different address spaces. The currently library mode compilation flow would treat compile them anyway despite not truly being executable on a real quantum system. See https://nvidia.github.io/cuda-quantum/latest/specification/cudaq/kernels.html for more details about data type restrictions on quantum kernels. The exact details of what is supported and unsupported may evolve over time, but I believe the validity of the specific examples I gave above are unlikely to change. Hopefully that helps.
I am curious, what does the kernel code that cannot be executed on real quantum devices look like? Can you please give me an example? Thank you very much.
One example would be a quantum kernel operating on global data. Another would be a quantum kernel taking pointers as input or providing pointers as outputs. Both of these examples are invalid because it is assumed that a QPU and the host CPU will share different address spaces. The currently library mode compilation flow would treat compile them anyway despite not truly being executable on a real quantum system. See https://nvidia.github.io/cuda-quantum/latest/specification/cudaq/kernels.html for more details about data type restrictions on quantum kernels. The exact details of what is supported and unsupported may evolve over time, but I believe the validity of the specific examples I gave above are unlikely to change. Hopefully that helps.
Got it. Thank you very much.
