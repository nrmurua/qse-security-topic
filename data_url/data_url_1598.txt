Is your design idea/issue related to a use case or problem? Please describe.
The fact that the following assertion fails is a continuous source of issues in Cirq:
Some workarounds have been attempted (e.g. op.untagged) but they clutter the Operation class and ultimately don't solve the core problem, as TaggedOperation is not the only Operation-wrapping class. ControlledOperation and other planned behaviors also wrap the Operation class.
Describe your design idea/issue
The wrapt python module provides transparent object wrappers with ObjectProxy, the behavior of which is best described by the following code snippet from their documentation:
By subclassing ObjectProxy with the operation-wrapper types, we can reduce boilerplate code (as all methods of the wrapped class are made visible in the wrapper) and safely rely on isinstance(op, ...) for determining operation types.
Nice, this follows the kind of mixin behavior I always thought tags should behave with - i.e. keep the original type but also get the tag. I like that wrapt has 94% coverage, and the maintainer seems knowledgable. 1.5k stars are a relatively good sign of usage / popularity in this space.
However, bringing in a library for this kind of core behavior always irks me a little bit, there is always maintainability risk with that.
From this comment it seems that the single maintainer is in the process of finding someone to do the maintenance instead of themselves.
To be confirmed, but, wrapt has c code in it, and only seems to publish source distros to pypi, which means that whoever tries to install it will need to have the right c++ compilers installed as well, which might mess with our installation experience.
I would create a prototype though quickly and see how it works with tags, as if this is the direction we agree to go on, we could find a way to implement maybe a specific version of it only for TaggedOperation. I just wouldn't trust wrapt at this point.
+1 to what @balopat said. I'd hesitate to bring in any dependencies that muck around with the object model of python itself, such as trying to change how isinstance works. I think moving tags into Operation itself would make more sense in this case. I'm not sure I fully understand the issues with ControlledOperation, but it seems to me that you'd want isinstance(ControlledOperation([q], FooOp(...)), FooOp) to return False because adding controls does fundamentally change the thing an operation is doing.
+1 to what @maffo said. I believe that instances of the wrapper class (eg: TaggedOperation)  should return False when checked against the untagged class type because of the way python's object model works. Also, in most classes, the wrapper classes fundamentally change some behavior of the operation -- TaggedOperation can change the decomposition behavior, ControlledOperation change the applied operation itself, ParallelGateOperation has a different unitary compared to the wrapped operation etc.
Also, the concept of a "wrapper" class can be extended to other core types in Cirq as well -- for eg, we could argue that a GateOperation is a wrapper on top of a Gate as every GateOperation represents an underlying gate with some extra added information on top of it?
IIUC, For gates and gate operations, the issues occur because of incorrect / incomplete usage of the isinstance checks. For eg, checking for isinstance(op, GateOperation) instead of op.gate is not None to check whether the operation has a gate, etc.
To handle such issues, my proposal here #2536 (comment) is to replace isinstance checks with cirq.match and handle the various isinstance cases in cirq.match.
Thanks everyone for your analyses! The concerns raised are valid, and given that the core purpose of this request is to simplify identification of operation types I think a cirq.match function would suffice.
