We can close this without a fix, but I just wanted to capture what was happening in Qiskit-Extensions/qiskit-experiments#1060 in case there is any follow up work that would be worth doing. The main issue was that QuantumCircuit.barrier() does not officially support a tuple import but kind of works okay with it any way.
When you run the reproducer code, you will get a decoding error. The problem is that barrier() does not support a tuple input. qc.barrier((0, 1)) results in a Barrier instruction with num_qubits=1 but two qubits in its .qubits. qpy.dump() will write this into the binary and then fail when it tries to load only a single qubit where two were written.
What should happen? It's fair enough that an error occurs after passing an invalid type to barrier. The things I wondered about though were
No response
We should have errored out at some point during QuantumCircuit.barrier (either directly, or in QuantumCircuit.append, or in Barrier.broadcast_arguments).  It's correct for QPY to not verify the circuit object; the point of encapsulated data is that it shouldn't be allowed to get into an invalid state.
I think Instruction.broadcast_arguments is an instance where the API split is wrong (imo broadcasting is something that QuantumCircuit should be responsible for within only one or two modes), but given that in the current situation that's the party responsible for checking, then I'd say that in the immediate term Barrier.broadcast_arguments needs to gain the check of qubit and clbit counts.
