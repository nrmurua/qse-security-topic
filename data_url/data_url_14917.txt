Majority of the quantum info classes implement an __array__method for converting to a Numpy ndarray. This is usually fine, but if I want to use Numpy object arrays (eg for their fancy indexing/slicing/iterating etc), with quantum info objects as the values, trying to construct these arrays so far seems impossible without numpy calling the __array__ method.
This is particularly problematic for Pauli / Clifford operators which have efficient object representations but are converted to 2^n, 2^n complex matrices by this method.
To demonstrate this issue, we can make a subclass that prints when its array method is called:
Now if I try and initialize an object array from a nested list of Pauli's, you can see the array method is invoked and a complex "object" array is returned:
However if I try and initialize an empty array first, and then set the values via slicing the returned result is "correct" (ie what I want), though it still invokes the array method:
You can check this breaks by doing [Pauli_(100 * "X"), Pauli_(100 * "Y")] which errors ValueError: Maximum allowed size exceeded.
For singleton arrays, the array method is also invoked if you do
The only way i've managed to find to avoid this is to explicitly iterate over a nested list and set individual values (which is undesirable):
and for for shape () arrays to use fill:
The end result of the above code produces what I wanted, an object array with Pauli objects as the values, however how it gets there breaks for anything but trivially small Pauli's since it is needlessly constructing the 2^n 2^n operator matrices for the Paulis when Numpy calls the __array__ method of each object and then presumably discards it.
I've been kind of stumped by this for a while. Some work arounds I've come up with are:
With the above, when the array method is called, it avoid the matrix conversion for the object case. However this changes the return type of np.asarray(Pauli("X"), dtype=object) from array([[0, 1], [1, 0], dtype=object) to array(Pauli("X"), dtype=object) (which is for me, but might not be technically correct?)
Your best bet is probably to do np.fromiter(your_iterable, dtype=object, count=len(your_iterable)), which is guaranteed to create a 1D iterable with the data objects directly.  If you're after nd arrays, I think you'll need to do things more manually.  For example:
(you can technically omit the count argument, it just won't be as efficient.)
Since the quantum_info classes implement __array__, the behaviour you're seeing is expected; it's what Numpy's meant to do when something is explicitly saying "you should treat me as if I'm an array".  It'd be the same problem if you were trying to turn a list of Numpy arrays into a 1D object array of arrays.  We shouldn't override __array__(dtype=object) to break that; that would be even more surprising.
I'd tend strongly towards classifying this as "won't fix" on the basis that it's not a bug; we can't have things two ways with regard to implementation of the __array__ interface, and we've long since chosen the "you should treat me as a matrix" path there.
I will remove the bug label here and instead open an issue on Numpy (and see if they think this subset is a bug): numpy/numpy#24336
Given that we tracked this down to a) Numpy behaving correctly during array-creation and b) Numpy appearing to overlook a corner-case in array-slice assignment for object dtypes, both of which are outside Qiskit's control/responsibility, I think we can close this as in issue on Qiskit?
To be clear for others, the general principle is that Numpy directly supports array creation of object dtypes for inner arrays like this using numpy.fromiter for 1D arrays, and it's up to the user at the moment to be more explicit for ND arrays.  Assigning into slices appears to overzealously attempt to coerce to arrays in Numpy, but that's a bug on their side (probably - up to them to decide), and either way, there's nothing to be done about it from Qiskit's side.
The only thing that we could consider is removing __array__ from the affected objects and replace it with a to_matrix or similar method.  The current system of quantum_info objects saying "you can treat me like a matrix" is already useful, and we'd be making that more painful and forcing users through an API break if we were to re-optimise to make it marginally easier to construct ND object arrays (for which alternative, efficient methods also exist).  Given that we already chose a path, and there are totally valid ways of achieving the goals in this issue, we shouldn't break API stability to change from one preference to another.
For anyone interested this is a workaround for initializing these sort of arrays (assuming you know the correct shape ahead of time)
