Here is a test case.
The same matrix produces two different sets of eigenvalues:
The evals() is correct and hevals() is not. The T gate is not even Hermitian, is it? Should hevals() throw an exception or something when its input is not Hermitian?
The problem seems to boil down to the the Eigen::SelfAdjointEigenSolver<cmat>, which does not check whether the input is Hermitian or not.
@DevelopDaily qpp doesn't do many of the more "high-level" (logic) checks, such as unitarity, hermiticity etc. It only throws exceptions for blatant mismatches, such as incorrect set of dimensions, tracing out non-existing subsystems etc. I decided to go this way since otherwise it'll be way too many "logic" checks that may significantly slow down the program. I've updated the Doxygen comments for each function so it makes it clear.
For example, I do not check whether a set of POVMs sum up to identity. If they don't, then the induced measurement probabilities one obtains will of course not sum up to one. Checking all those cases at runtime would be a nightmare, so I just assumed that the user is wise enough :) Or, one can write those checks on demand, so qpp core doesn't have to pay the overhead.
Of course there is the option of doing those checks only on DEBUG mode, but frankly it's a bit too much effort for the benefits. And sometime it restricts what one can do. Since I do not check e.g. POVMs to sum up to identity, one can just "peek" into issues like "probability of obtaining the result of the outcome 0", without having to compute all of the others, etc. Or implement post-processing filters ("gates" such as |0><0| with qpp::apply, with no check whether |0><0| is unitary (which is of course not)).
OK. Thanks.
