I've been stewing on this for the last few days.
Originally I added the extensions mechanism in order to solve something akin to the expression problem. Since then it kind of grew into a convenient way to ask things if they support a feature, to the point where we have cirq.cast.
But what value are we really getting out of this? It is easily the most abstract and complicated-to-use-correctly part of the library. Worryingly, it has wound its way into the way you perform basic tasks such as defining a gate. In principle it allows people to post-facto add features to a class and explain to library A how to use library B, but we're really not at the level of scale where that is a problem in the first place.
More seriously, I think extensions is doing something that is really a language-level task. It is not the job of a library to solve these kinds of problems. Or, at least, you would want the library to only be about that. Because otherwise people coming in from the rest of python-land have no idea why everything is done differently. It is an extremely unpythonic feature.
I think we should cut the extensions mechanism out. The key thing that would make this possible is to refactor all marker classes to have "can't do that" outputs. For example, KnownMatrix.matrix() would be allowed to return None to signify "I do not have a known matrix [e.g. because I am parameterized]". This would obsolete PotentialImplementation.
All of that being said, there may still be some use for extensions. But I think we should think of it more like a way to make existing gates smoothly go through your own code as part of implementing a feature, as opposed to defensively asking for an ext instance that you don't know what it would be used for.
Please chime in with your opinions.
I never understood this part of Cirq so I can't really comment. This despite having seen it come up a couple of times and reading the docs about it. Perhaps that answers the question.
I agree with everything @Strilanc said. This is a confusing feature and it will be much easier on contributors if we just do things the normal way (returning None when something is not implemented).
I think I mostly agree.  The conceptual overhead is high.  Another problem is that it is easy to write code that doesn't take in an extension, and then have to go back and  fix this when you realized that you hadn't passed in an extension.
The one place that it has been useful, at least for me, is dealing with different gate sets.  But I think we could deal with this by being more explicit about gate sets and conversion.
I am also in favor of removing the extension mechanism, which feels like an awkward fit for python. I think having methods that can return optional values is probably ok, though None is not always a good signal because there are cases where it could be in-band. Might want to return NotImplemented instead (or raise NotImplementedError). In some cases, it might also be helpful to have is_foo or has_foo test methods that just return a boolean indicating whether a certain feature is implemented, for cases where you'd like to check that an object implements a particular feature without invoking a potentially expensive computation.
Also, +1 to the idea of dealing with gate sets in a more generic way. I think this would be very useful, but unfortunately I don't have many concrete suggestions on how it should look.
Very well, I think that makes a strong consensus. I will start cutting down the extensions tree.
After playing this out a bit for KnownMatrix, and thinking about it overnight, I have a different idea of the refactor should play out.
Instead of requiring classes to implement KnownMatrix, it should be more like a "reference type" that we use to make mypy happy. At runtime all we should care about is the presence or absence of specific methods. This would put us inline with how the rest of the python ecosystem works. For example, there is no "Addable" interface there is only the __add__ method. You make yourself addable by implementing __add__, end of story. Numpy has a similar strategy, but with methods like exp; if you call np.exp(c) and c is an instance of a custom class that defines an exp method, numpy will delegate to that method instead of failing.
Secondarily, a problem I immediately noticed when using the optional-result version of KnownMatrix is that you have to cast all over the place because you often know that the result is not None but mypy can't figure it out. As such, I think we should actually have these methods come in threes: thing() -> T, has_thing() -> bool, and maybe_thing() -> Optional[T] where thing() and has_thing() can be specified, but if not they delegate to maybe_thing. When maybe_thing() returns None (or maybe NotImplemented?), thing() would raise a TypeError (or ValueError?) and has_thing() would return False.
Thirdly, since classes won't always specify these methods (or say they implement the marker type), we need an easy way to say "if the maybe_thing (or similar) method is present, use that, otherwise return None". A nice way to do this would be with top-level methods like cirq.maybe_thing(x).
I think this design is significantly more pythonic. It is based on duck typing and matches the style of numpy and python itself.
Talked about this with @Strilanc in person, but just leaving a comment here for the record:
mypy supports ducktyping via the "Protocol" mechanism (https://mypy.readthedocs.io/en/latest/protocols.html#protocol-types). That should be very useful here to keep mypy happy.
We also decided that we should use method names like _thing_ instead of thing, because then the obvious canonical way to get at thing would be cirq.thing(x) instead of x.thing().
Renamed bug as we decided to move to protocols instead of extensions.
Craig how much work do you estimate this will be?
Is anyone working on removing extensions from expand_composite?
It's at least 2 weeks work altogether, though there will be some overlap with other cleanup tasks and given my schedule lately that 2 weeks could stretch into 2 months.
What needs to be done is, for each feature interface, replace it with a magic method. This involves global refactorings that can't be automated AFAIK. We could probably pick a couple of them to be done by contributors, but there are some I want to do myself (the main one being KnownMatrix, though that's done now).
