Is your design idea/issue related to a use case or problem? Please describe.
Related to #4034 (zip/on_each),  #2164 (TwoQubitGate etc.), and probably part of #3242 (organize gate relationships)
Describe your design idea/issue
There are lots of diamond dependencies among gates. I propose we clean this up by adopting a mixin-like design for "behavior-specifying" gate subclasses. This allows us to keep the composability of behaviors, while keeping our class hierarchies linear. I've started looking at this in PR #4210 for ThreeQubitGate. As a mixin, this would still allow us to add typesafe e.g. on_each(Iterable[Tuple[Qid, Qid, Qid]]) for three-qubit gates etc., via inheriting the mixin, but without creating a diamond dependency.

This is potentially interesting for identifying types of gates (e.g. CircuitOperations wrapped in TaggedOperation), but I think we need additional evidence of added value to actively pursue this.
Interesting, I thought this would be a slam dunk. Is it that diamond dependencies not considered antipatterns in Python / Cirq? Or just that options other than mixins would be preferred? (I can't think of anything that would be as clean).
While diamond inheritance in Python still has the potential to cause confusion, it at least results in consistent behavior due to Python's use of method resolution order. For example, class A(B, C) will always search for a given method in A, then B, then C. Sub-classes can also specify which parent's version of a method to call, if necessary.
In the end, it's a matter of priorities: without a clear benefit beyond type-hierarchy sanitization, there isn't incentive to prioritize this over existing issues.
I was thinking about using mixins for modeling some special behavior, e.g. TaggedOperation. I can imagine num_qubits to be mixable for some named cases e.g. ThreeQubitGateMixin, but the usefulness is a little bit unclear (as the gate.num_qubits == 3 is similarly expressive and user friendly).
I'm a bit confused about the key issue here and the severity of it. The diamond problem is only an issue when both parent classes override the method from the grandparent class. Do you see an example of that? I.e. Gate <- EigenGate, TwoQubitGate <- CZPowGate might seem like a diamond but there is no method conflict. Also, as @95-martin-orion said, MRO provides a way to resolve conflicting situations.
Can you elaborate a bit more on the "behavior-specifying gate subclasses" idea? What would fall under mixin category? What would still stay strictly a subclass?
It's actually not so bad as I thought. We're already planning on getting rid of the SingleQubitGate etc., so the only one left that I see is Pauli, which is just used internally. Pauli can also be converted to a mixin with a four-line code change if we want to.
I don't have any specific issues with the diamond dependencies. Just after 20 years of hearing "multiple inheritance is bad", I assume we'd want to avoid it if we can.
Oh one other thing: I think having a strict tree for hierarchy might make it easier to reason about things when we get to pattern matching. Diamond dependencies may make that more of a challenge (or maybe not at all...I can't name a specific reason, it's just a feeling).
Closing since the issue will probably be taken care of organically.
