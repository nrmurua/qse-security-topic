sscope.setup_attributes returns:
OrderedDict([('avg', 1), ('curve_name', 'scope curve'), ('input1', 'in1'), ('input2', 'iq0'), ('duration', 0.000131072), ('average', False), ('trigger_source', 'ch1_negative_edge'), ('trigger_delay', 0.0), ('threshold_ch1', 0.5), ('threshold_ch2', 0.0), ('ch1_active', True), ('ch2_active', True), ('rolling_mode', False), ('running_state', 'running_continuous')])
I have a perfect signal on ch1 (FP resonance) which ranges from 0.1-0.8V and which is periodically passed. Nevertheless, the scope in continuous mode freezes after a few seconds and has to be re-engaged by clicking "Stop" and "Run continuous".
We had a similar bug before related to the scope triggering logic, could it be that its fix got lost in rewriting the scope module?
OK, I guess the scope needs an extra clean up pass, because in the present version, I just copy pasted what used to be in _setup into _start_acquisition, but in fact the whole code could be much clearer now that we can simply use the call_setup trick whenever a crucial attribute is changed (the situation was messy before because setup was not supposed to be called for some running_states like 'paused' or 'stopped' , so every attribute had to make sure he would not screw-up the current acquisition when its value was changed). The only thing that is not fully clear to me is what sequence of actions does the hardware need to start the acquisition... And I guess the devils hides in the details (for instance, what happens if the curve acquiring is done while processing these actions....)
I am not sure if you are already on it, or if I should do it?
no, please go for it. and maybe go through acquisitionmodule at the same time
I believe this is now solved
