The nightly benchmark runs have flagged several run time performance regressions after #7087 merged:
none are huge in absolute time (on the order of ms) and likely won't be noticeable in a larger transpile() call or application but we should try to fix these because #7087 really shouldn't have had any performance impact.
Run any of the transpiler passes identified in the regressions linked
The addition of a new abstract class defining the interface for a circuit operation shouldn't cause a noticeable performance regression
Identify where the passes are spending more time after the addition of the Operation class and fix the bottleneck.
After a bit of experimenting with the first problematic testcase (passes.MultiQBlockPassBenchmarks.time_collect_multiq_block), we see the following (we = Shelly, Eli and myself):
What would be the best way to proceed? Should we get rid of dependence on ABC? Should we try to optimize the number of times isinstance is called in this transpiler pass? Or maybe the slowdown is acceptable?
The __instancecheck__ mechanism of ABCMeta is to allow a registration method for classes that don't actually inherit from the defined type, like the generic types in typing (dict appears to be an subclass of typing.MutableMapping, for example, even though it doesn't actually inherit from it).  This is why isinstance is slowed on ABCs than other things.
We can't give up isinstance; it's the correct way to test the types of objects when they may be inherited.  It's also the reason we put in this class at all, to ensure that QuantumCircuit has an easy way to check that an object is of the right type - it's just got to inherit from Operation.
Perhaps we could define a lightweight metaclass that inherits from ABCMeta but rebinds __instancecheck__ and __subclasscheck__ to the relevant unbound method from type.  That should remove the overhead back down to pretty much exactly what it was before (technically it'll be marginally slower because there will be an extra MRO entry in most classes, but it shouldn't be noticeable).
For topological ordering, can we eventually get rid of using isinstance to derive the ordering labels by relying on proper polymorphism instead ? i.e. if all circuit elements derive from Operation,  we can think of a polymorphic method that returns some ID info which can be leveraged by many algorithms. Though run-time type resolution is very common in Python for functional purposes (e.g. not just input validation), I think it should be avoided whenever possible
For topological sort we shouldn't be relying on isinstance anywhere. For the lexicographical topological sort we do the tie breaking string sort key is str(qargs) and the rest of the sort should be isolated to retworkx internals. The place where we use isinstance more is filtering over the sorted nodes to get only gates, which we need to do to find the ordered subset of operations in the circuit which are gates. We could add a slotted type or gate boolean attribute to do the same which probably would be faster than isinstance with an abcmeta.
The sort key here is specific to CollectMultiQBlocks; it's not the default sort key for DAGCircuit.topological_sort, which does use object polymorphism (sort of) by accessing x.sort_key.
edit: Matthew just said something pretty similar haha.
I don't see why we should have a gate Boolean instead of a Gate interface.  That's kind of the point of #7087 in the first place - having those features be a defined interface means you can attach extra functionality, and you get static type-checking that the operations you want to perform are well defined.  It's also something we explicitly removed from DAGNode.
So it seems we should live ABC as a base class for Operation and treat the performance degradation either in collect_key. @jakelishman what do you mean having a Gate interface instead of a gate Boolean, without using isinstance ?
I think you've misunderstood me here - I think the best way to treat the performance is to change the base class of Operation to use a metaclass that has the original versions of __instancecheck__ and __subclasscheck__ that avoids the ABC.register overhead checking.  I also think the usage of isinstance(x, Gate) is appropriate in this key function; it needs to find out if a particular circuit Operation also implements the more specialised interface Gate, and that's the exact reason for #7087 in the first place.
I'd agree that using run-time type information is bad if you're trying switch on all possible subclass instances to do something different - that's absolutely something polymorphism should be used for - but in this case there is specialist behaviour that is necessary only for one specific subinterface to Operation.  If we wanted to use polymorphism over all implementors of Operation here, we'd have to add a dummy method to Operation, simply so Gate can override it, and everything else can ignore it.  Anything that wants to be treated as a gate should inherit from Gate to be properly polymorphic, not try to use gate-specific hooks without implementing the rest of the interface.
Gate is actually a concrete class that can be instantiated, but really we treat it as the "unitary circuit operation" interface throughout Qiskit, and we require that all such operations inherit from Gate, so isinstance is the appropriate check to me.
I think this needs some more investigation before picking a direction here, especially to determine if we would expect this slow-down to grow as we increase either the number of operations in a circuit, the number of operation-types or something else.
https://qiskit.github.io/qiskit/#circuit_construction.CircuitConstructionBench.time_circuit_construction?commits=05b60a5e
https://qiskit.github.io/qiskit/#circuit_construction.CircuitConstructionBench.time_circuit_copy?commits=05b60a5e
https://qiskit.github.io/qiskit/#converters.ConverterBenchmarks.time_dag_to_circuit?commits=05b60a5e
https://qiskit.github.io/qiskit/#converters.ConverterBenchmarks.time_circuit_to_dag?commits=05b60a5e
https://qiskit.github.io/qiskit/#ripple_adder.RippleAdderConstruction.time_build_ripple_adder?commits=05b60a5e
https://qiskit.github.io/qiskit/#ripple_adder.RippleAdderTranspile.time_transpile_square_grid_ripple_adder?commits=05b60a5e
Possibly helpful reference: https://stackoverflow.com/questions/42378726/why-is-checking-isinstancesomething-mapping-so-slow
After investigating this a bit more (using cProfile):
is faster than calling (polymorphic) functions:
and in the PR we have indeed changed name, num_qubits, and num_clbits to be properties. I believe this is what's responsible for basis_translator and assembler benchmarks.
(Note: if it would help, I could upload my profiling results somewhere).
Here are some numbers on a toy example, with classes
So, working with fields directly (especially bool ones) seems fastest (and does not depend on whether the base class inherits from ABC or not). Specifically, for CollectMultiQBlocks this would mean keeping a field in DagNode representing whether it's a DagInNode or DagOutNode, but (if I understand correctly) this is very closely related to what we are trying to deprecate.
I have tried to implement @jakelishman 's suggestion as follows (and probably did not do it fully correctly):
but on the toy example it did not improve things compared to inheriting from ABC. If this wold help, here is the profiling data for Base not inheriting from anything, vs. Base inheriting from ABC_Hack vs Base inheriting from ABC:
Thanks for looking into this @alexanderivrii .
PR we have indeed changed name, num_qubits, and num_clbits to be properties. I believe this is what's responsible for basis_translator and assembler benchmarks.
Interesting, this seems like a likely culprit. It might be interesting to see if this can be mitigated by using class-level attributes, e.g.
This should satisfy the ABC requirements and be faster, and be more common than the case where these properties need to be dynamic (and thus @properties). (See also: #6883 )
(Note: if it would help, I could upload my profiling results somewhere).
I believe you should be able to attach files in the Github UI (by clicking the lower bar or drag and drop), but failing that, flamegraphs or cProfile outputs are still helpful.
For 0.20, since the circuit and transpiler are still using isinstance(..., Instruction), we should remove Operation as a base class for any of the instructions in the circuit library and defer the release note until we can investigate further.
