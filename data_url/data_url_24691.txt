The PulseStorage holds pulses in temporary storage only when they are written until an explicit call to flush() writes changes to the storage backend. It needs to be ensured that all changes are written by the time the PulseStorage object is destroyed to avoid losing unflushed changes.
I recently put a call to flush() into a del() method of PulseStorage. However, del seems to not be called in a predictable manner (or at all in some tests) due to garbage collection weirdness (and its use is discouraged by the community), so this is not really an option.
The only secure way I can see to ensure storage in the backend thus would be to always write pulse changes to the backend immediatly..
Opinions, @terrorfisch ?
You can make use of the with-pattern in python for context management, similar to file handles. See contextlib for details.
I was considering that, but it's not really a nice solution..
it would either mean wrapping the whole code in a with PulseStorage:-block or that everytime a pulse is put into the PulseStorage, this would need to be within a with-block. Neither makes for nice code, especially considering that the dictionary-like interface of PulseStorage was chosen with the intent of easy readibility (which also implies to the user/programmer that no special care must be taken about storing values, so this should be something handled impicitely by the PulseStorage class..). The latter option would, additionally, result in the same behavior as just writing pulse changes to the backend in the PulseStorage class as proposed above, so there's no benefit.
A fix is pushed in branch issues/281_pulse_storage_flushing . that branch is in turn based on 250_serialization_backward_compatability, so a pr will have to wait until #266 has been merged.
The implemented fix is to bundle the serialization of a pulse and all its subpulses (i.e., one external interaction with PulseStorage) in a transaction conceptually (managed internally by PulseStorage) and write all new serializations to the backend immediately. This way, PulseStorages internal temporary storage and the backend do not desynchronize and the flush method is obsolete.
Fix ist merged into the serialization overhaul branch
