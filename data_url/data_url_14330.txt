By default, powering a Gate returns a UnitaryGate. This is inefficient because it numerically calculates the matrix exponential, and it discards information about the gate that could be used for efficient compilation. This can be addressed by overriding the power method for certain gates, including:
Update: #9318 overrides power methods for many common gates, but some are still missing. For example, XGate and YGate. As discussed below, what seems to be missing is some additional gate structure that allows a gate to declare how it can be efficiently powered.
We could also add XGate.power(0.5) --> SXGate and -0.5 to SXdg.
It's worth considering whether we can add some additional structure to the gates. For example,
Such changes would reduce code duplication and simplify identification of gates for efficient compilation.
As discussed in the meeting, these inheritance structures could lead to issues if the parameters of the child are not the same of the parent. Assume that ZGate inherited from PhaseGate, something like
then in the code I could do
and suddenly my "Z" gate is the identity! ðŸ˜„
Could you give some concrete examples from existing Terra code about how OOP inheritance would reduce code duplication and improve compilation efficiency?
Terra already has a mechanism for describing these relations: entries in the relevant EquivalenceLibrary (we use the name field as the key, which also lets us safely {,de}serialise custom user gate objects without needing to run arbitrary code).  This strictly more powerful, because it can relate one gate to several different compositions, each of any number of other gates.  It better represents the fact that these gates don't have a unique hierarchy - as a slightly reductive example, the I gate is a special case of any of U, P, RX, etc, but that set doesn't have a total subtype ordering under any useful definition.
I'm also concerned that while the mathematical Z gate is a special case of the mathematical P gate, that doesn't necessarily make it a valid subtype in the OOP sense.  For example, the number of parameters required to specify the operation, which is a class invariant, is not the same between the two objects.  As a concrete example of how introducing hierarchy between Z and P wouldn't necessarily help here without even more data changes: in order for the proposed custom PhaseGate.power to be automatically inheritable by ZGate, the latter would have to have its "phase parameter" accessible somewhere on the gate, defined by the parent.  This can't actually be params (because that implies mutability, which can't be inherited here), so it would have to be a separate field.  Since PhaseGate would still need its params field to be mutable, its params getter and setter would now have intercept all modifications (either to the entire params or to its __setitem__) to also mutate the other value.  We've had no end of problems with CUGate because it tries (poorly) to do exactly that.
In general, we don't use class hierarchies to specify the type of a gate, we use the gate name.  In my (admittedly relatively shallow) experience in building type-system descriptions within parsers, I've so far found that I've often started off trying to categorise things like you have done here, but it's always fallen apart for me as I've got deeper into it, mainly because these type-like objects are almost always only partially hierarchical.
fwiw: I totally support various gates gaining more accurate power methods, as mentioned in the actual head of the issue.
Thanks all, I agree with your assessment. The inheritance was not a very well thought-out proposal. I think that the structure I speak of will only be achievable once we support singleton Gates. Then, ZGate can just be an instance of PhaseGate with the angle equal to pi. This would reduce duplication because the ZGate class could be deleted. As for simplifying compilation, I'm talking about places in the code that check for special cases of gates and do something based on that. I think the equivalence library for standard gates is a good example: https://github.com/Qiskit/qiskit-terra/blob/b45afea03662bf4a2905251e26cbc008bdb3c0e1/qiskit/circuit/library/standard_gates/equivalence_library.py. Also, lines such as these which list different kinds of Z Gates: https://github.com/Qiskit/qiskit-terra/blob/19fdd32affd37afb58774f40bcf509b16480fe63/qiskit/transpiler/passes/optimization/commutative_cancellation.py#L57
That's fine, it's good to discuss!  Let's revisit the issue more when we've made some progress on getting the state out of Gate.
For your example: I'm not sure OOP hierarchy can represent this, entirely.  For example, both rz and p are in that list as being "rz-like", which in this case is only equivalence up-to-phase, rather than exact equality.  That might be ok in this case, but it causes differences if the gate becomes controlled, say, so other places that handle them might prefer subclassing to mean "child is a special case of parent".  If we try to resolve all the possible ways into one unique hierarchy using a lot of levels of abstraction, I suspect (without proof) that we'll end up with highly highly abstract intermediary levels that don't fully do their job anyway; you still end up with the " $I$ problem" I had above, where it's a special case of many different incompatible gates.
I think it makes sense to add a global_phase parameter to most or all gates. In that way rz and p can be unified.
#9318 overrides power for many common gates. It doesn't address XGate and YGate because there aren't analogous powered gates (for ZGate there is PhaseGate). I think we should add those gates.
