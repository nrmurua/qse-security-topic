As @garrison commented #1388 (comment), #1388 breaks some existing codes, for example,
It broke CI of Qiskit applications and we fixed the unit tests.
It may affect users' codes as well. Is it an intentional behavior?
References
qiskit-community/qiskit-optimization#298
qiskit-community/qiskit-finance#124
To some degree it's intentional, because we needed to change the return type to something which has strictly more features than the Numpy array, and doing the changeover period completely safely for down-stream uses takes prohibitively long.  That said, we put quite a bit of work into trying to ensure that code relying on Numpy methods would continue to work after the swap (with deprecations), so we can make this work too.  Calling a Numpy function on the returned result will still work as expected, as will trying to use Numpy-specific array methods on the object.
In this case the issue is that we forward Numpy methods to the underlying Numpy array, but __len__ is a general Python magic method that Statevector doesn't implement, so it got missed in the forwarding.  We can make that work as before.  __getitem__ is implemented by Statevector, though, so we can't override that.  Thanks for the example of what actually broke - just from the previous comment, I couldn't tell what the problem was.
Thank you for the information. It would be helpful if compatibility.Statevector has __len__.
I've added the magic Iterable methods in #1401 - could you check if those are all that's required for optimisation and finance and any in-progress PRs on them?
@t-imamichi Keep in mind jakes fixes will be removed ASAP in Aer (likely 0.11) so code that relies on this needs to be updated to use Statevector/Operator API instead of ndarray, or these methods like  __len__ should be added to the actual quantum info classes.
@chriseclectic Yes, I understand it. Our codes are ready to use Statevector and CI works fine again. I worried about users' codes; but #1401 looks good because it outputs a deprecation warning.
Our fixes:
qiskit-community/qiskit-optimization#298
qiskit-community/qiskit-finance#124
I might be missing something, but it sounds to me that if #1401 is merged as-is, and if later __len__ is added to the actual quantum info classes, then the situation will result in this code pattern emitting a deprecation warning on Aer 0.10, but then working again as expected (without any warning) on Aer 0.11.  If this is a likely possibility, then why mark __len__ as deprecated at this time?
We have to emit warnings based on the current state of the code, otherwise we're likely to get out-of-sync, and it's easy to accidentally change or remove something without any warning.  If the new code actually does arrive, we can remove the warning again - there's no issue with removing a warning without comment. Right now, Statevector doesn't have __len__, so the only way you can be validly accessing __len__ on the compatibility class is if you were relying on it being a Numpy array.  That's deprecated behaviour, so there's a warning.  If Aer 0.11 were to release before Terra 0.20 and remove the compatibility classes, we'd be breaking code without a deprecation warning.  We're not guaranteed to add __len__ to Statevector even in 0.20 (though we likely will).
In an ideal world, the deprecation procedure for this would have been much longer, but we didn't actually expect people to be using things in this manner - it's generally got poor performance in Python to try and use Numpy arrays as regular iterables (as is being done in the two test failures there), and if the code was accessing them as Numpy arrays (result.shape or result.size), the compatibility shims would have taken care of it.  Regular Statevector also behaves like a Numpy array when given to Numpy functions.
