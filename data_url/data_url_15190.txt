HEAD of main, currently dd7f9390cf07
3.11.1
Both macOS and ubuntu, so far.
import test.python raises an error in 3.11.1, therefore tests do not run. @wshanks has indicated that it is working fine for him in 3.11.0 but not 3.11.1 (I don't have 3.11.0 installed).
Or, see an example of this happening in CI: https://github.com/Qiskit/qiskit-experiments/actions/runs/3704009805/jobs/6281449337
Run the tests or simply import test.python in Python 3.11.1.
This should not error.
No response
I'm having trouble reproducing this using only wrap_method. For example, the following works as expected:
If it works on 3.11.0 maybe python/cpython#99646 is related which touches TestCase.__init_subclass__? Though it's weird that the failure isn't happening consistently, in some of the CI runs only Mac and in some only Linux failed..
please, revert #9296 when fixed.
I did a bit more digging and I think that python/cpython#99646 is, surprisingly, unrelated to this issue. I believe there has been a change in Python itself that breaks the way qiskit.utils._WrappedMethod.__get__ deals with __init_subclass__. I can't find the change in the 3.11.1 changelog, but didn't look as hard as I could have. That the change to TestCase appears in the same release is just bad luck.
Consider the following:
This snippet summarizes the path that qiskit's wrap_method and _WrappedMethod take to grab  the underlying __init_subclass__ method. In Python 3.11.1,method as defined above is not a bound method, but in previous Python versions, it is. Hence the TypeError when it's called without cls as the first argument.
Looking back, I think I over-engineered this machinery in response to a minor problem, mostly because I was enjoying learning more of the Python internals. That said, at the top of the file there's some special handling for the magic methods that lie about their implementations; you might be able to fix this by adding the __init_subclass__ string to the relevant set at the top of the file, if it's now an implicit class method rather than explicit one.
Yes, I think the issue requires both the unittest change and a change to how __init_subclass__ is treated in 3.11. __init_subclass__ is a weird case that gets converted into a classmethod (according to the documentation; what that actually means I am not sure and I think might have changed in 3.11) and I think the decorator/wrapper code might mischaracterize it now.
#9310 is a test of that idea.
I think something like this might work across versions, but I've never run terra tests locally and I need to figure out what I'm doing wrong invoking them :) (currently something about _accelerate circular imports)
qiskit.test.decorators.enforce_subclasses_call is a class decorator that wraps specified methods of the class in wrappers that set a flag when the method is called and wraps __init_subclass__ in a wrapper that then wraps those methods on subclasses to clear the flags and then make sure the flags are set after the call.
The wrapper code distinguishes between methods defined on type and other methods and uses type.__getattribute__ or object.__getattribute__ accordingly here. This is the part I don't completely follow (though there are nice comments by the code). I can't find documentation on the difference between type.__getattribute__ and object.__getattribute__ (beyond reading the Python source code). I think that something funny happens with __init_subclass__ between the way it gets converted to a classmethod and the way it is bound to the class variable. The change in behavior might be related to the performance work that was done in 3.11 which I think worked on optimizing attribute access.
This code mimics how the qiskit method wrapper handles type methods and other methods:
On 3.10, I see
while on 3.11 I see:
In #9310, I just force __init_subclass__ back to the object getter instead of the type one. There may be more that is good to adjust by someone who understood the distinction between object.__getattribute__ and type.__getattribute__ better than I do.
@ihincks When I see a message about _accelerate, it is usually because I forgot to run pip install . after switching branches or Python versions (because it is the first compiled thing that is imported).
I can't remember all the details off the top of my head, but I'm fairly sure the differences are in how they apply the descriptor protocol - object.__getattribute__ fills in the fields like instance calls, and type.__getattribute__ fills in the fields as if they're class calls (because of course that's what's happening).  They have slightly different interplay with __new__, __init_subclass__ and __prepare__, which are "magic" descriptors (they bind differently to how their definitions would appear), but I can't remember / maybe never knew what that is.
There's a bit of description here (and near here). If @wshanks patch passes tests I'll personally be happy, because it's unlikely that these machines will ever test the magic methods in ways beyond what enforce_subclass_call currently does ðŸ˜„
My original suggestion was actually wrong and the one from @ihincks was closer to the right solution. Mine "worked" but only by chance for the specific circumstances covered by the tests. By forcing __init_subclass__ back to object.__getattribute__, I just forced the wrapper to call object.__init_subclass__ instead of the wrapped class's method. For the tests, that had the effect of just bypassing unittest.TestCase.__init_subclass__ (the only wrapping of __init_subclass__ in the tests) which does not do much so was not missed by the tests, but bypassing __init_subclass__ obviously would cause problems if anyone ever wanted to use __init_subclass__. I described the issue in #9310 in detail. The short version is that the classmethod was getting converted to a bound method by __getattribute__ and then unbound by __get__. Ian's solution detects the classmethod to bound method conversion by checking for __self__ and skips the call to __get__ that unbinds the function. #9310 instead avoids the classmethod to bound method conversion by avoiding __getattribute__.
