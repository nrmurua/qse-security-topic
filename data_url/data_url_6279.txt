The primary driver behind the decision to implement QCircuit was originally to take advantage of NVIDIA's cuTensorNet, when building for CUDA instead of OpenCL. The general idea was that a QCircuit would be wrapped in a QExperiment (not yet implemented) with a forward declaration of the desired outputs from running the QCircuit, like a sparse set of probability amplitude expectation values. QInterface is written so as to be "ready-for-whatever-is-next, just-in-time": it simulates full state under "strong simulation condition" and loses no information in the immediate application of gates and measurements to the simulator. With the hypothetical QExperiment wrapper for QCircuit, we would have a interface that can safely wrap tensor network contractions for a specific, limited sampling of information out of the final circuit state. Then, so long as a user defines a QExperiment, it would be possible to "transparently" switch over to tensor network simulation as appropriate without worrying about the information lost in specific contraction orders of gate tensors and how it restricts user choices for applying QInterface.
Though QExperiment does not yet exist, it will be necessary to convert any QCircuit instance into an input for cuTensorNet. The point of this issue is to implement a method in QCircuit (perhaps QCircuit::ConvertToTensorNetwork(), or similarly named) to convert its bespoke quantum gate representation to the inputs for cuTensorNet. (To consider the issue complete, it is not necessary that tensor networks are "transparently" integrated with CUDA-based Qrack builds, but rather only that QCircuit have a working ConvertToTensorNetwork() method that produces a well-formed and equivalent input for cuTensorNet.)
For now, CircuitToEinsum provides this for PyQrack. (See https://github.com/vm6502q/pyqrack-jupyter/blob/main/Qrack_and_cuQuantum.ipynb for an example.) For the moment, unless a compelling case of practical advantage with cuTensorNet can be demonstrated, (which hasn't happened yet,) we do not seek to implement this at C/C++ level, for now.
