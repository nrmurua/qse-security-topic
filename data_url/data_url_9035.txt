Hello, I've been trying to use the glue code provided in the getting started tutorial to turn a noisy measurement circuit that I've built with Stim into a matching decoder in PyMatching. Unfortunately, I am making extensive use of the ELSE_CORRELATED_ERROR instruction in my circuit model, and when I use the glue code I get an error explaining that analyze_errors mode does not currently support the ELSE_CORRELATED_ERROR instruction when it's trying to convert my circuit into a detector error model.
I see that you are aware of this, as it is mentioned in the Stim Command Line Reference doc. That said, I think this is the only place in the documentation where this issue with ELSE_CORRELATED_ERROR is mentioned, and I think it would be very helpful to beginners if this lack of support was mentioned in the Gate Reference doc section that describes ELSE_CORRELATED_ERROR. I read the gate reference doc before coding up my circuit, but not the Command Line Reference doc.
I'm also wondering if there are any near term plans to implement support for ELSE_CORRELATED_ERROR in this setting? I read in another issue below that PAULI_CHANNEL_2 is currently 10x slower than DEPOLARIZE2. Is the reason for this performance difference the same reason why it might not currently be feasible to efficiently process correlated Pauli channels on larger numbers of qubits?
Thanks, I've really been enjoying working with Stim so far!
I read in another issue below that PAULI_CHANNEL_2 is currently 10x slower than DEPOLARIZE2. Is the reason for this performance difference the same reason why it might not currently be feasible to efficiently process correlated Pauli channels on larger numbers of qubits?
No, it's because it's performed by decomposing it into 15 individual errors. By contrast, DEPOLARIZE2 is sampled as one error that then uniformly samples 15 possible symptoms, which ends up being something like 5-10x more efficient when sampling IIRC.
In the context of error analysis, DEPOLARIZE2 and PAULI_CHANNEL_2 actually have pretty similar performance, because all 15 cases within DEPOLARIZE2 have to be handled separately. The low-then-uniform optimization doesn't apply to looking up xoring error sensitivities.
I'm also wondering if there are any near term plans to implement support for ELSE_CORRELATED_ERROR in this setting?
The reason ELSE_CORRELATED_ERROR isn't supported is because it is the only instruction that couples multiple instructions into one. Interpreting the probability it lists requires knowing the correlated errors that came beforehand. For example, the meaning an ELSE_CORRELATED_ERROR in a loop can be different in every single iteration if no CORRELATED_ERROR appears in the loop.
If I add support for it, it will specifically only work in the case where every ELSE_CORRELATED_ERROR is immediately preceded by ELSE_CORRELATED_ERROR or CORRELATED_ERROR. Also, it will require specifying approximate_disjoint_errors=True since it will just be approximating the ELSE_CORRELATED_ERROR into a CORRELATED_ERROR. This is because, by design, every error in a detector error model must be independent of all the others (though individual errors can contain arbitrary many terms) (for example this means it is literally impossible to explain a DEPOLARIZE1(0.99) error to a detector error model without approximating it, though DEPOLARIZE1(0.75) and below are possible). The alternative was just too hard to consume on the decoder side.
Thanks, Craig. That makes sense. Although, I'm not sure that I understand your comment re: DEPOLARIZE1(0.99) vs. DEPOLARIZE1(0.75), which means that I probably don't understand the details of detector error models well enough to correctly troubleshoot some other issues that I'm encountering. May I ask: why would the noise strength of a single qubit depolarizing channel affect how well a detector error model can deal with it?
Ah, I believe this is the answer: https://algassert.com/post/2001
Re-opening since I do think basic support for [ELSE_]CORRELATED_ERROR blocks makes sense as a feature.
