If I define a 1-level annihilation operator with qutip.destroy(1), and then I try to take a power to any integer, qutip throws an exception. I think this is because scalars are recognized as bras, and bras are not operators.
I've also found another edge case where 0.0 * qutip.num(0) gives an OverflowError.
In fact, any scalar multiplying qutip.num(0) gives the same error
Both issues fixed in dev.major.  The the former, dev.major is much more rigorous about defining the output types of Qobj created from various functions, so qutip.destroy(1) has type oper and so on.  The latter is fixed by the new data-layer types not accepting shapes with zeros in them.
Fixing just the cases defined here isn't too hard, but fixing it uniformly across QuTiP for all possible ways of creating 1x1 or 0x0 operators is rather more involved.  Since the work is already done on dev.major, and it'd be quite a lot of effort for some very minor edge cases, we're unlikely to backport this to 4.x.  I'll close this for now.
