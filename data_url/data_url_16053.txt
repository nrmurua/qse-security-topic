Suppose a ListOp that contains of 2 expected values (PauliSumOps with at least 2 Pauli terms) that are based on parametrized circuits with different parameter sets. Then, evaluating the ListOp is fine, but evaluating its gradient crashes since it first realizes that one element does not contain a certain parameter and replaces the partial derivative by 0.0 (float, not operator), which doesn't work in some of the following steps where the opflow assumes to get an operator and not a number (e.g. if it tries to reduce it or something like that).
The following code reproduces the problem:
The correct behavior would not replace the partial derivative (lets say d/dx <psi(y)|Hpsi(y)> by 0.0 (float) but e.g. by ~Zero @ One.
A possible workaround is to include the following lines into qiskit/optlfow/gradients/gradient.py (around line 170):
It's not 100% clear how to fix this. But, this problem is of immediate practical concern, so it needs to be addressed. The immediate problem is that an element of a  ListOp is initialized as floating point number, 0.0. But, much of opflow assumes that anything in a ListOp (and its subclasses) is an instance of OperatorBase and calls methods of OperatorBase. The mypy parameter annotation in ListOp.__init__ indicates that all elements are OperatorBase. But, this is not enforced or validated anywhere.
Some things we can consider to clean this up. All of these should be quick to implement once it is decided what to do.
Make subclasses of ListOp method reduce behave uniformly for empty lists. In particular, consider returning an OperatorBase equivalent to 0.0 rather than 0.0. Note that SummedOp([]), etc. doesn't have a clear meaning. Also the bevahior of eval is not consistent across subclasses and should be reconsidered; eval either returns 0 or throws an error. Also num_qubits needs to be made uniform.
Validate ListOp on construction. This also involves making a serious decision on what can be in the lists.
Somehow get rid of ~Zero @ One in the code.
We need to think about where allowing 0.0 or ZeroExpr in ListOp leads us. It needs to be exposed to users and then supported. Will users start to use it in expressions, and how?
