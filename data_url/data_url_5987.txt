Building of Aer from source according to https://qiskit.org/documentation/contributing_to_qiskit.html#install-install-from-source-label fails on Raspberry Pi 4 (armv7l).
Installation of Raspberry OS "Buster",
ends with the following error message (see full log attached)
See full log: Qiskit-Aer-log1.txt
"Successfully built qiskit-aer"  :-)
tbd
Thanks for reporting this @JanLahmann
Conan (the dependency manager) is trying to build OpenBlas and it is failing. It is probably something wrong with the CMake files in the OpenBlas version (0.3.7) for ARMV7. As you have already installed OpenBlas through apt as well, we can try linking to that version:
Thank you, that solves the issue.
Using that flag, compile of Aer now works on RPi 4 / ARM7.
I'm actually going to reopen this issue I'm not sure that the -D flag is a sufficient solution for this (although it might be a partial duplicate of #757 ). RPi users will have issues post release with conan because when they do pip install qiskit-aer it will build from sdist since there are no raspberry pi wheels available (see piwheels/packages#132 for more on that) and will fail trying to compile openblas. Then passing the -D flag in isn't really a solution because we basically have to document and try to inform users on RPi that they need to clone from source at the tag and run the setup.py command manually after installing openblas headers on their system. Having an env var as proposed in #822 will help because an informed user could set the env var when calling pip, but I'm worried not be sufficient because it still requires the user to know the internals of the build system, when most users going through pip aren't and just want the package installed. Building from sdist on pypi is more than a concern for rpi users too, it applies to anyone using aer outside of the platforms we publish precompiled binary wheels for (which is just x86_64 windows, linux, and mac).
The problem here is that we cannot support all platforms, this includes RPi which is not (and should not be) a priority at the moment (more on RPi support will come soon, stay tuned!)
People out of the supported platforms spectrum, will inevitably have to read the doc regarding building from source, and as far as we have everything documented, we should be good.
RPi builder community (which I've been a part of for a long time) is very aware of "piping" and playing with things to build stuff, so I'm sure setting a few environment variables should be no challenge for them.
Another bigger problem is the fact that pip is not very friendly for non-python code projects -- every simple C++ project out there will have building flags of any flavor at some point, and not allowing to pass these flags to the underlying build system is IMHO a tremendous flaw. Unfortunately there's not much we can do here other than push pip project to implement some mechanism, in the meantime I'm ok with documenting the use of env variables (we can track this in #757)
@mtreinish do you have any other option in mind?
It's not a question of platform support, nothing in aer itself doesn't support arm, the problem is with how we've built the build system. This is honestly a more general problem, and it's the same concern with conan that I had in other issues like #757, by assuming we always need to compile our dependencies it means that building/installing aer we're now responsible for also ensuring that out of the box a user's system needs to have all the prereqs and a compatible system for compiling all the dependencies, which is a much larger problem than just aer. For example, I'm unable to build aer from sdist on my laptop because openblas doesn't compile on newer intel mobile CPUS (I fixed this in OpenMathLib/OpenBLAS#2683 but its still not in a release, also we use 0.3.7 not the latest). Most other packages don't do this because it increases the complexity of responsibility, they just say please install X if a build dependency is missing. Pip works fine with non-python projects, there are a ton of compiled extensions shipped via pip/pypi, the problem here is that our build system isn't setup assuming people will be consuming things that way despite it being the primary mechanism that people install aer with.
What I think the solution here is we should make conan a fallback path for blas and other dependencies only if they can't be found on the system (maybe only blas it's the one that normally causes trouble) instead of assuming we always need to compile all our dependencies on every build. Also to provide better error message and documentation on the process via pip because right now when something fails it's hard for users to figure out why. (for example building from sdist on my laptop has 370 lines of error output and openblas isn't even mentioned in the last 60 lines of output.
I think the idea to use Conan was to have something that takes care of dependencies for us, so that we don't have to upload and distribute compiled libs (as muparserx for all archs, or op'nblas for win) or depend on them being on the system. For example for raspberry pi they have been able to solve the muparserx dependency for armv6 without issues.  It also gives us control over the version we want to use. For example in the case of nlohmann_json we cannot use modern versions because nvcc cannot compile it, although it is standard c++ 14 so it should. With conan we can be sure we are suing the right version (although a recipe for the specific version has to exist).
Sure, we can handle the dependecies in the classical way with apt, yum, brew, etc (at least in linux and macos) but you link to the version available, which may vary simply across linux flavors.  You point out that we are not linking to the last OpenBlas version with conan, but linking to the distributed version may not be the latest one either.
Another issue that solves Conan is that of finding the libraries. The CMake mechanism for finding libraries works well when the library provides its own FindXXXX.cmake. That's not always the case and then we have to write the code for finding them, considering the different OS, archs, etc (for example we had to provide the TBB ones #598).
Of course, Conan is not a perfect tool and has its own problems, as we have seen, although I think it has a lot of potential. Openblas seems to be the more conflicting library (I haven't heard of problems with others). In my opinion the problems come from a mix of two issues. The first one is that OpenBlas is a somewhat complicated library to compile, with detection of CPU at compile time, etc. The second is that the existing recipe on Conan doesn't tackle well enough that complexity, probably because for a simple use it worked well. Currently I'm trying to improve the existing recipe but if it doesn't work we can think of other alternatives, like the env var approach, use the old approach, etc. Of course, if more problems arise with other libraries, we'll need to think of a solution. I have been thinking of a simple way to have both Conan and regular find_package at the same time, but I haven't found anything convincing that doesn't require maintaining two build systems, though maybe that's what we have to do at the end if things don't work as we want.
Pip for other projects works perfectly when you provide the wheels but if you don't, you can run into issues. Last week I was playing with passing options to pip through --install-option (there might be better options), and it automatically forces the wheel build of every Python dependency you have, and it fails for some of them.
Also, I would like to clarify some misconceptions I sometimes hear about how conan works. First, dependencies are only compiled when the required binary package is not available at conan center. Conan currently provides packages for common combinations of os, compiler and common options (you can check them here). Right now it is missing gcc-10 but they are on it (conan-io/conan-center-index#1587). Second, once you have built a dependency, you don't have to rebuild it each time you compile AER, except if there is a change in options, version, etc or if we want to always build it for some reason.
To clarify, I do not work for Conan ;), but I think it is a good option. It has been a big change and we may need some time to make it work as we want. If we see that it doesn't work as we expect or that there are important caveats we can think of alternatives. Right now, I think, as @atilag proposed in #757 and I implemented for OpenBlas #822 , we can use the workaround of the env vars if we have a few problematic libraries, or even leave them outside the conan circuit if that doesn't work at all.
@JanLahmann @mtreinish I'm gonna close this one as now we use the system OpenBlas library and everything seems to work on Raspberrys.
