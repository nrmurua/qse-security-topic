The Git workflow sets the rules for how to use Git when contributing to a project. You can see an explanation of the most common workflows here.
Up until now, we have been using a Feature Branch Workflow among the collaborators and the Forking Workflow for external contributions (although no one has used it yet). In both cases, the approach is to always create a branch for each new feature, which is then merged into master. Short of committing directly to master, I would say this is probably the workflow with the lowest barrier of entry that keeps things organised. However, it started showing its limitation once we started release the software.
The problem
The case that triggered this reflexion is that of SequenceBuilder, which is a decent improvement that would be ready for merging with master, but not yet for release. If we were to merge it with master and then a bug would show up in the latest release, we would either have to release the fix in a patch with the SequenceBuilder half-done or delay the release of the fix until SequenceBuilder was fully done. Either case is suboptimal, in my opinion.
Gitflow
A workflow that would solve this problem is the Git Flow. This is a more complex workflow, which I'll try to summarise:
To me, this seems to be exactly what we're looking for. Without knowing about it, I started a similar workflow where a branch for the next version (currently, this is v0.2)  would be created and would receive the new features while master would be reserved for bugfixes. This is equivalent to having a develop+release branch for each new minor release. After learning about Gitflow, it seems like a less messy solution that this one.
In my few hours knowing about Gitflow, I've already come across some critiques. Most seem to be related to the time it takes to prepare a new release being inadequate for continuous deployment, but that does not concern us. For us, the most relevant critique I've seen is about the complexity of Gitflow. I think this is fair, but for sporadic contributions I think it can be condensed into:
I don't know if this overly complicated or not. All other complexities having to do with preparing a release would only be asked from the maintainers, which doesn't sound like a big ask anymore.
@bejito @lhenriet @Louis-PaulHenry @sebgrijalva  I think we should discuss this in the next meeting, but it might require a bit of reading for the discussion to go smoothly. I'm also open to starting the discussion here.
It doesn't sound too complicated (I haven't yet read the Gitflow page, so maybe I'm underestimating something).
I agree that we need to structure the workflow, and your suggestion seems to do the trick
Great initiative @HGSilveri
I agree with your conclusions, that flow looks good. The only issue comes when having to merge hotfixes, because we will probably want to merge them in master and release/develop to enjoy the fix in the branches, and to make sure master doesn't drift from them (which would make later PRs more complicated). But hotfixes should be exceptions in the flow, they should not happen too often.
There is an additional case which is not treated here, but I think we can leave it for later: patching old version. Usually, we have to maintain old major version for some time to allow clients to migrate on the newer ones (the cost being to update the code to adapt to whatever breaking changes we introduce from one major to the other). IMO, we should leave this one for later.
I agree with your conclusions, that flow looks good. The only issue comes when having to merge hotfixes, because we will probably want to merge them in master and release/develop to enjoy the fix in the branches, and to make sure master doesn't drift from them (which would make later PRs more complicated). But hotfixes should be exceptions in the flow, they should not happen too often.
@bejito You mean you agree with the standard gitflow approach, right? With having a develop branch instead of a v*branch for the next release, that is.
I agree that hotfixes complicate things a bit, but I'm fine with that for now, as long as the occasional contributor doesn't have to deal with the complications directly (ie they PR to master, we take care of the rest.)
There is an additional case which is not treated here, but I think we can leave it for later: patching old version. Usually, we have to maintain old major version for some time to allow clients to migrate on the newer ones (the cost being to update the code to adapt to whatever breaking changes we introduce from one major to the other). IMO, we should leave this one for later.
Yes, I think we're far from having to deal with this, I agree with leaving it for later. However, it makes a point for not deleting the release branches after they're merged with master. I've seen in some repos that they keep all previous releases in branches called release\v..., I guess we should adopt the same practice?
I'm leaning toward develop because it wouldn't require the contributor to know what the current v* branch is when doing a PR with a new feature.
I'm already doing this, I agree that it substitutes keeping the releases stored in branches.
