Samplers use Pauli frames to efficiently handle noisy circuits behind the scenes, but hide this information in the Python API. It would be nice to explicitly show this information through a Pauli frame simulator for noisy circuits that;
[Have a mode that returns the] Pauli frame at the end of the circuit
This is an interesting idea. Reporting frame changes to measurement results is already a thing in the command line tool (passing the --frame0 flag in sampling mode skips computing the reference sample by just setting it to 0, meaning the frame changes are returned directly instead of being xored against a reference). Exposing that functionality to python as well makes sense.
I'm hesitant to return the entire frame at the end of the circuit (IXYZ for each qubit). My reasoning is that this features puts the "simulation side" of a circuit into competition with the "sampling side". For example, to get maximum information when simulating you'd have to omit measurements at the end of the circuit (since measurements insert Z errors into the Pauli frame with 50% probability, totally randomizing that information) but to get maximum information when sampling you'd have to include measurements at the end of the circuit. I don't want to put Stim in a design space where methods generating stim circuits have an "if simulating produce this circuit otherwise produce that circuit" flag.
One way to avoid the conflict between simulation and the sampling would be to have a stim.FrameSimulator analogous to stim.TableauSimulator. Then the driving code could ask for the Pauli frame whenever it wanted. That's not currently on the TODO list but maybe it makes sense as an eventual thing.
[Have a mode that] Tells you which measurements [...] may be flipped. [...] detectors are restricted to deterministic outcomes in the noiseless circuit
You can bypass the deterministic limitation by passing allow_gauge_detectors=True as an argument to the detector_error_model method. If you accompanied every measurement result in the circuit with its own personal Detector annotation, and passed that argument, you would get an output equivalent to what you're asking for.
That being said, the performance of the error analysis step and the usefulness of the output will both be significantly worse than in the case of proper locally-sensitive detectors. For example, in the surface code, a bit flip on a data qubit as it is initialized will be interpreted as an error that flips every single Z stabilizer measurement involving that data qubit until the end of time. In a thousand round circuit, It will look like an error with thousands of symptoms. Working with such large errors will slow down the analysis and make the output cumbersome to work with. Also it will prevent loop folding of repeat blocks from succeeding, which is another large slowdown to the analysis.
Given that there is a workaround to achieve this functionality, and given that I expect the output to be poor quality and the performance to be terrible without architectural changes to the error analysis, I currently don't intend to add "compute a measurement error model" functionality as a directly supported feature of stim.
If you think this feature is compelling, I recommend implementing the "gauge detector for each measrement" workaround I mentioned. Make it available to others (e.g. as a pip package or just as code on github), and if lots of people like it then I'm open to merging it into stim itself.
To summarize:
Coming back to this issue, in case anyone is wondering how characterize errors in a circuit on arbitrary input as a list of correlated Pauli noise and probabilities. One can invoke a stabilizer version of the Choi–Jamiołkowski isomorphism to extract Pauli frames for arbitrary circuits with STIM. The following script is a short example:
