A single QPager "global qubit" is basically the same thing as a QBinaryDecisionTree "node," if the "global qubit" additionally has a normalized pair of scale factors for its two branches. By giving the QPager global qubits an explicit class identity, with two scale factors apiece whose norms sum to 1, some amazing opportunities emerge. These kinds of global qubits will keep pointers to their pages, and the pointers can be manipulated directly, like replacing 2 entire pages with 2 pointer references to the same page, when the two are identical. To work this way, we keep the pages internally normalized, to total norm of 1 apiece, which might simplify the QPager implementation overall.
When we "shuffle" pages for inter-page operations, I can write an OpenCL kernel that does the shuffle and two scale factor applications in the same traversal, I think, so there's not a major performance penalty, there. This is also stepping-stone work toward generalized binary decision trees, which I will ultimately use as a layer over QStabilizerHybrid.
QBinaryDecisionTree hasn't seen much use in itself, yet, but it does the work of QPager global qubits better than what we already use. I'm excited by the prospect!
First, to do this, NormalizeState() in QInterface should accept an additional phase argument, to apply to the normalization constant:
I considered combining the normalization constant with the phase argument at first, but the two really are logically separate. Leaving a default argument for nrm will lead to its automatic calculation, while this is still entirely independent of phaseArg, which can be applied as the complex angle at the same time. Leaving them separate also prevents confusion as to whether phaseArg should be transformed from its input form the same way as the nrm argument, which results in the application of ONE_R1 / std::sqrt(nrm) as the actual directly multiplicative constant, before we multiply it by std::polar(ONE_R1, phaseArg).
We have an implementation that works in a satisfactory way for many applications, at this point. In my (currently local copy, hacked-up for the specific case) unit tests, a QEngine based "attachment" under QBdt passes our entire suite for QInterface methods with the specific exception of arithmetic logic unit methods, (QAlu,) "parity" methods, (QParity), and Schmidt decomposition methods, which is expected and acceptable. Even QStabilizer passes the same tests, except for test_sqrtxconjt at low enough "magic qubit" couunt, which might be a "dumb mistake," or it might be a singular point for QStabilizer under the Attach() API.
However, following through with quantum binary decision trees method, the QBDT node PushStateVector() implementation cut in 9816335 seemed obviously necessary at that point in development, and I'm not still not convinced that it isn't. The reason this was cut was that we don't push to the tree depth where the heterogeneous attached PushStateVector() implementation is invoked, but maybe we must. I am investigating, this weekend.
Running test_mirror_quantum_volume again with a universal simulator attachment, there's definitely still (or newly) a bug here in about this region of the code. It might be as simple as appropriately reinstating the code from the commit linked above, and finding a workaround for stabilizer that avoids certain QInterface method usage.
This works, but it's slow in practicality. However, the issue has been addressed, so we can close the ticket.
