I am trying to run VQE for LiH molecule. My current setup is:
I experienced segmentation fault running the 12 qubits configuration (full space of spin orbitals).
It seems like the reason of the segmentation fault is insufficient RAM. The output when running the script with /usr/bin/time -v:
Run the gist to reproduce the error. It is based on the example of Qiskit VQE.
The computation finishes successfully, without an extensive memory consumption.
When I run the 6 or 8 qubits configuration, maximum memory usage is 220 and 460 Mb, respectively. For 10 qubits, the computation finishes as expected, but memory usage increases to 4.6 Gb.
I ran the 10 qubits computation in debugger and found out that a spike in memory consumption happens inside the COBYLA optimizer C code. It happens in a pretty strange way. When the execution enters optimization, memory usage rapidly increases to 4.6 Gb, stays at this level for a short time, and then drops to about 200-400 Mb. For the rest of optimization it does not exceed 400 Mb.
As far as I understand COBYLA algorithm, before the actual iterative process, it evaluates the objective function at N+1 points (N is the number of parameters, 24 for the 10 qubits UCCSD circuit). The memory spike might correspond to the 25 evaluations of the objective function. If it is the underlying reason, can it be avoided (probably at a cost of a slowdown) to significantly reduce the memory consumption?
Additionally, I tried to set COBYLA max iterations to 1 and the spike in memory still occurred. It suggests that indeed something happens during the optimizer initialization.
You can find the code to run the 10 qubits configuration in gist.
Hi, in investigating, so far we have tried with COBYLA and SLSQP and get the same failure, also we tried using Aer statevector instead of BasicAer but have the same failure. Now we tried this using 0.6 version of Aqua, in which VQE uses operators that are now legacy in 0.7. In 0.6 Aqua it worked fine. It also works fine in 0.7 if you use Aer qasm_simulator, which by default uses a snapshot instruction in Aer that makes the outcome behave like the statevector. This mode avoids conversion to matrix format of the operator, which is done for evaluation under the statevector simulator, and where we are are beginning to suspect the issue lies in the new operator flow logic that was introduced in 0.7 which is now doing this conversion.
@woodsp-ibm thank you for the answer! I checked qasm_simulator and it really worked fine.
It appears that the list of paulis (631 of them) is being converted into a list of matrices each having size 4006x4096 (2^12 as there are 12 qubits) of complex128 type. This is 256MB per matrix and consumes a lot of memory. The opflow was done on the basis of lazy evaluation but is leading to excessive memory in this common use case. We will have to look at how things can be improved in this regard.
