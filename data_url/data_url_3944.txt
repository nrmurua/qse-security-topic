Output files "_scheduled.qasm" are generated by quantum_program::schedule() which may differ from the actual scheduler used by the backend. As such, the file may not actually reflect the scheduling of the backend: e.g. for the CC-light, the backend takes resource constraints into account, but "_scheduled.qasm" doesn't.
I think this is confusing and put the offending code between #if OPT_WRITE_SCHED_QASM in PR #221, but disabling the code breaks the test suit.
Indeed. its not potentially, its actually generated by two different schedulers. one with and one without resource constraints, as you mentioned it. _scheduled.qasm is without resource constraints and is cqasm v1.0 code which is meant for qx simulation. cc-light qisa has different syntax and scheduler also takes resource constraints into account.
the thing is, for quite some time I assumed that the scheduled qasm reflected the scheduling as done for the cc-light, and could be used to verify the scheduling. Only after going through the source I happened to find out that my assumption was a mistake. When asked, Adriaan seems to have had the same assumption.
For one thing, I think that it would be good to have an easy way (other than going through the qisa) to verify the scheduling.
On the other hand I would say that if the use case for scheduled qasm is qx, it would be better to make a separate qx backend that generates this file.
@wvlothuizen FYI there is a separate backend for QX.
Regarding the generated outputs, when compiling for cc-light, the following files are generated:
The aProgram_scheduled.qasm cannot express cc-light code because there are various cc-light target specific instructions which are not part of cqasm and hence cannot be used to verify cc-light code on qx.
Apart from the above documentation of the generated output, do you suggest any other change based on this issue?
My preference would be for 2) to use the same scheduler as the backend, or remove 2) altogether since it does not have real meaning.
I really think it is very worthwhile to be able to verify the scheduling in an easy way: in PR #221 I extended the CC backend with output in VCD format, which can be viewed by many viewers, e.g. GTKWave.
I'd like to separate the OpenQL distribution and what is in the develop and master branches from what is in a private one for private development and private testing; of course, when suitably tested, the latter is made available generally in develop but then should also be generally applicable.
The compiler frontend just generates what it does now (1 and 2) and that seems to be used by the QX backend. So I propose not to change that.
In the CC backend you are free to generate whatever you like: I expect that its compile method calls the RC scheduler and after that writes a qasm file; the name of that qasm file is defined by the CC backend writer; if you like to give a new name to it, it is fine, in my opinion.
For example, in the CC-Light backend that I am using, the compile method calls several passes: decomposition, clifford-optimization, mapping, and then RC-scheduling proper; after having created bundles, it does qisa generation containing mask generation, etc. And, in between several of those, I generate output files to know what is going on. And all those output files are probably not of interest to you. Indeed, when merging this into develop, I will omit the generation of all those files.
@wvlothuizen can this VCD support not added at a higher-level of abstraction so that other backbends can also benefit without replicating the work?
addressed in #237.
@imranashraf I fully agree that the VCD support would be better located in a generic location outside of a specific backend. A few factors make that difficult at this stage however:
