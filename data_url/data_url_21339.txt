We will want to interact with datasets (beyond Subscribe-based plotting) in GUI applets -- for example, setting and changing image ROIs, fussing with fits, etc. From what I gather, the Publisher/Subscriber pattern is meant as a one-way sync of some data structure from (eg) the master to other objects, but not the reverse. If a "subscriber" wants to mutate that dataset, they must interact with it through the set-dataset rpc.
There may be a more elegant way to do this, but I'd like to propose adding an update_dataset method to the SimpleApplet class, modeled off of the similar function in the artiq_browser. For example:
Then in the SimpleApplet.__init__ method, we could add something like:
This would make it easy from derived applets to mutate datasets as needed.
Thoughts/suggestions?
The use case is definitely valid. But the implementation is way too narrow.
It's really not much code. I'd consider doing what you want to do explicitly in your applet.
In addition to what Robert said: the applet doesn't know the master address when embedded, all the data goes through the dashboard using the IPC pipe. And when the applet is used in the browser, there is no master.
A good approach would be to proxy the RPC through the IPC pipe, or just send the applet the master connection information through it. Unlike the case of dataset subscriptions, having each applet connect to the master would not waste much network and processing resources. The standalone (not embedded) applet mode should still be supported, and there should be a well-defined standard about what to do when the master is not available (browser usage).
@sbourdeauducq @jordens have your design ideas from above evolved in the past 2 years?  Seems like a relatively low-complexity item, is this accurate?
Still the same. Yes, it's not very complex, but what to do when the applet is run standalone or in the browser? Should those calls be allowed to fail in regular situations and should the user code be expected to deal with the failures?
I think we just need to agree on some graceful method for the applet to handle the the lack of a master.  Personally I am content to have user code be in charge of dealing with this failure in the appropriate manner, because I think the desired behavior will probably be quite different depending on the situation.  What would be nice would be to have something in ARTIQ that cleanly connects an applets to the master, and raises a reasonable exception when this fails, which the user can catch in the manner they desire.  For us, we would probably just have a try/except block for connecting to the master in the __init__() method, and we'd catch an exception by setting a boolean that is then checked by any "interactive" features of the applet before they are available.  Something super dumb like that.
I think doing this at a higher abstraction level, and perhaps providing an example applet or two (one for interactive plots, one with control buttons like "pause" as @npisenti mentioned, for example), would be nice.  This could be hacked together by people currently, but having it done properly, document, and put in tree seems to me to have real advantages.
