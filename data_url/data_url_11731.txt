When running a VQE job, users will sometimes receive the following error:
qiskit.aqua.aqua_error.AquaError: "FAILURE: job id:<job_id>, status: 'FAIL_TO_GET_STATUS' Unknown error: (Expecting value: line 1 column 1 (char 0))"
and will have their job stop running.
Run a VQE job and wait until error appears.
The iteration of the job always completes successfully, so it is not related to the job failing. It looks like the error is being thrown from https://github.com/Qiskit/qiskit-aqua/blob/master/qiskit/aqua/utils/run_circuits.py#L155. This while true: loop queries the API multiple times for the job.status(). The amount of queries is possibly too high and is causing the connection to be rejected by IBM Cloud.
What is meant by "iteration of the job always completes successfully"? Is the job shown to be complete in IQX?
Yeah, the specific job_id that shows up when the error is experienced is shown as completing on IQX. It is just that this error is returned to the user and stops the rest of the job from continuing, so the next iteration of the VQE job never starts to run
Why does the job.status not report something to that effect ie connection refused as a JobError in some way? Instead we get an exception which Aqua reports, in this case Unknown error: along with some parsing statement about expected values that causes status to throw an exception.
If we got back a JobError of some sort, rather than status throwing an exception, it would have kept going since it would have believed everything was ok, but an Exception being thrown it believes bad things have happened. Not sure whether connection refused should be considered bad if its recoverable.
It sleeps in that loop for 5s meaning it should not make any requests faster than that.
The job.status() implementation should be use it only to recovery the status of a job, once time, not to  query (each X seconds) and wait until the status changes to notify if the job ends. For that you need to use the websocket implementation (https://github.com/Qiskit/qiskit-ibmq-provider/blob/46f5d99b04aafc7dc40b8edc931537c1a0c5c27c/qiskit/providers/ibmq/api/clients/websocket.py#L173), if not you are using a REST API endpoint to check if the status changed. So, if you call the same endpoint (with the same parameters) during a period of time (until job ends), the cloud provider can reject you the request (to avoid DDoS attack), or you can find another network problem.
So, you should use the websocket implementation for that, and avoid thousands of calls if the jobs takes hours to run :)
In this particular case, the exception raised is actually a JSONDecodeError, not a networking error and therefore not caught by qiskit-ibmq-provider and not converted to a JobError. The provider can certainly catch that exception, but as Paco mentioned, it's probably better to not call job.status() in such a tight loop. If the goal is simply to wait for the job to finish and get its result, then calling job.result() would accomplish that. If you want to report the status/queue position along the way, then the provider will need to support some kind of callback in its websocket implementation.
Closing as several improvements have been added to Terra and IBM Q Provider to address issues like this.
