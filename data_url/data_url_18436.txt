This meta-issue contains a roadmap for implementing various features in the compiler related to HARDWARE-OBJECTs of order ≥ 2, which includes such existing GH Issues as #23 and #118.  This list might update and change (1) as we implement some of these features and (2) as discussion proceeds in this thread.
These threads can be completed separately / in tandem.  To ease testing, it would be helpful for the ADDRESSER work to precede the COMPRESSOR work, but this isn't necessary.
Background reading: https://www.youtube.com/watch?v=H4v7wddN-Wg
I wanted to add a few distinct facets and considerations to this problem of implementing higher order hardware objects (HOHOs) that motivate separate lines of work/goals.
Sometimes a HOHO is really just a way to manually optimize. Probably no architecture is going to expose CCNOT without exposing a high-quality universal(-contributing) 2Q gate like CNOT. Similar to a native SWAP, CCNOT is just coming along for the ride, and gives the user more options for writing efficient programs. But the compiler doesn't actually need to do anything with them, except schedule them in the output of the program.
Some quantum computing architectures, like neutral atoms or ions, use and require parametric HOHO operations natively. A parametric Molmer-Sorensen is an example. Typically these architectures have patterns like:
where P, Q, R are products of 1q interactions and MS are parametric Molmer-Sorensens.
One of the ways to "get around this" without implementing N-Q gates in QUILC is to just implement a universal 2Q gate set that expands into fixed templates of MS gates. But this possibly loses potential for optimization along various axes. (This is the same issue as building a compiler that only knows CNOT, and then after expanding CNOT into native instructions blindly via a library of templates.)
In the last example, HOHOs of dimension 2^n aren't all that useful for implementing 2^n-dimensional unitaries directly, except for perhaps a specific set of state preparations. Instead, they're useful as a generic way to achieve 2 or 3Q operations using a relatively flexible template that uses more qubits.
In essence, this process is truly more about making use of ancilla qubits: qubits that participate in the computation but whose state doesn't change by the end (in the case of Molmer-Sorensen echoing) or is disentangled & thrown out altogether.
The challenge in implementing HOHOs thus "reduces" to a challenge of supporting ancilla qubits in QUILC, which mostly turns into an addressing and fidelity calculation challenge.
Another facet to the problem of HOHOs is building knowledge that allows QUILC to optimize HOHO operations, nativize smaller arity operations into HOHO operations (if fidelity calls for it), etc. I call this out separately because I think there's different heavy lifting to do with the "addressing" side (getting operations placed, even when they're native), and with "synthesis/optimization side" (profitably using HOHOs for operations that aren't expressed in terms of them).
