As a result of the work #346 we surfaced the pre-existing ambiguity about the type for the parameters to gate declarations. The  purpose of gate is to define mathematical equivalences between gates. Having imprecise types (floating/fixed point) interferes with this. If the parameters have some new "symbolic" type there's a question of what set of operations we should support on symbolic objects, and some thought that maybe linear combinations with rational coefficients may be sufficient to capture the relevant use cases (and allow us to stop short of requiring a full Computer Algebra system within openqasm).
The purpose of this issue is to pull out this parameter discussion from #346 and allow #346 to focus on the gate extension question.
After much discussion in the T&C WG I'd like to put forward the following proposal. It ended up as a long essay so here's the outline.
gate does 2 things: 1) associate a unique unitary with every call to the defined gate; 2) describe one concrete implementation of that gate in terms of other gates (after repeated unwrapping eventually in terms of fundamental gates).
Compilers at minimum MUST be able to unroll recursively until reaching a set of gates for which defcals are available, and MAY throw an error if any gates unroll all the way to the built-in U basis without hitting available defcals. (We expect that the profiles WG will define an "executable QASM" profile where erroring is appropriate, and
If a vendor provides a standard gate library include file (eg stgates.inc) for a given execution environment, and user code builds only on gates from that library, then the user code should be able to execute (modulo other vendor constraints such as a maximum circuit depth limit etc). A simple minimal implementation (may not be very efficient) would therefore be to simply provide defcal for U and CX and standard libraries that build only on those (ie without further use of ctrl modifiers and such). (We should consider distributing such a stdgates.inc implementation along with the reference implemention - the example on github is not of this form). More efficient implementations of the standard libraries might unroll directly to other native gates.
If a compiler supports basis-changing the compiler MAY recognize some subset of gate definitions and have functionality to eg rewrite from an crz(x) basis to an partialswap(x) basis. This might require the gate partialswap(x) definition to be provided in a particular form because although the mapping is unique in the sense partialswap(x) describes a unique unitary, there may be multiple implementations of the body of partialswap and the compiler might only recognize some of them. When searching for known basis gates, the compiler must ignore the name of the gate and parameters (ie, gate partialswap(x) and gate fractional_swap(theta) should both be recognized if the body of the gate is identical after parameter renaming).
In this case that a compiler supports basis-changing, it MAY recognize as equivalent gates with syntactically-different but mathematically-equivalent definitions. For non-parameterized gates its probably practical to recognize all definitions of the same unitary (and there are examples of this in eg qiskit-terra), for parameterized gates it likely isn't practical to recognize all formulations but maybe simple transformations can be spotted.
I think of this model by analogy to eg vector acceleration instructions for classical CPUs. By providing a defcal for an instruction, it becomes available for direct use by the programmer, analogous to inline assembly to use a vector instruction. Additionally, some compilers may optionally, provide auto-vectorization functionality even when they do its expected that a compiler will require specific support for each such instruction set (eg just because SSE is supported doesnt mean SSE2 will be without additional compiler development) and its not expected that a classical compiler recognizes all vectorizable code, but rather the input should stick to certain idioms (eg side-effect-free loops over memory-aligned arrays).
There was a lot of discussion in the WG around how exactly the wrapping behavior of an angle type in a gate parameter should be implemented. This comes from the fact that eg 3x/2 when x is an angle can have very different result if its interpreted as (3*x)/2 or 3*(x/2). Even though the spec takes pains to carefully describe the behaviour of such explicit expressions, the concern was that hiding some of this in gate definitions might make it implicit and mysterious.  I think with the above expectations on gate definitions this is no longer a problem and we can make a simple rule:
The overflow behaviour of recursively unrolling gates should be as-if the expression were evaluated by assigning to an angle type at each call.
Ie, with the definitions
then g1(5*(pi/3)) evaluates as
ie g3(pi/3).
There are 2 built-in parameterized gates, U(θ, ϕ, λ) and gphase(γ). The definitions of these gates are explicitly 2π periodic in all the parameters except for θ, for which U is instead 4π periodic. The spec implies that U() is defined for
θ in the interval [0,2π), but also says that the inv modifier can operate by replacing inv @ U(θ, ϕ, λ) by U(-θ, -λ, -ϕ). Unfortunately this is not correct when considering global phase: ctrl @ inv @ U(θ, 0, 0) c, t; is not the same as ctrl @ U(2pi-θ, 0, 0) c, t; but rather needs an additional p(pi) c; to correct.
I can see a few options to resolve this:
I think any of the options 2-4 could be acceptable but I lean towards option 4 even though its a bit embarrassing to have to revisit this and obsolete the paper.
Also, all options 2-4 only differ in the presence of ctrl modifier, and all can be inter-converted by judicious use of gphase instructions
There's a need to choose a number of digits for the calculations. The concrete parameter of a gate call will have a specific precision, and the defcal will have specific precisions, but there is no precision specified for the intermediate steps. I propose to leave the details implementation-defined but with the intention that the general level of precision of these intermediate calculations should be sufficient to realize the defcal precision. One approach might be to do all intermediate calculation at some fixed machine word size (eg the size of int without size modifier) and round to the defcal precision just before passing control into the defcal.
Maybe there is some care needed with the precision so that the same rounding always occurs otherwise in the vicinity of the wraparound you could have some bad behaviour:
if the a is close to pi and the 2*a terms might wrap differently in at tag1 than at tag2 then could get an unwanted result.
I think now, the Types and Casting WG determined that the type of gate parameters are in principle angles, with a number of bits of precision which may depend on the implementer, and which have wrapping modulo 2π (corresponding in particular to option #3 above in what to do about U). Does this seem accurate?
I think now, the Types and Casting WG determined that the type of gate parameters are in principle angles, with a number of bits of precision which may depend on the implementer, and which have wrapping modulo 2π (corresponding in particular to option #3 above in what to do about U). Does this seem accurate?
Seems accurate to me.
Resolved by #393.
