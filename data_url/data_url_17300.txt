These two decompositions should be the same:

This is not a bug. Both decompositions are equivalent.
If you compile using optimization_level=3, both will become equivalent (each will use only 1 cnot).
It does make them the same. in gate count, not phase angle values, but the compiler with O3 actually makes the cz unrolling worse:

I would also say that this does not answer the question as to why the unroller does not do the same thing for the same gate in two different representations.
Ok I'll reopen the issue and change the title. This is easy to do, we basically have to simplify the U3 gates to U2 and U1 where possible. We have code for this, it's just not called.
The unrolling rules for CZ and CU1 are different. CU1 is a more general gate, so by default it is expanded differently than CZ. The unroller operates based on decomposition rules, any optimization is done in separate passes (as shown above).
Actually this is true in general.  For example the random ring circuit you gave me:

{'u2': 10, 'cx': 64, 'u3': 50, 'barrier': 1, 'measure': 10}

{'u2': 10, 'u3': 141, 'cx': 69, 'u1': 1, 'barrier': 1, 'measure': 10}

The above example makes me think it is not just a simple decomposition issue.
This example seems the "NoiseAdaptiveLayout" that runs for level 3 chose some qubits that cause lots of swap insertion. We really need to merge the DenseLayout and NoiseAdaptive layout to fix this.
If I force the "DenseLayout" instead (by passing backend_properties={}), then the depth is lower.
Ideally we would run both circuits to see if noise adaptivity of the layout is worth the extra swaps, but this circuit is too big. We should do that study though.
So the noise adaptive layout is used in level 2, but level 2 seems not to suffer from large U3 count.
I have some ideas about merging the two. Here it seems some optim pass that is in 3 but not 2 is causing issues.
The extra U3 gates are being generated by the ConsolidateBlocks() pass.
Title changed to reflect the problem.
Yeah these come from the KAK decomposition and I think an extra clean up step is required to simplify the U3s.
This was my guess, but I am surprised that kak would be triggered for something like the cntrl-z above. My guess would have been do a cleanup if more than three cnots in a block or something like that.
Ok, so this is because the block is added to the dag as a unitary gate, that automatically tries to do a kak on it since it is a two qubit unitary.
It is possible to check local eqivilents of unitaries, ie unitaries are related by single qubit gates only. One could check if a block is local to a one two or three cx unitary, and if that number of cx is in the original block do nothing, else reduce.
