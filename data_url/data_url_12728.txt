It would seem that one could implement this using https://docs.microsoft.com/en-us/qsharp/api/qsharp/microsoft.quantum.canon.applycontrolledonbitstring however the implementation is supplying a Bool string typed as an int string.
If you are here, see the following snippet:
I don't think Task 1.5 from DeutschJozsaAlgorithm kata can be solved using ControlledOnBitString. ControlledOnBitString allows to mark a single basis state that matches a specific pattern, and this task looks for all basis states that have the right parity of the selected bits.
For example, if we're looking at 3-qubit states and a pattern [1, 0, 0], ControlledOnBitString would mark one state, |100⟩, and this task asks for all states in which f(x) = xₒ = 1, that is, states |100⟩, |101⟩, |110⟩, and |111⟩. The oracle in the task represents a balanced function, and the function implemented by ControlledOnBitString would've been unbalanced, though nearly constant.
I don't think Task 1.5 from DeutschJozsaAlgorithm kata can be solved using ControlledOnBitString. ControlledOnBitString allows to mark a single basis state that matches a specific pattern, and this task looks for all basis states that have the right parity of the selected bits.
For example, if we're looking at 3-qubit states and a pattern [1, 0, 0], ControlledOnBitString would mark one state, |100⟩, and this task asks for all states in which f(x) = xₒ = 1, that is, states |100⟩, |101⟩, |110⟩, and |111⟩. The oracle in the task represents a balanced function, and the function implemented by ControlledOnBitString would've been unbalanced, though nearly constant.
I concur, I know a lot more now than I did when I typed this up. I'll close it.
