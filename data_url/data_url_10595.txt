I have the following coefficient matrix which I pass to DwaveSampler as QUBO:
This matrix is 64 by 64. The 64 variables can be tiled, counting index from 0 to 63, into a 8 by 8 decision matrix in row major order, and there are two constraints on this matrix:
I tried this matrix on both DwaveSampler and SimulatedAnnealingSampler. SimulatedAnnealingSampler returns an answer satisfying all constraints, but DwaveSampler does not. My code that engages DwaveSampler is as follows:
What is wrong here? I've also noticed that ScaleComposite matters here, because without it the answer is mostly 0, which is non-sensical.
Hello @willxujun, I believe that part of the problem might be that you're not using a chain strength parameter. In the sample_qubo statement, please add the parameter 'chain_strength=1500', and please re-run your problem.
Just to explain what I'm thinking, the EmbeddingComposite is doing an embedding for you, and as part of finding the embedding, it builds some "chains," in which qubits are constrained to have the same value, so that they behave like a single qubit. If the chain_strength is not enough, those chains will break, and the behavior isn't what we want.
Hello @willxujun, my initial work shows that the chain_strength helps, but doesn't yet lead to a "correct solution." Could you share the expected answer that you're seeking?
Sure. Here's what I got using the above matrix and SimulatedAnnealingSampler:
so each entry of this solution matrix is a variable with a corresponding index like that of a flattened 2D array in the original problem matrix. For example, entry [1][2], which is a 1, is variable index 10 = (1 x 8 + 2).
One more question for you, @willxujun. What energy are you expecting? Do you have a calculation of it? (The "permutation matrix" is good, and it matches what I'm getting. I'd like to know the energy number you expect.)
I don't have a specific target, but somewhere in the range of -7500 is fine (I'm quoting the result of SimulatedAnnealingSampler here). My answer doesn't seem to be correct even with chain_strength, i.e.
Is there something else I am missing?
@willxujun, I get -7480 now, with different solvers, so we are indeed in the same range.
No, you're not missing anything. This problem is a challenging one for the QPU. There is significant range between the large entries and the small entries (1036 vs. 3, etc.), and it looks like there are a large number of answers which do not have much to differentiate them. It looks like a Traveling Salesman problem (or Eight Queens, or something like it), and we do not get very good results initially with the QPU.
I will get back to you within a day or two with some things to suggest, for additional features to try, which may dramatically improve convergence to a much better solution. Thanks for your patience.
If it helps, the problem is a Quadratic Assignment problem. Thank you.
Hello @willxujun, I have not forgotten this. I will come up with a strategy for you. It is taking longer than I'd hoped, but I will get there. Thanks for the additional detail that it is quadratic assignment.
Hi, any updates on this? If the original matrix is too difficult, how about the following one? I actually have some code controlling the ratio between the entries, so hopefully the following is more gentle on the QPU.
I use "external penalty" to iteratively increase the coefficient between some pairs variables, which explains the larger entries. In theory the solution of QPU should converge to a "solution matrix" as the weights increase to some level (which means I have an iteratively changing problem matrix). With simulated annealing solver I am able to get this behaviour, and the matrix above is just a snapshot of a successful iteration.
@willxujun, I apologize again, for the long delay - thanks for writing. I'm working on this today. I confirm that your second matrix does a little better - although it does not get as close to the solution as SA does (as you noticed). I just need a little more time - thanks for your patience.
@willxujun, I started to research this today, and I am still looking for a set of steps for you to follow. One of our technical experts mentioned some techniques which I'm not familiar with, and another person mentioned reverse annealing. My goal is to send you some small snippets of Python code which you can run, to get better answers.
The main point is that your overall question - back to the beginning of this thread, 20 days ago - is that you're not doing anything wrong. The problem is a hard one for the D-Wave QPU. Two of the people I spoke to initially said they did not expect good performance by the QPU on this problem, as you noted. The goal is to come up with a recipe for improving the performance, and I will do that.
