A BasisTranslator does not translate a gate if its target includes the gate. Thus, the target_basis is essentially ignored, and the resulting circuit includes gates that are outside of the supplied basis_gates.
Run this code:
Output: ('x', 1)
I expect it to output ('sx', 2) or something similar, as it does when I omit the target argument. I do not expect it to silently ignore the basis_gates argument.
Fix BasisTranslator.run, particularly line 157. If you intend to keep the current behavior, then you should warn users who provide both the target and basis_gates (or target_basis) that the presence of the former causes the transpiler to ignore the latter.
We can definitely improve the documentation and warning here, though the current output is as expected / designed.
In order to achieve what you want in the short term, you're likely going to want to create a custom Target based on the existing one, overriding the heterogeneous ISA with whatever other data you want.  I suspect (but am not sure) that what you intended to happen could be achieved with:
where hopefully I made clear several of the places where we'd have to make questionable assumptions when trying to override a Target with something like basis_gates, and places where you might want to tweak exactly what's created.
To explain a bit more:
Passing contradictory data to transpile like this is generally going to require us to ignore at least one of the two items.  Before target existed, we only had backend, which was at the time a BackendV1 instance, and most of the rest of the arguments to transpile are direct fields on BackendV1. This meant that there was an obvious meaning to supplying both a backend and the other options; you were overriding a single field of the backend.
With Target, the same logic is much trickier, because Target represents far more complex and heterogeneous data than the other individual arguments can.  Most of the compiler passes now draw all their data from Target, and only fall back to the other forms if no Target was given.  For example, a Target doesn't have a split coupling_map and basis_gates, it stores information on which gates are available on which qubit arguments along with the associated errors, which is more general.  In this sense, setting target=..., basis_gates=... in a call to transpile ends up with knock-on effects if we prioritise basis_gates; we now also do not know the effective coupling map, because that's not supplied.
As a concrete example, consider a Target that has:
Now suppose we're asked to transpile to this target, but overridden so that basis_gates=["rz", "sx", "cx"].  What should we assume that the "coupling" of the effective target is?  There's lots of potential choices here, and it's not at all clear what the meaning should be - we could:
and in most of those, we also have the question: for any implicit links, what should we assume about the available directionality?  Should ecr on (3, 4) imply that cx would be active in the (3, 4) direction, or maybe the (4, 3) direction is also valid?
The point I'm trying to make clear is that it's not really meaningful to override single BackendV1 fields on a Target because of the heterogenous ISA support (which current hardware vendors are starting to have more and more of); it has huge knock-on implications in general.  This is why we're suggesting creating your own Target in these situations.
Note that if the goal is to synthesize a quantum circuit with FakeCairoV2's coupling map and with custom basis gates, then (exactly as @jakelishman explained) one can simply write
Additionally, we have the method Target.from_configuration() that can build a Target object given coupling_map, basis_gates, etc..
