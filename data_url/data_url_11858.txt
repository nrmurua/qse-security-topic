In general, I'm struggling to understand the separation of params, and algo_input
I don't like that some algorithms don't have an algo_input. Why can't the params be part of the algorithm?
Hi @jaygambetta I believe I can explain some of this. The algo_input is usually inside the params as json and that was the previous behavior in all situations. However it was asked that I add the ability to also let the user pass an algo_input object. In this case the algo_input object will be used instead of any json input inside params. I believe @pistoia or @woodsp-ibm would be able to give you more details.
but why can't we combine this in one object
I don't like the word algorithm given the QuantumAlgorihm object. But this is like the aqua program to be run
OK @jaygambetta . Let me think about it a little and I will talk to @pistoia @chunfuchen and @woodsp-ibm  too.
no problem thanks for considering it.
The algo_input is the 'data' for the algorithm, where the params is the configuration dictionary declaratively selecting which algorithm and components along with their respective parameters. algo_input would often be computed such as an Operator instance or training/test/classlabels for AI. The config and data are passed in separately.
Now params, instead of being a Python diction, can be in json form. In json form the algo_input would have been serialized to json and stored in the same json file as a convenient standalone entity for say exchanging the experiment or saving it for some future runs. Currently this is run through the same method where params can be this standalone json form and internally then the algo_input is re-created from the serialized form in the json so that what gets passed to the algorithm is consistent.
That's fine but I think it is confusing when some algorithms can run with no algo_input. I think that an algo_input should be required and params be a configuration of the algorithm.
This is currently only the case with Grover. The data here, for the current and only Oracle we have, was simple enough that we ended up with it configured declaratively on the Oracle. An algo_input here for Grover could well depend on the specific search/Oracle and we just had the one example. Given that at the time we did it without an algo_input but expected that how we dealt with Grover would likely need to be revisited at some point.
exactly so we should ask what is algo_input and what is parameters and as a minimum, we should always require an algo_input and not params and params should be configurations. We currently have it the other way.
Params are the configuration parameters for the algorithm and its components, such as name which optimizer to use, and it step size, depth of var form etc. The algo_input is the problem data for the algorithm e.g the Hamiltonian (Operator) for VQE, classification data for the AI algo for training/prediction. The only place where this is not the case, as I explained, is Grover where, for the moment, it is passed directly to the Oracle within the params. This was possible as the data was limited to simple 3-SAT problems for the present, but as I explained, for what we have with Grover to be more consistent and solve other search problems that this would need to be revisited.
I think the confusing thing here is that both params and 'algo_inputare inputs torun_algorithm`.  I also do not understand why they cannot be combined into a single instance.  The partitioning of what goes in which dict is also not so clear.
However, looking through the tutorials, I am wondering about the use of run_algorithm itself.  It seems by a very non-pythonic, i.e. matlab like, way of doing things.  All the examples specify and algorithm, and then set the parameters for that algorithm.  So why are the algorithms themselves not classes that can be setup.  For example, something like:
run_algorithm has two parameters. One is a configuration dictionary for that algorithm of settings to select which algo to run, and control parameters to tune how the algorithm runs such as depth, which var form etc. The other the is data that the algorithm will act upon. The documentation in this regard might be improved to help but I do not see how combining them as two fields in a single instance will help if the meaning of what should go in those fields (ie what were the parameters to run_algorithm) is less than clear.
run_algorithm was designed to be run declaratively so it can be run from json, with schema validation enforced. This was a key requirement.  It allows an experiment to be saved as json (the inputs to run_algorithm) and re-run from that json in the future or exchanged with others to run. The method also supports passing the config part of that json as a Python dictionary and having the problem data supplied directly rather than it being serialized to the json. When you have programmatically created an Operator as input data for the algorithm it allows it to be used directly rather than being serialized to json and immediately thereafter in run algorithm deserialized back to an Operator for the algorithm to consume as they do not deal with json.
The python style you show is nore of less what run_algorithm uses internally. That level of API can be used and we have more advanced notebooks that show this. In general the expectation was that reqular users would use the run_algorithm. Developers adding to Aqua would be expected to know the internals more and may wish to use this when developing new algos or components.
Closing old discussion
