Construct a density matrix, via some array creation method (in this case numpy - haven't checked with others). Create a rho0 for mesolve to use with the flat array while explicitly specifying the matrix dimensions in the dims parameter. Upon passing the density matrix to mesolve a segmentation fault occurs. A simple proof of concept is included below. np.random.random was used to fill the matrix in this case, but the issue was encountered using valid density matricies, and the issue seems to be unrelated to whether the matrix is valid or not as a density matrix.
The code should exit without failure or throw a python error elaborating on the issue
I ran the code through gdb to somewhat narrow down the cause of the issue. It seems that dense2D_to_fastcsr_fmode causes the segmentation fault, but the parameters passed to it seem fine at first glance, since I expect ncols = 10000. While I don't know how useful it is I will put the top of the stack trace (after this the only the call to mesolve is relevant in the stack trace).
@Lala5th Thank you for reporting this.
It looks like the issue is just hat mesolve calculates the size variable incorrectly for a flat array and the following diff removes the segfault for me:
I agree that we should not segfault. Probably the minimal patch is to raise an exception if rho0.shape[0] != rho0.shape[1]. If you agree, I can open a small PR (or you can if you would like to).
@hodgestar I agree, that an exception would suffice, my issue was mainly that segfaults are hard to debug, especially if the offending code can be removed from where the crash occurs. If you don't mind opening the PR I then I think that would be the best since it is your fix.
I think the bug is bigger than that. Qobj never ensure that the shape and dims match but in many places, solver check only the dims and not the shape. Here rho is shaped as an operator-ket but with oper dims, so it slip through the dims check. I wouldn't be surprised that we can cause other segfault with Qobj where the shape and dims don't match.
It would be safer to add a check when entering cython code.
@Ericgig That is true. Possibly a check in Qobj constructor, would be the best to avoid mismatched Qobjs to be created in the first place. A rudimentary fix might be something like:
If you think this would be a good fix I can open a PR.
A check in Qobj would be great, but we have enr_... states and operator that have shape and dims not matching and are somewhat supported. This check would refuse those states. The best would be to improve dims to support these spaces, but it's only planned for v5.
If you can make a PR that do not break these enr_ functions, it would be appreciated.
I am unfamiliar with the enr_ functions, but I modified the check so that it does not have to be a perfect match. Now the requirement is that the shape of the underlying data has to be smaller (at each dimension) than the dimension it represents. I checked and enr_fock and enr_thermal_dm are not broken by this change, but I might be missing some other function that is broken by this change. I'll open a PR and attach it to this issue.
