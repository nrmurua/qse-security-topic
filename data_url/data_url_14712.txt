As highlighted here: Qiskit/qiskit-tutorials#1036 , (and found by @mtreinish) the copying of circuits
https://github.com/Qiskit/qiskit-terra/blob/dc3a2a667b8dc22512ca409ecae347d8dbdd944c/qiskit/circuit/quantumcircuit.py#L1900
is the primary bottleneck in algorithms that make repeated use of bind_parameters.  To overcome this, there needs to be a way to bind_parameters in-place.
One way to do this would be to have the parameters actually just be references to the appropriate node and parameter in the DAG representation of the circuit.  However, this would require always have the DAG representation handy; the QuantumCircuit should be a wrapper around a DAG.
My thinking on this was actually to defer the binding outside of the circuit. So instead of calling QuantumCircuit.bind_parameters() we have an argument for transpile() and/or Backend.run() (after #5086 merges) that takes in the parameter table.
For transpile we'd do what you were suggesting but directly in the dag after transpile runs circuit_to_dag(). It basically would make transpile a 1 to many circuit function when the parameter table is set (ie it would generate a list of output circuits for each parameter value).
For Backend.run we basically leave it up to the provider to efficiently take the parameterized circuit and the parameter table and pass that to the backend. This is basically what @hhorii did for UCCSD in aqua when aer is being run (qiskit-community/qiskit-aqua#1206 ) it manually constructs a parameterized qobj (which only aer supports) to send a single circuit with all the parameters and leaves it up to aer to handle each parameter value.
For the transpile part I do not see how one gets around transpiling multiple times if the parameters are not a priori given.  For the latter, I think I am usually given an array of values that correspond to parameters in a circuit object (or perhaps the QASM rep?) and I need to feed those in.  So at some point it needs to be in-place inserted into a circuit somewhere, or perhaps a lower level representation at some point.  If it is always going to be lower down in the stack (your Aer example) then one might be able to get away with a parameter table as a semi-separate thing
For adding a argument to transpile() it definitely would be transpiling the circuit multiple times, once per parameter value.  I don't think there is a way to avoid that. But, you could do the bind in place as a modification of the dag node after the parameterized circuit is initially converted to a dag basically as an outer loop (or over parallel_map) around the passmanager.  My thinking was basically if its in transpile() we could come up with a a way to handle this more efficiently than deepcopying a circuit object for each parameter value and then passing that copied circuit object to transpile(). I was thinking this is basically the same thing you mentioned in the original issue but instead of embedding the dag into the circuit object we just handle everything inside transpile. Assuming we had that in place it could become the default case if the backend object doesn't handle parameter binding for us. Basically something like:
But, this is still all just a rough idea, so I'm probably overlooking a lot of details.
For sake of completeness: The assign_parameters method allows in-place assignment: circuit.assign_parameters(param_dict, inplace=True).
But if this is about performance of binding different parameters many times, this is of course no alternative.
Looking at the reported ctimes, the performance issue from Qiskit/qiskit-tutorials#1036 looks to be more of an issue with the basis translator than with bind_parameters, probably here:
https://github.com/Qiskit/qiskit-terra/blob/cb81c02/qiskit/transpiler/passes/basis/basis_translator.py#L151
so maybe the issue is that DAGCircuit doesn't have a bind_parameters. I started a branch adding it (without a ParameterTable) but, on the cases I looked at, the performance was comparable since we need to copy the circuit here at least once either way. I'll try dusting off that branch and seeing if there are other approaches (maybe caching the bound_dag over bind values) to see if it resolves the issue.
@kdk did you get any further with this?
We added bound DAG caching in GH-6187 to address a different performance concern (around sympy) and subsequently removed it in GH-6457 (when the sympy issue was resolved separately with symengine). The removal was flagged as a regression in time_transpile_from_large_qasm ( https://qiskit.github.io/qiskit/#transpiler_benchmarks.TranspilerBenchSuite.time_compile_from_large_qasm?cpu=Intel(R)%20Xeon(R)%20CPU%20E3-1270%20v6%20%40%203.80GHz&machine=dedicated-benchmarking-softlayer-baremetal&os=Linux%204.15.0-46-generic&ram=16GB&python=3.6&num_cpu=%5Bnone%5D&commits=0ef110c5 ) which has a significant number of translation replacements to do, so there may be something to be gained by reinstating it.
I think this might be an issue of conflicting views on what we mean by "binding" the parameters.  In some contexts, by binding we mean replacing the ParameterExpression with a numeric value.  If this happens, there's no way to re-bind the parameters to new values, so it wouldn't be useful to be able to do this in place for algorithms, presumably.
On the other hand, if we have binding be something that just happens inside ParameterExpression, we end up with ParameterExpression needing to keep track of its entire history of binds in order to be able to revert at any point, and it becomes very tricky if we get a cycle.  As a simple example, consider binding a -> b -> a -> 2, then if someone tries to bind a again, do we rebind the first or the last?  In the simple example it's fine, but what if the general structure involves parameter cancellations and larger expressions - I'm fairly sure with cycles like this, we can get into situations where the choice matters for the value.  At any rate, keeping the entire history of the expression around is not going to be great for performance either.
