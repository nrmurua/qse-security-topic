Classical shadows is an efficient method for constructing an approximate classical description of a quantum state. There is a problem when trying to implement it on a real device, it requires the transpilation of two different layers, one that is the same for all the circuits, and one random with single-qubit operations. If I try to join the two layers and do the transpilation afterwards it takes too long. If I try to transpile the first and the second separately to reuse the first layer, I didn't find a way for my second layer to be aware of the first transpiled layer. This is a follow-up to our discussion @1ucian0.
The code below could help to understand what I found:
Been able to combine the two circuits while keeping the same logical qubits.
No response
What calls are you making that it seems like transpilation is taking a long time?  The first call to transpile with a new IBM Runtime backend may take a couple of seconds to initialise the backend fully, but after that, transpilation should be fast.  In your example, if I delay the transpilation until after the whole circuit is constructed, the transpilation takes 37ms on my machine.
You can set the initial virtual->physical mapping for subsequent transpilations by using the initial_layout argument to transpile.
What calls are you making that it seems like transpilation is taking a long time? The first call to transpile with a new IBM Runtime backend may take a couple of seconds to initialise the backend fully, but after that, transpilation should be fast. In your example, if I delay the transpilation until after the whole circuit is constructed, the transpilation takes 37ms on my machine.
You can set the initial virtual->physical mapping for subsequent transpilations by using the initial_layout argument to transpile.
Thank you for the quick reply, @jakelishman. For me this code is broken, isn't it for you?
When I said it takes too long is as if the whole transpilation is made after combining the two layers. Maybe it does not take too long for small circuits but the idea is to make it for 127 qubits with a  number of shadows around 10.000.
Sorry for the long delay between now and then.  The code block exactly as presented is broken, but I was talking about how long transpile took if you build the circuits completely and then transpile, so I used this tweaked code-block, with the only changes indicated:
At the end of this, calling
was timed at 36.8(6)ms on my machine, which doesn't seem excessive.  Are you working at scales where you absolutely must pre-transpile the initial setup of the circuit?
In principle, the way you would do the transpile(qc_shadow, ibm_brisbane) call using the final layout map of a pre-transpiled circuit is to find the positions that virtual qubits $0, \dots, n-1$ end up in, and set that as the initial_layout argument to the second transpile call.  That looks something like:
I should note that you should add the measurements to the second circuit before you transpile it, to ensure that the remappings and any subsequent inserted swaps are respected.
