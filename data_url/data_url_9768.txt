BQM.change_vartype and SampleSet.change_vartype either always copy or always act in place. It would be useful to be able to cast the BQM/SampleSet to an appropriate vartype, copying only in the case that they don't match. It would be similar behavior to
This could be accomplished with a new method
as inspired by ndarray.astype. But this is fairly redundant with the existing method and it might be confused with the existing as_vartype function.
An alternative would be adding a new keyword argument to .change_vartype, e.g.
though I think copy is a pretty confusing name.
Perhaps this will only confuse matters -- this is related to @hhtong's latest comment on dwavesystems/dwave-system#321 -- I've hacked up a view whose vartype can change without making copies
One feature of the above is that you can change the vartype inplace without making a copy, and then if you want to make a copy, you can simply call .copy().  I attempted to embue this with an as_vartype(self, inplace, copy) as you suggested, but found that inplace=True and copy=True is somewhat nonsensical.  It may be better to return an EitherView to support bqm.spin or bqm.binary, which supports changing vartype inplace, and then if the user wants a concrete copy, they can call .copy()
This implementation has some issues, specifically that set_quadratic etc do not respect the vartype of the BQM (edit: I see the ._bqm property now). The existing .SpinView and .BinaryView are already intended to cover the "no copy" case, i.e. just by doing bqm = bqm.binary if BINARY is the desired vartype. The problem @hhtong ran into in dwavesystems/dwave-system#321 (comment) came about because .change_vartype is not defined for the vartype views. Another way to address that issue would be to update .change_vartype to work in the inplace=False case.
We could combine the EitherView with the existing VartypeView and use that instead of the two subclasses, which would make change_vartype well defined with fewer overall layers of abstraction.
Ooh I quite like that
