We have a couple of F77 interfaces:
Some are somewhat documented (for src/f77_interface.F there is an example in tools/f77_interface for which one example is already broken), others are not (src/motion/gopt_f77_methods.F). Both of them are unfortunately not "leaf"-modules , but are used by other F2003+ code in CP2K. Furthermore they are not even F77 anymore since they contain for example OPTIONAL dummy argument descriptors (introduced in F90).
Simply moving them in a MODULE  in the case of src/motion/gopt_f77_methods.F does not work since it triggers a reverse-dependency loop in our build system, while the src/f77_interface.F is highly entangled with the CP2K startup code, the farming and other features.
As documented in #792 there is some need for a programmatic interface to CP2K, but also there the standard being used is F90.
@oschuett I know this post is rather old. But there is potentially a way out of this dependency issue: Fortran's submodules. Check Steve Lionel's post on this topic. There, he explicitly mentions that circular dependencies are possible: Module A can use module B, and a submodule of B can use module A! This doesn’t create a circular dependency because module A can’t see into the submodule of B. Surely, one has to check whether and how we can achieve the disentanglement of our f77 interface and how to ensure the compatibility with our build system.
About the compiler support: Intel implements this feature since version 16, Gfortran since version 6. I don't know about the others.
@fstein93 back when I opened the issue Jürg and I already discussed about submodules and I agree that this is the way to go. Please keep in mind that for submodules we also need the build systems to support it, not only the compilers.
CMake with Ninja should be able to handle the dependencies properly, CMake with Make I am not so sure about (depends on CMakes built-in Fortran parser).
From what I understand, the only real advantage of submodules is that they can speed up the build in some cases. At least Gfortran is already smart enough to rewrite the .mod files only when the public interface has actually changed.
I think, a much more promising approach are abstract types. I really liked this exploration by Tiziano.
As for circular dependencies, I think we should simply try to avoid them. Yes, it's a constraint, but a good one that forces us to organize the code in a comprehensible manner.
