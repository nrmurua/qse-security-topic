QPY serialization fails when attempting to serialize a circuit containing an IfElseOp.
The circuit should be able to be serialized and de-serialized.
No response
So there are 2 things we need to fix here. The first is to add qiskit.circuit.controlflow to the module lookup path for terra objects here: https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/circuit/qpy_serialization.py#L1122-L1125 and https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/circuit/qpy_serialization.py#L976-L983 so that qpy know about the control flow instructions. Otherwise it will try to treat the control flow instruction objects as custom instructions and make them instances of Instruction instead of the actual control flow object. The other piece of this is to allow circuits as a valid parameter type for instructions, here: https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/circuit/qpy_serialization.py#L1183-L1222 and https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/circuit/qpy_serialization.py#L934-L956 and we can just use https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/circuit/qpy_serialization.py#L1428 with a BytesIO buffer for the payload.
The only potential (mostly because I'm not as familiar with the control flow instructions) complication I can think of is if IfElseOp(**params) doesn't work we'll need to add a custom handling for it here: https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/circuit/qpy_serialization.py#L961-L991 in the deserializer. But, if we need more information from the object than what is serialized by default we'll probably need to define a custom serialization format for it (similar to what we did for the PauliEvolutionGate in #7374) so that we have all the necessary information in the qpy data to reconstruct the operation on the deserialization side.
IfElseOp(**params) will fail, because the first positional argument is the condition, which is stored separately on Instruction, not in params.  The same goes for WhileLoopOp, but ForLoopOp is in that form.
I guess we need to add an arbitrary serialisation hook here.  I think we want to avoid any possible arbitrary _de_serialisation hooks, so we could ask for a method that will return a 2-tuple (args, kwargs) that can be passed to the initialiser to reconstruct the state of the object, and then recursively serialise those?
Well we've had to do deserialization conditions before for instruction types which behave differently for weird reasons. Barrier and Initialize are the only two currently. We also serialize the condition attribute currently. So assuming the condition attribute is the same tuple of (register/bit, value) that other instructions have we wouldn't need to change anything on the serialization side and we can just add conditions like we do for barrier and initialize today. I think this might be preferable just because it's a smaller change for a backport and doesn't require defining a new type for the custom instruction table.
I think for the ever growing qpy v4 todo list (which already includes a global parameter table and pulse support) in 0.20.0 allowing an instruction class to define it's own (args, kwargs) for the constructor with something like a __qpy_args__() method for serialization is a good thing to do.
Having the condition is fine, the problem is that the constructor of IfElseOp and WhileLoopOp take condition as their first positional argument, and don't put condition in the params attribute.  The condition is the same tuple, but you do something like
We can do it, but it'll need special handling for IfElseOp and WhileLoopOp when reconstructing the instances, to pass the condition positionally first (they error if there's no condition).
Also, can qpy currently serialise a parameter of None?  IfElseOp can have None as its second parameter if there isn't a false body.
Right, I just meant we have a place already for this kind of thing where we have to do that kind of custom deserialization construction. Since we had to do it for Barrier (which does Barrier(num_qubits) which isn't a parameter) and Initialize (which does Initialize(params) instead of Initialize(*params). So for 0.19.4 I think if we do something like:
around here: https://github.com/Qiskit/qiskit-terra/blob/main/qiskit/circuit/qpy_serialization.py#L986-L992 that fits in with an existing pattern and won't be too intrusive and seems like the simple path for a backport fix.
As for None, that's a good call we don't support that yet either. That's trivial to add as a supported param type, we can add that at the same time we do QuantumCircuit
