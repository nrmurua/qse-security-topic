The function steadystate() does not seem capable of handling Liouvillians with non-unique steady states. This is immediately apparent because steadystate() does not contain an argument for an initial state at time zero. Instead, it returns a state (presumably some linear combination of the null-space operators) that does not match the long time output from mesolve(), which varies based on initial condition.
There are many Liouvillians which do not admit unique steady states, but a simple example can be found in Section 3.3 of this tutorial.
No response
For Liouvillians that admit non-unique steady states, I expected steadystate() to return the long time limit of mesolve() given a particular initial condition.
No response
Yeah in my experience this is something one has to be careful of with the steady-state solver as it is. Depending on the method chosen it can either fail, return one of the possibilities, or some linear combination of them.  The default one (direct) tends to fail, which at least sometimes lets you know you have this issue.
We could consider adding null_space solver which returns all possibilities, or modify the existing svd solver to do so if possible?
Still, if the default "direct" method is silently failing it may trip people up still, so adding some examples to the documentation might help, as a minimum.  I don't know of a way to extend that direct method to return all possible solutions, and connect those to possible initial conditions.  It would be very interesting if its possible!
One minor thing; looking at the the example in the linked paper you provided seems to badly constructed.  The dephasing operator they define there is actually just an identity, so does nothing, so technically the second example has no well-defined steady-state at all.  A more useful example would be a proper dephasing through a collapse operator = sigma_z,  and no driving on the qubit, so the degenerate steady-states are =\pm 1.
