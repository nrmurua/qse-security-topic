Operator.from_circuit throws a "cannot find bit" error when called on a transpiled circuit that was originally constructed out of:
All of these examples print "failed":
The actual exception is along the lines of
The bits we're looking up should be the ones that are actually on the circuit.
The current form only works (as best as I can tell) with circuits constructed as QuantumCircuit(n), where n is the number of bits in the backend used in the transpilation call.  The fact that this works is a side-effect of how the legacy Qubit hash function works, and that the legacy behaviour of QuantumCircuit(n) is to create a register called "q", which is the same name as what the layout passes create by default.
The _layout field in a circuit from transpile has the same qubits as the input circuit in its "virtual bits" fields, but the returned circuit has a single register called "q" that fills everything.  The lookup in Operator.find_circuit tries to use the virtual bits from the original circuit, but these don't exist any more.
I'm not actually sure if this is recoverable off the top of my head - I'm not certain Layout retains enough information to infer the order the virtual qubits of the previous circuit were in, especially if they are loose bits.
I tried to integrate a fix for this here: https://github.com/Qiskit/qiskit-terra/pull/8597/files#diff-f5222a986231cd8c6a8d2c71592e43aaf0ba310b123373fb47fe156d4dc34e72R244-R255 (if that PR doesn't make the release we can always extract it as a standalone bugfix). It is a tricky problem in general because as you say the Layout from transpile doesn't always provide us with sufficient information to do this. Since the output layout from transpile is the input circuit qubits to the output physical qubits (which are equivalent to the output virtual qubits index in the output circuit). That mapping doesn't give us sufficient information to know what order the input circuit's virtual qubits are in. The best we can do in the case where the virtual qubits aren't the same post transpilation (i.e. a flat register for all active qubits named "q")  is to rely on insertion order but I'm not sure we're necessarily constructing the layout object in the same order as the qubits in the input circuit. We might need to rethink what we return from transpile for the ._layout attribute to handle this (or add an additional attribute for pre_layout qubits or something like that) to be able to do this robustly.
I'm not opposed to us adding a public QuantumCircuit.layout attribute (defaults to None), which will let us put whatever object we like there.  I don't much like how _layout is private and pretty informally specified, but quite a few bits of Qiskit access it and do things based off it.
Well IIRC, when the _layout property was added we weren't sure that it was the interface we wanted to commit to which is why we made it private. I do think since we're trying to get better about this exposing this more having this be public makes sense now, but I'm thinking making it a tuple with like the Layout object and an optional list of circuit.qubits (defaulting to None) from the original pre-transpiled circuit (matching the order in the original circuit) might be the better interface. This would give us sufficient information to track the permutation correctly in all cases I think
Yeah, or perhaps a dataclass / some custom object that contains the original qubits and the layout?  It's easier to extend an attribute-based object than a tuple if we need to add more later.
I pushed up a fix PR in #8802 and left the property as private for now (and used a tuple) to make sure we could include it in 0.22.0 at this point in the cycle. I'll open a new issue for 0.23.0 to make a public layout attribute and/or a public method to reverse the layout somehow and we can make a container class for it as part of that
