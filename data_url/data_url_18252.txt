The attached fuzz_reccztqq.txt triggers a ValueError: math domain error exception when executed with the mapping {0: [2], 1: [2], 2: [3], 3: []}:
It is my understanding that the program should execute just like as when there is no map restriction:
The attached example was generated by a fuzzer. It could be the current behavior is the expected. My apologies in that case...
This is due to numerical error in the argument of acos in yzy_to_zyz. For example, math.sin(math.pi/2) * math.cos(math.pi/4) / math.sin(math.pi/4) = 1.0000000000000002 > 1. One solution is to round the argument.
One option is to round, but that might add errors after several computations. I suggest to move to symbolic computation instead of flouting point math to avoid this issue:
Comments?
I think @awcross1 was giving an example where it fails, but it general the inputs are not symbolic they are floats.
The particular case in yzy_to_zyz, can be solved symbolically. There are several other points in the mapper where math is used, that can be easily be replaced with sympy.
I'm not sure what you mean. In situations where user code has floats, that error is introduced by the user and we can represent exactly that error without adding more, using Decimal in the parser.
My point is, when possible, we should operate with symbols to avoid adding error.
Thanks Luciano, I think it is worth investigating using symbols.
Here is a self-contained test case from @dcmckayibm that triggers the error
from qiskit import QuantumProgram
import numpy as np
coupling_map_test = {0:[0]}
qp = QuantumProgram()
qr = qp.create_quantum_register('q', 1)
cr = qp.create_classical_register('c', 1)
qc = qp.create_circuit('qc1', qregisters=[qr], cregisters=[cr])
qc.u2(np.pi/2, 0, qr[0])
qc.u3(np.pi/2, np.pi/2, 0.0, qr[0])
qp.compile('qc1', coupling_map=coupling_map_test)
Closing the issue, as it was fixed by #151 - thanks Luciano!
