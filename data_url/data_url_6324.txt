Per #710 forward through this issue, I have been working on approximation methods in QUnit, for wider and faster, shallow simulations. So far, single qubits are pressed into Pauli X/Y/Z eigenstates by a user-controlled variable radial clamping distance on the Bloch sphere, with normalization to compensate for "leaked" probability from clamping.
The Bloch sphere is a 2-sphere, describing the full pure state space of a single qubit. A 2-sphere implies a 3-ball embedding, (at least naively). Since QUnit can transform Pauli X/Y/Z basis independently for each qubit, this covers the 3-ball embedding implied by the Bloch Sphere.
Two connected pure qubits are the Kroenecker product of two 2-sphere Bloch spheres with 3-ball embedding tangent spaces, implying 9 permutations of two tangent 3-spaces. These 9x2=18 nodal states on the product of two Bloch spheres are Clifford. If we attempt to separate 2 qubits from bulk at once, the natural extension of the single qubit method is to attempt to clamp to every available stabilizer state among the 2 qubits.
Generalize this iteratively through all possible stabilizer states in an arbitrary set of bits to TrySeparate(). Since the bits representations might not be fully connected in QUnit representation, the number of possible Clifford states worth attempting is reduced.
Given Qrack's fundamental reliance, mostly, on single-target, single-control gates, much could likely be gained from just handling the two qubit case, for now, iterating over all 2 qubit stabilizer states to attempt to clamp, and leaving larger TrySeparate() sets to the general case handler, (which is too expensive).
To use the new features, the probability clamping threshold can be set with a constructor argument to QUnit or overridden universally with the QRACK_QUNIT_SEPARABILITY_THRESHOLD environment variable. The --benchmark-depth option for the benchmark suite is also useful, to this end, for choosing the depth of single-qubit plus two-qubit layers across the full width of a benchmark. See, particularly, test_ccz_ccx_h.
