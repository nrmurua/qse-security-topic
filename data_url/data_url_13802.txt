I'm trying to anticipate and reason about what effects the added gates in #156 will have on the library. I'm reading the code to greedy_consume_gates and came across the following line:
gatetype = {i: 0 for i in range(qubits)} # 0 = Z-type, 1 = X-type, the two sorts of commutation types.
This initialises a dictionary with a key for every qubit, and a value of 0. However, in the following code block, gatetype[q] is only ever assigned a value of 1 or 2 (not 0 or 1 as the comment claims). So it looks to me like 0 is the uninitialised value, whereas 1 and 2 are the Z-type and X-type values. Is this correct or did I misunderstand something?
There's also an if-block that has the condition if g.control == q: gatetype[q] = 1. I presume the behaviour of that code block is still correct for gates with multiple targets, such as ParityPhase, since those qubits will fall into the else branch. But what about gates that have multiple control qubits (named ctrl1 and ctrl2), such as Toffoli and CCZ? Then g.control == q will be False, so the assignment gate_type[q] = 2 will be made for the control qubits, which seems wrong? Or is greedy_consume_gates only called on a basic subset of gates which are guaranteed to have one control and one target (in which case there should be an assert guarding it to catch potential bugs  or misunderstandings caused by calling it with other gates)?
I have not really used this function in many years, so not exactly sure what the state of it is. I'm pretty sure it will only work correctly if you have called to_basic_gates first.
