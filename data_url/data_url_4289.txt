Had a discussion with @marekgluza about  Issue  #1034.
We had two pull requests resulting from that issue,  Double bracket flow #1047  and also DBF: tutorial #1087 . These are great features and tutorials.
From the current implementation, we can see that users will have to write their own for loops, I wonder if we can incorporate this step as part of the function to make most future codes more compact and also reflect how DBI or DBF should be used.
@Edoardo-Pedicillo @MatteoRobbiati @andrea-pasquale, more broadly, we could think about the main use of the model. In my mind this would be:
smallest feature: double-bracket rotation $e^{-s_k \hat W_k}$. This is now called dbfand the inputs steer what is $\hat W_k$. Possible change is to call a DBI recursive step a double-bracket rotatin (DBR) so chang dbf to dbr.
more generally, I recommend for us to depart from saying flow sooner than later. That way we can stress the sequential character of the circuits that would be ultimately used and the continuous flow equations will not come into view and cause confusion. That would in particular mean to call the module DoubleBracketIteration(s). If needed we can link with the package by Steven Thompson @sjt48 which actually studies flow by using ordinary-differential equation solvers https://github.com/sjt48/PyFlow
then currently a user is looping over dbf. This is fine to give a user flexibility to design their scheduling from outside but @shangtai is completely right that running a sequence of say $K=10$ DBR steps forming a double-bracket iteration (DBI) of 10 steps would be useful too, even if to get onboarded. Possible change would be to write a function call dbi which takes in as input step durations $s_0,s_1,\ldots$ and either $\hat D_0, \hat D_1,\ldots$ a sequence of diagonal operators or a handle to a map which will produce them on the fly given the iterated Hamiltonian $\hat H_k$ so $\Delta^{(Z)}(\hat H_k) \equiv \hat D_k$. This latter map could be a handle to a loop optimization function that variationally constructs $\hat D_k$ based on $\hat H_k$. Please evaluate if these 3 modes (default, instructed by hand, constructed on the fly by optimization) would go well with the code, in my opinion these are natural generalizations and would provide clarity.
finally, a user might want to have some ways of putting together some strategies e.g. first 5 steps canonical bracket, then start optimizing etc. This point is vague and I don't recommend action before we have a good use example of configuring strategies easily, in the end the way Matteo showed in the tutorial is not difficult and using dbr a user can make a for loop and essentially implement a custom dbi
As a last point, @shangtai means that sometimes users would like to have access to a set of routines with 'best' strategies (up to our knowledge). We could handle this by making a separate pip package called double_bracket_iterations and then QIBO users could opt to pull that into their workflow via a dependency. That separate package could be more liberal in it's scope (I agree with @MatteoRobbiati that it's good to keep QIBO crisp). @scarrazza if you think this is a good idea, we could make a github still within the QIBO team or should we make a separate team e.g. called DBI collaboration?
Thanks @marekgluza for the summary.
@scarrazza if you think this is a good idea, we could make a github still within the QIBO team or should we make a separate team e.g. called DBI collaboration?
The problem with this approach in maintainability, e.g. keep track of further CIs, tests, docs and releases. Therefore, my recommendation is to keep developing the strategies here until we have some technical motivation to create the external package, examples are: complex extra dependencies, too large codebase, etc. I also believe that at this stage of the development is simpler to just touch a single package until we have a working system.
@scarrazza Hi Stefano, I talked to @marekgluza and I'll be working on implementing some examples on how to use the double-bracket steps from @MatteoRobbiati, in a way that @shangtai suggested. We will do this building on the tutorial notebook Matteo created.
How should we communicate the results to you? Through pull request or?
Yes, please open a PR with the tutorial.
Summarizing a quick meeting with @marekgluza this morning, let me suggest the following:
Thanks everybody, the workflow is now clear to us
#1143
