Opflow objects are immutable by design, however the PauliSumOp stores it's primitive by reference and when the original object is modified the PauliSumOp is affected.
If the PauliSumOp is instantiated with a SparsePauliOp, make a copy
I think this store by reference is true throughout opflow. Directly modifying the primitive that was supplied always had this effect - my recollection is that storing by reference was to avoid costly copy operations. Although logically opflow primitives were immutable, if you maintained references to the original entity it was built from, a matrix or whatever, and changed that then like saw here it changes the primitive itself. Its no different that accessing the primitive on the object and directly modifying the primitive.
In general with this sort of thing, you can have your cake and eat it by having a default copy=True parameter in the initialisers.  All library code will construct the primitives internally, so can safely pass copy=False, because know they're providing the only reference to an object, and so you get the same speed you had before.  However, if a user doesn't specify it, then they get the slightly slower but safer behaviour, and they have access to the fastest versions as well with the flag.
I think it was expected that expressions using opflow would be normal and hence there is a lot of implicit construction that goes on then which would all be under default behavior. Maybe some global flag could do in its stead to cover these cases too. I know the goal opflow was to keep the operations/behavior lightweight until things were finally needed. FYI the behavior is noted here https://qiskit.org/documentation/stubs/qiskit.opflow.primitive_ops.PrimitiveOp.html about the underlying primitives not being copied.
I'm good with storing the reference I was only worried that this was not intentional, as pretty much all operations are out-of-place and I thought opflow was designed to have immutable objects. But if that's intentional I'm fine and this issue reduces to only the bug that PauliSumOp.permute modifies the original object, as discussed in #7339.
This is fine, because it's already closed, but the important point is that CircuitOp and other opflow classes also have references. In the first place, opflow is mutable, and hence not hashable.
