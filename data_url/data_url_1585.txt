One of the most noisy operations in superconducting machines is measurement. It's a bit ironic that we don't actually have a built-in operation for it!
I think we should define a NoisyMeasurementGate that has a confusion matrix defined. Then it should provide efficient implementations for each of the simulators.
It might be reasonable to extract the notion of applying a confusion matrix to a classical result into a zero-target gate, so the noisy measurement can decompose into measure+confuse instead of having to be defined as one thing. It also likely makes sense to incorporated some additional optional arguments into cirq.measure  for creating noisy measurements.
We don't do this for other gates, namely have noisy versions. Instead we have noise models that insert noise operations after (or before) noiseless versions. In that context, we'd need to introduce an assymmetric bitflip channel and a noise model that inserts that before noiseless measurement operations.
If we implement this as noisymeasurementgate, it could be easier but I can forsee future requests for noisy versions of the rest of the gates
Notes from Sync:
More notes from Sync:
This probably needs an RFC (assuming we don't go with NoisyMeasurementGate).
I also stumbled upon the need for this when working on #4800 -- +1 to prioritizing this issue.
Some more thoughts on the issue:
@mpharrigan's suggestion above for adding an AsymmetricBitFlipChannel should work for the simple use case of adding uncorrelated/local readout noise to each qubit -- the assumption here is that we are not doing any operations after measurement, because in that case the qubit state would be different if we apply the noise to classical measurement results vs if we apply noise to the qubit itself.
However, the confusion matrix approach to apply noise on the classical measurement results can also be useful to capture correlated readout noise, i.e. we can specify a 2 ** n x 2 ** n confusion matrix (or multiple smaller 4x4 matrices for every adjacent qubit, to simulate "local" noise) which can then be used to change a sampled state i to j by with probability P(j | i).
In terms of implementation, I think creating a new NoisyMeasurementGate should be the straightforward way to do it. The gate can take a confusion matrix in the constructor and we'll have to implement the _act_on_ protocol with the correct logic. One proposal to do this would d be to directly update ActOnArgs.measure() to also accept a confusion matrix and use it to compute the corrected bits. @95-martin-orion and @daxfohl what do you think about this proposal?
I don't think we should implement it as a _decompose_ to measurement + confusion matrix gate because the latter would need to look at the results of the measurement to be able to update them. Hence there's an implicit coupling b/w the two decomposed gates and hence it's probably better to not decompose them at all.
One more possible approach would be to start accepting a confusion_matrix parameter in the vanilla MeasurementGate itself. This will behave like a more complete version of the invert_mask parameter. This will also enable us to start supporting noisy measurements in other composite measurement gates like the PauliMeasurementGate, which decomposes into the vanilla MeasurementGate.
Not really an answer but note we also have PauliMeasurementGate. (And maybe should there also be a NoisyPauliMeasurementGate?) So given the Rule of Three, perhaps it's worthwhile to invest in an abstraction.
I think measurement isn't in a great place ATM, given the number of isinstance checks that we'd have to update, and that the is_measurement protocol also matches subcircuits, which is sometimes what you want but often not.
I am half inclined to say that we should delete the PauliMeasurementGate and just add extra parameters to the regular MeasurementGate to represent Paulis and or confusion matrices. In fact maybe I'm three quarters inclined. It would be the simplest least breaky way and would allow the combination of features without needing multiple inheritance. Though I haven't looked at the code lately.
Also need to determine how this fits with the deferred measurements transformer.
@tanujkhattar's option (5) appeals the most to me. invert_mask is a subset of the requested behavior; we just need to generalize that behavior to include confusion matrices. A separate NoisyMeasurementGate feels unnecessary.
My primary concern in this process is how qsim will interact with the result. qsim classical-state handling is entirely separate from Cirq's log_of_measurement_results, so any change to how Cirq handles classical data requires a nontrivial change to qsim as well. Generalizing invert_mask works well with this, as qsim already has a code path for handling invert_mask-type behavior.
From cirq sync:
Let's proceed with option-5 proposed above to modify MeasurementGate.
