Right now we leverage a mix of different import styles all over the repository. Imports vary between absolute and relative imports, as well as between class and module level imports. This should be cleaned up for 2 reasons first for consistency throughout the repo so everything looks the same way it makes it easier for new contributors to recognize the style, and secondly because class level imports cause circular import problems (for examples of this look at #911 or #1152 ) Instead we should make all imports absolute module level.
So for example instead of something of the form:
from ._quantumregister import QuantumRegister
it would be:
from qiskit import _quantumregister
Then for every instance of QuantumRegister in the code it would become _quantumregister.QuantumRegister
This will prevent potential circular imports when refactoring or adding imports in the code since python can resolve them at the module level. Additionally this pattern will make it very clear in the code where a specific module or object is coming from.
The only problem with this is we need to maintain our public top level interface. We modeled the qiskit namespace after something like numpy, where all the public methods are accessible off the top level. This is very convenient and also saves typing for users. So we should model how we define our usage based on what numpy does, which is leverage __all__ to define the top level. See: https://github.com/numpy/numpy/blob/master/numpy/__init__.py#L168 We should define the public functions and classes in each module using all and then aggregate those into the top level __init__.py for the qiskit namespace.
@charlesastaylor I think this will mostly be mechanical work, just updating all the imports to be the same for everything. The only complexity comes from making sure we get setting __all__ correct everywhere so the public interface remains unchanged.
I'll make a start in the next couple of days.
I'm labeling the issue as discussion, as changing the import convention it's a decision that needs to be evaluated carefully. @charlesastaylor , could you hold off starting the implementation until we get more input? Thanks!
#1172 is another place where the current import setup has caused an issue. As we refactor things this will continue to cause issues
Do I infer from #1206 that this is agreed on to do?
Nope, not agreed yet :)
So the underlying issue here is caused by any cycles in the import tree. Regardless of how deep if there is a class level import anywhere in the module level code in the call path for any module that has a cycle, python will not be able to resolve it and raise an exception (and one that isn't exactly clear either). For example let's look at one of the examples I had to fix in #911 and #1152 before it could even work. Adding an import from qiskit.tools.visualization to qiskit._quantumcircuit caused this situation:
qiskit._quantumcircuit -> qiskit.tools.visualization.__init__ -> qiskit.tools.visualization._circuit_visualization -> qiskit.transpiler.__init__ -> qiskit.transpiler._transpiler -> qiskit.unroll.__init__ (really just class level direct imports of DagUnroller, DAGBackend, and JsonBackend, but from that module)
This problem here was that qiskit.unroll.__init__ had a class level import to qiskit.unroll._circuitbackend which had a class level import from qiskit._quantumcircuit (actually qiskit.QuantumCircuit, but this doesn't make a difference). The problem was no matter what you did because of the class level imports from qiskit.unroll.__init__ regardless of where you import from qiskit.unroll.* you always would end up with a cycle python could not resolve. For example changing the imports in qiskit.transpiler._transpiler to directly import the module with the class (like changing from qiskit.unroll import DagUnroller to from qiskit.unroll._dagunroller import DagUnroller) will not fix it because the class level import is in in __init__ which always will have all module level code get executed at import time.
Unless you guarantee that there will never be a cycle at any depth in the import tree (which is increasingly difficult as a repo gets larger) the only way to fix this is use module level imports. This isn't an issue for users of a project because it's not very likely they will cause an import cycle from outside the repo (unless it was in qiskit already), so using class level imports from outside the qiskit namespace would still be safe.
Is there something that still needs to be discussed here, @diego-plan9 and @mtreinish ?
I think the main premise (the over-abundance of circular imports) has been alleviated since a while back (probably around #1600), when we updated the linter version which includes a check for cycles and a series of followups and small refactors.
Is there any other aspect of the original issue still missing?
I think there are, but hopefully they can be discussed as new issues individually if needed, as the rationale seemed to be very bound to the circular import issue - feel free to reopen if you feel they are better suited in this one! üëç
