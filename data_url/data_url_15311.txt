Creating a QuantumCircuit and appending operations into it is a very common pattern. It would be very convenient to be able to create a QuantumCircuit by directly passing an iterator of operations, something like:
Currently this is not possible as written but it would be if my proposal #8707 were implemented.
I agree that this is a useful constructor method that we could implement. We can do this without #8707 (which I'd generally oppose on the grounds of error-checking) - the control-flow builder interfaces already do something very similar when building up their internal blocks.
(Just to add: the iterable should probably be of CircuitInstruction, not the legacy 3-tuple, since this is a new method with no backwards-compatibility concerns, but otherwise I'm fine with it.)
We can do this without #8707
@jakelishman so how should this be done? would you just do circuit.add_bits(set(qubits) - set(circuit.qubits)) before every append?
Yeah, exactly.  It'd probably be good to do a shade more book-keeping just for efficiency and reproducibility reasons (ensure that bits get added in the order they appear in the operand sequences, make sure condition bits and cregs are respected, and track the sets of what we've already appended internally to avoid recalculation), but those are just minor implementation details.
Similarly, you probably want your constructor to accept name, global_phase and metadata fields like the main constructor.  If you'd like to write a PR to do it, I imagine we can get it merged into 0.22 if you've got time this or next week?
I'm not sure I'll have time, so don't let this block 0.22. Why does Circuit.qubits need to be ordered? For this specific purpose it would be better for it to be unordered.
It's not absolutely critical, it was just on my mind because we occasionally have issues testing the circuits produced with the control-flow builder interfaces because they have a non-deterministic ordering (admittedly limited to the arguments of the blocks) - hence the recent #8627.  I think you're probably right that it's not an issue here.
That's fine if you've not got time, no worries.  We can mark it as a "help wanted" - I think it's a good issue for someone in the community to take on.
For a community member wanting to have a go at this, the rough interface would look like
CircuitInstruction always contains only Qubit and Clbit instances, so we'd need to track the bits used in a set, and append them to the circuit before appending the instruction if they're not already there.  We'd also need to take care to ensure that any bits or registers that appear in the condition field of an Instruction instance are added as well.  For control-flow instructions, the method would need to inspect the blocks field (which contains QuantumCircuit instances, and ensure any registers in there are also in the top-level circuit.
@jakelishman I meant to ask about the Circuit.qubits attribute. It already exists, and it is a list and not a set. Why is that? Can  we make it a set instead?
It's important for it to be a sequence, because it defines the order that bits are applied to it when a circuit is used as an Instruction definition, for example - we associate CircuitInstruction.qubits with the QuantumCircuit.qubits by equal indices in the sequence.  We do actually have the set view already, it's just a private attribute - it's QuantumCircuit._qubit_indices, which is a dict. (I forgot about that when I was saying we'd need to track the set separately.)
@jakelishman @kevinsung I used the proposed interface for the from_instructions function. for now it has a fixed 2 qubit size.
I tested this function with CircuitInstructions in a list, but these instructions are a bit long for a user. So I should make a more user friendly interface and use set.qubit function?
I'll take over this issue, please assign me.
