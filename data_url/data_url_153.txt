In CUDA Quantum, a spin op is a C++ object that enables the programmer to encode a polynomial that can be used as a general-purpose specification for rotating a set of qubits. These data objects are encoded and passed into kernels. At a primitive level, the vector of double values can be used to encode the spin op object.
The structure of the polynomial is a sequence of terms separated by operator+. Each term can be composed using operator* of a complex literal and 0 or more qubits (implicitly enumerated from 0 to n-1) with I, X, Y, and Z Pauli functions. The following shows a spin op in C++ form.
This example has 3 terms. The first term refers to no qubits. The second term refers to qubit 0. The third and final term refers to qubits 0 and 1. The total number of qubits is thus 2 (the maximum over all terms). In implementation then, every term will have a vector of 2 qubits and any unspecified qubit in the term will be added as an I (identity) Pauli function. For example, the above spin op can be rewritten as the equivalent expression.
For AOT compilation, having the polynomial as constant information is advantageous. If we know the entire polynomial and that the polynomial will not change at runtime, the compiler has some freedom to decompose the spin op into quantum gates [1], fold values, derive a quantum circuit, etc.
On the other hand, as a spin op is intrinsically just data, it could be the case that an AOT compiler knows that a spin op exists and nothing else. The number of terms, qubits, and values involved might be statically unknown. In the case where nothing about the content of the spin op is known at AOT compile-time, the compiler will not be able to generate the circuit nor decompose its gates, much less optimize the resulting circuit. This problem falls squarely in a JIT compile-time class. The executing program will have to ultimately present the content of the spin op to the QPU for execution, and it would be at that time that the JIT compiler could finally construct the quantum circuit for execution.
The middle ground is that the computational structure of the spin op is known at AOT compile-time but the constant coefficients are deferred to JIT compile-time. Such a spin op polynomial might look like the following, where coeff_i is an unknown complex floating-point value.
Note that the exact qubit is already a variable. The polynomial just indicates that a vector of two qubit references is required. It does not specify which qubits will be the two operands.
The I, X, Y, and Z Pauli functions affect the decomposition and having them be variables will change the structure of the decomposition. Adding more terms would also, of course, change the computational structure of the quantum circuit. The number of terms is capped at 4Q, where Q is the maximum number of qubits in the expression. Any terms with the same combination of Pauli functions can be combined by adding the coefficients (algebraic simplification).
The cudaq runtime has its own data structures to encode a spin op. It is highly desirable for the runtime and the compiler to generate similar data structures or, at minimum, have well-known functions in the runtime to make any conversions.
Within the compiler, all spin ops will have a well-defined representation. This representation may be statically constant or deferred and populated at synthesis (just prior to JIT compilation). A spin operation can be encoded as the following type, where T is the number of terms and Q is the (maximum) number of qubits.
Such a spin op may be created as a constant in a kernel or passed from C++ application code. Both cases must be handled.
For a dynamic spin op, the number of terms and qubits must be passed as data at runtime. Such a structure might look like the following.
The pointer argument would be “opaque” and address arithmetic would be needed to recover the implicit array of structures.
It seems that a Quake Op to build a spin op would be a good idea. Having a special type at the Quake level for a spin op to distinguish these values explicitly may be useful as well. We don’t necessarily what to immediately lower these to bitstring encodings nor allow the compiler to optimize the encoding into something unexpected. A unique type would abstract a spin op that is passed into an entry kernel as well.
Spin op decomposition can be achieved for each Pauli term via using a generator function (written in MLIR so it can be inlined?). The coefficient, number of qubits, and Pauli terms would be decoded to generate one of the family of possible CNOT ladders.[1]
A high-level optimization of a Pauli spin op would involve folding of terms. This folding can be done in construction or by Ops in Quake to combine spin ops (operator+) or perhaps take their difference (operator-). This depends a bit of the level of expressivity in the C++ class(es) in the cudaq headers.
The low-level optimization of a Pauli spin op in, for example, a Suzuki Trotter decomposition should follow from any other gate-level optimization. Synthesis of the circuit is required.
[1] Paulihedral: A Generalized Block-Wise Compiler Optimization Framework For Quantum Simulation Kernels, Gushu Li, et.al., Paulihedral paper.
