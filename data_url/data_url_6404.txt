The current head of master passes the unit tests with VC4CL, but not with an Intel Xeon test system of mine. In the head, a reference to a class attribute of type std::vector<cl::Event> is cached and then passed out of scope after the attribute is replaced with a new object. If the reference is not passed, a build on the Raspberry Pi calls the cl::Event destructor, which calls clReleaseEvent when the object is replaced. If the pass-by-reference is removed, all systems pass unit tests except the Raspberry Pi.
The compiler on the Xeon is probably correct to assume that the vector should be safe to release at the point that object goes out of scope, (if that's what's happening). However, the copy constructor for the vector should transfer ownership and reference count of the cl::Event objects to a copy of the vector, such that the Raspberry Pi build might not be calling the same assignment or copy operator of cl::Event.
Neither behavior is necessarily wrong, despite the apparent differences in the compilers. When the object goes out of scope, it could be immediately freed; when the std::vector assignment operator is used, I'm not sure that we have a strict guarantee of the operator used for copying elements.
A WIP pull request will be opened to find an implementation that works on all test systems, including the Raspberry Pi. The WIP will, for now, point to an implementation that doesn't pass a reference out of scope, so that versions are available both in general and specifically for the Raspberry Pi. This reference is where the problem resides, but I'm still trying to figure out a fix that's compatible across all systems.
The PR now tries to "compromise" between the two compilers: the vector is initialized and kept as a std::shared_ptr. This seems to work on the Raspberry Pi and on a GTX 1070; the Xeon still has issues. I'm profiling with valgrind, on the Xeon, as we speak.
The Xeon is using Intel's "Compute Runtime" for/with OpenCL. I can't see any reason why the std::shared_ptr should not work where a naked vector would, assuming I've held onto strong references as appropriate. I'll report on the valgrind results.
It looks like the Xeon doesn't have the right allocator (by default) for the std::vector of shared pointers that QEngineOCL uses to hold onto wait event lists between first being waited on and being deconstructed. It can't push_back() with the default allocator, according to valgrind.
emplace_back should satisfy the allocation problem from the last comment, since the default copy constructor works for these shared_ptr objects, (as well as the copy constructor taking std::move()).
I'm kind of at a loss, because there is no longer even any mention of user code in valgrind. There are issues within the Compute Runtime, and perhaps something we're doing is responsible for that, but the output is unhelpful, now, while a problem persists.
(Victory!) Incrementing the reference count on passing out of oclengine.cpp instead of std::move seems to be the trick to keep the std::shared_ptr<std::vector<cl::Event>> allocated. I will annotate on the pull request, after I've repeated my tests a few more times. It seems all available systems pass unit tests.
