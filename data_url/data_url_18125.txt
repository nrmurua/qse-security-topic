Installing QISKit via pip breaks a conda installation if the already installed packages do not meet the requirements in requirements.txt.  Because the overwritten packages are installed via pip, the conda environment is not aware that they are there, nor what version they are, so one can not simply reinstall or upgrade via conda.  Moreover, the packages installed by pip are unoptimized versions of the ones in conda.  As the make file assumes conda, we should play nice with the conda build system.
Having the latest conda packages installed results in silently downgrading of certain modules, e.g. scipy because of restrictions in requirements.txt.
The downgrading of libraries should explicitly require the users permission, or the user should do it themselves.  Or, perhaps better, we remove the upper limits on the version numbers of the dependencies in requirements.txt.
Having my scipy silently downgraded from 1.1.0 to 1.0.1 broke some other code I was was working on that assumed the newer version.
Latest conda env with scipy=1.1.0 and doing pip install qiskit.
qiskit installed via pip only (no conda) also downgrades packages on ubuntu 16.04 (mind you not "silently", but does not ask for permission).
For example, at the moment both scipy and matplotlib get downgraded as the standard pip3 repos include versions 1.1.0 and 2.2.2 respectively (which are higher than qiskit's requirements).
I guess the question is if it's more likely the point release updates break qiskit, or if these downgrades are more likely to break other software people run. I would think, the latter is a more likely scenario, but maybe that's not quite right?
By silently I mean without the users permission / notification.  For example, contrast this behavior with that of conda when upgrading or downgrading.  You always need to approve.
I am not sure what the reason for having upper bounds on module versions is.  I would guess to prevent bugs from popping up.  But since your going to support the new versions at some point anyway, you will have to address them one way or another.  It is always possible to have Travis install the latest conda and test against it as well.
This seems outside the scope of qiskit itself, and more an issue of how an user decides to manage his environment: it is rather common that a general Python package depends on specific versions of the libraries, and arguably the main reason why virtualenv and similar de-facto environment managers exist - such as the conda environments:
With conda, you can create, export, list, remove and update environments that have different versions of Python and/or packages installed in them. Switching or moving between environments is called activating the environment. You can also share an environment file.
As hinted in #340 and hopefully reflected in the docs, we are aiming towards allowing the user to chose which environment he sees fit, and the documentation should currently not have an imperative reference to a particular environment (there is a light recommendation, but extended instructions should be out of the scope of the project) - the make env target that you mention is (as far as I know) not really mentioned anywhere, and actually does create a clean conda environment as suggested by the Conda documentation. Could you pinpoint the potential documentation issues that might be misleading, and ideally submit a PR for improving that aspect?
I am not sure what the reason for having upper bounds on module versions is. I would guess to prevent bugs from popping up.
Yes! We are being conservative in the versions of dependencies allowed as it is not possible to guarantee that newer versions of the dependencies will not cause issues with the current version of qiskit (API changes, etc happened in the past - networkx come to mind). It would be a good idea to try to do a round of testing to be able to raise the upper limits to more recent versions, though!
As the creators of the pip installer, isn't it really in our scope as to how we modify the users env?  We do not have to overwrite packages, it is a choice.  Instead we could just install ourselves and do version checks at runtime.  We already do this in the qiskit._util module.  In that case, the requirements.txt would be there as a guide for the end user to manually install dependencies, If needed.  As already mentioned in the docs, Anaconda already includes most if not all of the stuff anyway.
No where do we mention that we will downgrade your packages.  Indeed, the main qiskit.org page just says do pip install qiskit. The docs just say we will install dependencies, not downgrade existing ones.  At least this should be mentioned somewhere if we are not going to change anything.
As the creators of the pip installer, isn't it really in our scope as to how we modify the users env?
Hmm, but I think the choice of words is important here: we are not the creators of the "pip installer", we are the creators of the "pip package" according to the packaging standard - it's not in our scope reinventing how pip packages are installed and managed, nor we are overwriting packages, nor we should manage the user environment, as there are standard tools for that purpose and we should be able to expect some level of familiarity with those tools (virtualenv, conda env, ...). I'm updating the title to reflect better the issue.
What is in our scope, as mentioned, is:
I have a PR (#505) indicating that packages may be downgraded.
I already have the setuptools based repo that tests against the latest conda packages (i.e. I removed the upper bounds on the packages):
https://github.com/nonhermitian/arrogant_seahorse
Everything works fine.  It does not do the online tests though, as I do not know how to pass the token without it being visible.  Locally works fine.
Great! For the version updates, we cannot review unless a pull request against the current master is submitted, as usual - can you take care of submitting it?
Please note that simply removing the upper bounds is not the goal, as that would leave us open again to having our functionality broken (it has happened in the past). Raising them to the most recent versions possible is the idea - and if you can confirm which packages use semantic versioning or assure that they won't break functionality between non-major versions, it should be safe to aim for that (ie. be able to say <4 instead of <=3.14.16 if they clearly have that policy). You can probably just bump the numbers in requirements.txt and the existing travis in master should take care of the rest during the PR ðŸŽ‰
This is addressed, in part, by PR #509.
Closing this now as it has been addressed.
