I've come across an issue where Qobj.norm() is returning zero when I think it shouldn't.
Please see the following image showing an example of the issue: https://imgur.com/a/1E8FZWQ
Then norm of an operator (with default input) is its trace. The trace of the Qobj you give, out, is 10^(-6). If you increase the tolerance (by default, tol=0) or maximum iteration in the eigenvalues solver, it should eventually be equal to the trace function (tr()), result.
I do not really understand what the function of this 'tol' is, like how it is defined.
Just for clarification: the "trace norm" is not just the trace of an operator (which wouldn't be a norm at all; at best a semi-norm for density matrices: there are lots of non-zero traceless operators, like sigma_x). The trace norm of an operator A should be (A.dag()*A).sqrtm().tr() (in physics, at least, mathematicians seem to prefer (A*A.dag()).sqrtm().tr()). I think this was addressed in #748. Looking at the current implementation of .norm it looks like everything is fundamentally correct. I'd agree that for the operator in the screenshot, returning a norm of exactly zero does not seem ideal. Is there a rounding limit somewhere in the implementation that's causing this?
This is an artifact of auto_tidyup; the object in the picture is zero everywhere except the diagonal, whose values are of the order 1e-7.  The first step of calculating the trace norm is to do op @ op.dag(), which you can see will make all the diagonal entries of order 1e-14.  This is below the default tolerance for auto_tidyup, so the resulting sparse matrix gets contracted to zero.  This happens within Qobj.norm, so cannot be intercepted by the user.
Can be worked around by temporarily setting qutip.settings.auto_tidyup = False, but that's just a work-around.  Fixed already in dev.major.
