In my last call with @quantshah, we decided not to make qgrad dependable on QuTiP, for the time being at least. In tests, however, I think that QuTiP may help. For example, in a lot of test cases, I am using random kets, density matrices, and hermitian matrices: rand_ket, rand_dm and rand_herm from QuTiP. Would it be okay to use QuTiP just for testing, or is it preferred that I write my custom methods for anything that I am going to use for the tests? Because I suspect I would be needing some more functions too.
And since we do have a long-term plan to make QuTiP a dependency, we can probably go by it now?
cc @nathanshammah
Using QuTiP functions for testing would be fine but you have to distinguish using functions from qutip such as rand_dm, rand_ket etc. to help you construct the tests vs substituting QuTiP for your unit test asserts itself. E.g., look at one of the tests for Qobj in QuTiP. The assert statements check the logic "A == BB" or "AB == Identity". It would be fine if you use qutips qeye function to make the identity function.
But it would NOT be okay if your asserts ONLY checked your qgrad definition of fidelity == qutips definition of fidelity by doing something like below.
These tests would still be useful ofcourse and we can include them. But there should be some part of the test which explicitly tests the logic of your code instead of just relying on QuTiP and its function + tests. E.g., in the above qutip tests we check if the mathematical definition of A*A.inv() is correct by evaluating it to identity. So maybe your fidelity function also needs to test if two states that you know are orthogonal have 0 fidelity between them. Of if two mixed states which you know have 0.5 fidelity actually give you 0.5 fidelity with ´qgrad_fidelity´ instead of just relying on QuTiP's fidelity function.
Unit tests should be self-sufficient in making sure the logic of your code is correct.
Thanks @quantshah! I am using QuTiP's functions to help construct tests only.
I completely agree with Shahnawaz: unit tests should be self-sufficient and test the logics behind the code. You could have additional tests to check compatibility with QuTiP, but only for that purpose. You could use QuTiP building blocks just like one uses scipy's or numpy's building blocks (most of the times, if we are not interested at Qobj those would suffice.)
