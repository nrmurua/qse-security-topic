I was using PauliString to implement some operations like exp(i t X Y) |00>, but I found that the simulated state vector did not match the one given out by directly using numpy matrix multiplication (by a global phase). The code I used is:
Then I tried to test the simplest case exp(i t X) |0>, the results still differed. I found in cirq/ops/pauli_string_test.py, there are test cases in test_exponentiate_single_value_as_exponent, which assert that e^(-i X(q) 0.25 π) = Rx(0.25 π).on(q). However, in the definition of cirq.Rx, Rx(rads) = e^(-i X rads / 2) (similar for Y & Ry, Z & Rz).
Diving into the source code of PauliString.__rpow__, I thought it was the half_turns variable that led to the question. If we added coefficient=2.0 into the arguments when creating the PauliString, the test case above would pass, and the definitions of R{α=X, Y, Z} would be matched.
So maybe we should replace half_turns with turn = 2.0 * math.log(base) * (-self.coefficient.imag / math.pi) in PauliString.__rpow__?
This does look broken to me. @viathor for comment.
This was fixed by #2989. Note, however, that we will be removing support for applying np.exp to gates, since np.exp means element-wise exponentiation. This is being tracked at #2710.
