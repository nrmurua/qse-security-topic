When QUnit measures qubits, it flushes singly-controlled phase and "inversion" buffers that might further entangle the underlying ket representation. Therefore, calling measurement methods can cause a state that is (momentarily) simulable without exceeding system resources to nonetheless exceed available memory footprint. Of course, it would always be desirable to avoid that contingent behavior, as QUnit simulation without ability to measure is of arguably little practical utility, compared to not simulating at all.
However, all QUnit buffers are singly-controlled phase (Pauli Z-like) and "inversion" (Pauli X-like) gates, with arbitrary target "payload" phase factors: this class of gate generally commutes with measurement!
Measurement methods therefore have no strict need to further entangle ket representation under QUnit by flushing this type of gate buffer: it's possible to measure without regard to the buffers, simulate the collapse all buffered controls from the classical measurement result, and update both simulated qubit and classical measurement result for any controlled-inversion buffers that turn out to apply their (Pauli X) "payload."
(This seems critical for efficient simulation of 2019 Sycamore, only incidentally, besides its general value to Qrack and any attempt at pareto-efficient quantum computer simulation.)
My description of Pauli X payload case above is technically not right: what I mean that is that, we know the case is that the buffer was applied in the past, in the sequence of gates, but it's being buffered right now, and I can either flush it and measure, or I can measure, determine whether the payload activates based upon that result, and update both the simulated qubit and the classical measurement result upon basis of that knowledge, retroactively to collapse.
(Addressed by e232875!)
