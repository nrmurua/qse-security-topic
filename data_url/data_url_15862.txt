Summary: When transpiling a circuit with save_state instructions (such as those inserted into a circuit with the `save_statevector() function) to a backend that does not support it, remove/ignore them.
Users can save the statevector at the midpoint of a circuit by calling the save_statevector() function, which is useful for probing the circuit during simulations. However, then transpiling the same circuit to run on a backend that does not support the save_state instruction, such as the real quantum computer backends, the transpiler will fail with the message like this:
Unable to map source basis {('measure', 1), ('save_state', 1), ('h', 1)} to target basis {'reset', 'rz', 'measure', 'barrier', 'delay', 'x', 'snapshot', 'id', 'sx', 'cx'}
This is may be confusing the the user. Assuming that they interpret this error message correctly, their recourse is to regenerate the source circuit without the save_state instructions (e.g. by removing calls to save_statevector()) and transpiling again. This is cumbersome and perhaps error prone.
An improved approach would be for the transpiler to simply remove/skip/ignore save_state instructions when the target backend does not support them. The benefit of this is that it would allow the user to switch easily between statevector simulators and real quantum computer backends.
@wagnersj can I have a look at this issue?
@TheGupta2012 Of course you can have a look!
@wagnersj could you provide a starting point in the transpiler passes where this check should have taken place?
It would be really helpful if you could provide the specific file name. Thanks!
@TheGupta2012 The error message that I included in the issue description above occurs in qiskit/transpiler/passes/basis/basis_translator.py in the run() method. That would be a good place to start.
Hey @wagnersj . While exploring this issue I found that there are many other methods that are not supported by backends i.e. the methods of type QuantumCircuit.save_x where x is something. Since the transpilation fails for these other methods too, should I make a general checker for all of them inside the qiskit/transpiler/passes/basis/basis_translator.py file?
Thanks for picking this up @TheGupta2012 . I think there are a few complicating issues here.
This is may be confusing the the user. Assuming that they interpret this error message correctly, their recourse is to regenerate the source circuit without the save_state instructions (e.g. by removing calls to save_statevector()) and transpiling again. This is cumbersome and perhaps error prone.
At present, I believe this is the correct workflow (though agree the error message could be improved!) since, even if the transpiler ignored the save_* instructions, a hardware backend would raise an error like "Instruction save_statevector is not supported." upon seeing an unknown instruction type.
@chriseclectic and @mtreinish discussed a bit if the transpiler should ignore or raise early on such instructions in #5701 (comment) and may have some more background on motivations or alternatives.
Well, @kdk what my solution was to not even make a node in the source_basis pertaining to the save_* instructions that were not supported by the backend. I thought that would silently just execute our circuit without the incompatible save_* instructions and when done, just log the information that some instructions weren't supported on the backend which the user has provided. Is this thought process correct?
I thought that would silently just execute our circuit without the incompatible save_* instructions ...
I think this is slightly incorrect. Because the BasisTranslator modifies the input dag in-place, calling continue for any save_* instruction will leave it in the dag which will result in it ultimately being sent to the device.
Okay, so does checking during the original construction of the dag a better way to go here?
If yes, could you highlight which file is responsible for the same so that I could take a look at that directly. Thank you!
From some discussions with the team, the best fix here is to update the BasisTranslator to check if Instruction._directive (added in #5701 , and True for Barrier, snapshot, and all the save_* instructions) is True, and not attempt to translate the instruction if so.
Automatically removing instructions like these from a circuit, which are both not applicable and known not to affect either the result or runtime execution of a given backend, is something we should consider in the future, but will depend on some of the ongoing work in https://github.com/Qiskit/qiskit-terra/labels/ISA .
From some discussions with the team, the best fix here is to update the BasisTranslator to check if Instruction._directive (added in #5701 , and True for Barrier, snapshot, and all the save_* instructions) is True, and not attempt to translate the instruction if so.
Automatically removing instructions like these from a circuit, which are both not applicable and known not to affect either the result or runtime execution of a given backend, is something we should consider in the future, but will depend on some of the ongoing work in https://github.com/Qiskit/qiskit-terra/labels/ISA .
I had a small doubt here. If we chose not to translate the Instruction with the _directive parameter set as True, won't the dag still remain the same as it is being changed in place? Instead, I was thinking of updating the circuit_to_dag and circuit_to_dagdependency files and not add the instructions where _directive is set to True. What do you think?
I don't think circuit_to_dag should be worrying about removing backend specific instructions from the circuit for a couple of reasons. First, that is more the job of the transpiler. Second, converting to dag and back to circuit should get back to the original circuit (or close to it). To handle this in BasisTranslator one could record the directive nodes when going through the list (which aren't in target basis) and delete them from the dag afterwards.
Agree circuit_to_dag and the rest of the converters should be lossless, and that the BasisTranslator should check _directive and leave these instructions in place. Being able to remove them in a subsequent pass depends on our ability to know more about these instructions and the backend being targeted.
If I may suggest a naive way of working around it. We can remove the specific instructions from the circuit that are causing the issues.
Since I've just closed a related PR, an update:
I think automatically removing any instructions from a circuit with no translation/replacement in the preset pass-managers is against the contract of the transpiler, especially if it's a directive we'd have to assume the meaning of.  Personally my view is also that all unknown instructions should be rejected if the backend doesn't claim to support them, but with the assumptions we have about "barrier", I'm not 100% sold on that.
The most straightforward workaround for having the preset passmanager remove arbitrary instructions is probably to add a null rule to the SessionEquivalenceLibrary that replaces the instruction with nothing, though that's likely to only work with non-variadic instructions.
If somebody wanted to write a simple "remove without replacement" transpiler pass that took in a filter function, that's probably a composable way to achieve the desired behaviour here.  Let's say we had such a pass called FilterOperations, then the workflow would look something like:
Let's say we had such a pass called FilterOperations
https://github.com/Qiskit/qiskit/blob/main/qiskit/transpiler/passes/utils/filter_op_nodes.py
oh, lol, yeah, I even reviewed that for you like four weeks ago.  Well, I stand by what I said in the review that it would be generically useful!
In that case, I'm not certain that there's anything more in this issue that needs changes in the library.  I've updated my recipe above to show how to use the transpiler pass that actually already exists to do this, and I'll close this issue.  Please feel free to re-open if there's more to discuss.
