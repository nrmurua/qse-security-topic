Right now we have a stable branch for making bug fix releases, but without a policy for what and how we include changes in this. To help facilitate using it moving forward I wanted to propose a policy for this. I wrote this based on similar policies I've used on other open source projects:
The stable branch is intended to be a safe source of fixes for high impact bugs and security issues which have been fixed on master since a release. When reviewing a stable branch PR we need to balance the risk of any given patch with the value that it will provide to users of the stable branch. Only a limited class of changes are appropriate for inclusion on the stable branch. A large, risky patch for a major issue might make sense. As might a trivial fix for a fairly obscure error handling case. A number of factors must be weighed when considering a change:
When backporting a patch from master to stable we want to keep a reference to the change on master. When you create the branch for the stable PR you can use:
$ git cherry-pick -x $master_commit_id
If the patch you‚Äôre proposing will not cherry-pick cleanly, you can help by resolving the conflicts yourself and proposing the resulting patch. Please keep Conflicts lines in the commit message to help review of the stable patch.
Bugs or PRs tagged with stable backport potential are bugs which apply to the stable release too and may be suitable for backporting once a fix lands in master. Once the backport has been proposed, the tag should be removed.
Perhaps the tag should be stable backport potential as existing tags use spaces.
Sure, spaces are fine. I'm used to a more cli driven world and forget that github supports spaces. I've updated it in the issue.
üëç on this idea. Question on the backporting procedure, what is the advantage to fixing in master first, and then cherry-picking to stable? The alternative would be to fix first in stable, and then merge into master. The only difference I can see is in where conflicts have to be resolved (when merging into master, or when merging in to stable.)
It's mostly about managing risk of regression by introducing a new change on stable. By going through master first we're already reviewing and testing it to merge on master before we introduce the change to stable. The idea is that we only want to make changes to stable when the change is a known quantity. So we're moving from something we've already fixed and tested on master to the stable branch.
Right, when there are merge conflicts in either case when cherry-picking between branches and it'll be roughly the same amount of work on just that mechanically.
