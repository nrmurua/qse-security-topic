See @jakelishman 's comment on #301.
Jake's comment:
I think my problem here is that the spec doesn't have "imaginary numbers" in the type system.  There are real numbers and complex numbers, but no imaginary-only numbers.  With the current text, I don't think we should be exposing a new type in this manner in the AST.
To be fair, the current form of the spec with regard to complex numbers is not great.  The exact text is
complex[type[size]] types are initalized as a + b im, where a and b must be of the same type as type[size]. b must occur to the left of im and the two can only be seperated by spaces/tabs (or nothing at all).
Taken literally this implies that z = 3 im; is invalid OpenQASM 3 because it doesn't have the a +  bit in it.  Even setting that aside (a later example has z = -2 - 7im;, which also would be invalid), the AST representation of 3 im should likely be a complex number, not an imaginary one, if we were supporting complex-number literals.
The spec currently only really allows the im keyword in initialisers - the form of the initialiser doesn't really make sense to be used in any other situation because it can take expressions as a and b: the spec lists the following example:
which it presumably intends to be equivalent to 2.0 + 17.05im. It doesn't define how tightly the + symbol necessary for the initialiser should bind, so the sin(pi) could be attached to either the real or imaginary part right now. Having this adds an extra rule into the expression tree: as well as something like AddExpression: Expression "+" Expression you also need ComplexNumber: Expression "+" Expression "im" or something to that effect, and then you start getting super weird stuff like 2.0 + 3.0im * 2 could be parsed as MultiplyExpression(ComplexNumber(2.0, 3.0), 2), or 2 * (2.0 + 3.0im), and the order of operations (+ before *??) has gone to hell.
I'm also marginally concerned that there may be a valid OpenQASM 3 statement that requires an arbitrary number of tokens of lookahead to parse here, but I'm not certain at all.  ANTLR can handle that (slowly), but others who have more performant parsers (e.g. a Bison-based LALR(1)) might not be able to support it, for no real benefit.
If anything, with the current spec, I think the AST node for this type of expression should be along the lines of
but honestly I think we'd be best completely revisiting complex numbers in the types group before.  I'm actually in favour of having an imaginary literal lexeme similar to that implied by the AST node in this PR, if we can decide on a rock solid set of allowed implicit casting rules - I'm not certain if we will manage that, though.
Originally posted by @jakelishman in #301 (comment)
