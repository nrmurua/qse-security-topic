It would be cool to have a "sampler" that does not do sampling but gives access to the problem that is generated by the composite.
I'm thinking something like
and such.
How about something like
This way we're not breaking the API.
yeah that looks good
Maybe this should be a composite? And we should have a "null" sampler that always just returns an empty sampleset? Those two features seem useful but conceptually separate.
I don't know how that would work
Object names not final obviously:
TrackingComposite
Would add to info the inputs and outputs received by the composite
NullSampler
Would always just return an empy sample set
hmm.. ok.. any reason why you want to divide into two?
I like the tracking composite, but how would nesting work?
yeah... that's why i was suggesting a sampler.
another option, which i believe ppl are gonna hate, is every composite now adds its name to bqms info field.
@conta877 Just because I like things to do just one thing. And I can imagine wanting just one of the two uses without the other.
@randomir That's a good point, something like
seems simple/obvious. Otherwise the outermost?
I like tag
Hm. Sure, tags could work. They are a bit too explicit/verbose for my taste. I was imagining some kind of info dicts nesting, but that’s probably too magical..
There’s also the option from Hybrid / hybrid.TrackMin - keep debugging info in the object (composite here), not the result.
I think keeping them in the object makes sense. It's slightly less convenient for deeply-nested composed samplers but it keeps things clean.
