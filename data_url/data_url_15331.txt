Defining and using custom gates is common practice when using Qiskit. Unfortunately, QPY serialization does not support this use case. For example, there is no way to tell QPY how to preserve custom gate attributes:
This issue can be addressed by adopting the JSON serialization framework from Qiskit Experiments.
First I think it's important to level set here. QPY (and qiskit itself) is not a general python object serialization library. QPY was explicitly defined not to support arbitrary object serialization as it's a huge security issue to import arbitrary code during deserialization. This is one of the many reasons pickle isn't a viable solution for the places QPY is typically used. There isn't a path to supporting a custom attribute on a Gate (or any Instruction/Operation) by design as it's not actually viable given the guarantees we make about QPY. These same reasoning though is why the "JSON serialization framework from Qiskit Experiments" does not actually solve the problem here. You don't know what a is, or how it's used by MyGate without the code for MyGate. Similarly, how do you know that the serialized MyGate in the payload isn't the MyGate from my local code:
the second you need the code for MyGate you've just recreated pickle (at least partially) which embeds the python code for reconstructing an object with the serialized data and you should just be using that (or honestly just saving the python file). We can not assert anything about the code outside of qiskt itself (even if it's downstream code built solely using calls in qiskit). What the json module in experiments gets you is an easier way to add objects in experiments to the default serialization path for the library. This is important for experiments since a large part of the purpose of the tool is storing results with the experimental parameters. What this doesn't really provide you is a viable solution for arbitrary object serialization (which is what you're asking for). While at first it might seem that having dunder methods with serialization and deserialization hook points solve this problem in practice they don't because of the issues I outlined above. The only case this would work is if the serialization and desieralization environment are identical which isn't ever a guarantee we can make in Qiskit.
That being said we have talked about having similar hook points for qpy before but they would be limited to qiskit objects only and would not solve this use case (to decentralize the special casing of specific objects out of qiskit.qpy)
In this specific case QPY does the best effort thing and creates a Gate object with the name attribute and any other standard attributes for Gate (e.g. definition, etc). But it doesn't recreate MyGate because it doesn't know what MyGate is or any of it's custom attributes since the deserializer can't ever reliably know what MyGate is from the context of just the QPY data it receives. I'm closing this issue as it's not something we can change.
While at first it might seem that having dunder methods with serialization and deserialization hook points solve this problem in practice they don't because of the issues I outlined above.
I believe that the dunder methods do in fact solve this problem in practice.
The first issue you raised is that deserializing arbitrary objects is a security risk. I don't think this is a significant issue in practice because the typical user will be deserializing objects that they trust. In the example I gave above, the user is defining their own custom gate, so the code is trusted. I understand that QPY may have security requirements, but that doesn't preclude introducing a framework separate from QPY.
The other issue you raised is that if we're creating a framework that introduces arbitrary code execution during deserialization then we might as well use pickle. This point overlooks the advantages that JSON has over pickle, such as human readability and interoperability outside of Python. JSON is also more forgiving if the environment changes in a way that breaks the serialization because you can always read the file as a normal JSON file.
