StepResult is a very generic interface which is used for simulating any sized system, but bloch vector is specialized to a single qubit.  If one really needs it one can just do cirq.bloch_vector_from_state_vector(step_result.state()).
I can work on this.
@dabacon, do you also want it removed from SimulationTrialResult (same argument about system size can also be made here as far as I can tell)?
I would prefer to keep this method. Yes it's a small convenience method, but it is much easier to discover when using an IDE with autocompletion.
I'm not sure where the line in convenience vs redundancy should be, though.
Yes, everything that you can do on a state could end up here.  I think it will just make this entire class nearly unreadable in the end.  If the argument is for just using autocomplete, a better pattern would be to use an abstract class for objects that have wave functions and stuff everything there.  The other is to create a state object that exposes these.  I don't think putting this all in the StepResult is correct because a "bloch vector" is not something that is a result of a step
OK, we talked about this offline and think that probably the best thing here is that there should be an abstract class that has methods that operate on a state.  So any object that has a state we can add this interface as a class to inherit from.  This allows these methods to be on the class, but doesn't pollute this class.
So basically put all methods currently in cirq/sim/wave_function.py into an abstract class? Do we also want to keep the static methods there, or is it enough with the new class?
