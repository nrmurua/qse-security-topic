Now we have #define OQS_SUCCESS 1 and  #define OQS_ERROR 0. This is not the usual C convention, where 0 is used for success. Moreover, all over the code, there are hard-coded return 1; or return 0; instead of using the corresponding macros. I propose to change it, and have #define OQS_SUCCESS 0 and #define OQS_ERROR -1, and perhaps a typedef OQS_STATUS int or something similar, so it's clear from the function signature whether it returns any int or a status code. Also we should change all hard-coded return 1; or return 0; with corresponding return OQS_SUCCESS/OQS_ERROR, respectively. I created the branch https://github.com/open-quantum-safe/liboqs/tree/vsoftco_refactor_OQS_SUCCESS for this.
If C had bool defined you would be using that to describe true/false return values, and so it should reflect that, as it facilitates the most natural flow of language i.e. if (myfunc()) or while(foo())
If returning some specific error code from an enumeration, then use zero for success, but that is not the case described.
To cite convention, is to say 'because so many bad programmers with a bad style have done it this way for so long, we are stuck with it now', not a very compelling argument.
Which arrangement should be used, depends largely on who you ask, and yes, a lot of older codes do use 0/-1, but as an api designer, I consider this to be idiomatically incorrect, because it does not represent its true intent; an expression of a boolean conditional, which means you have to interpret the result, which means more code, more confusion, more mistakes...
I do agree with you on hard coded returns though, there should only be one return statement in a function, and it should represent an actual evaluation of some kind, or the api should be changed to void.
I'd totally return something like an enum class in C++11 (if something like that was possible in C). I agree with you that idiomatically success should be non-zero, however almost everywhere error codes are non-zero (including exit codes), so which way is better is debatable. I will initially modify all the hard coded returns in the code, then once we decide on the OQS_SUCCESS/ERROR values it'll take 1 minute to change to whatever everyone agrees.
That is a good approach. I always use enumerations for this sort of thing, that way if at some point the return codes are expanded to include actual error values, it becomes a simple thing to adjust in the global scope. I guess it comes down to what the return values actually are; if they are boolean, then make them that way, if however, it is expanded to include actual error codes, then 0 for success is preferable.
John I also liked the idea that functions should return true/false for being able to do if (myfunc()) like you suggest, which is why I originally went with 1 and 0 in the API.  But indeed it is not C convention (to the extent that there can be said to be a convention for anything in C), and moreover it is not how the NIST/SUPERCOP API handles returns.  For now I think getting OQS_SUCCESS/ERROR values everywhere is a good start, and we can decide on the actual values later.
I would add one thing to the conversation, and that is I think this comes down to documentation, and not just comments or external docs, but in how the api is phrased. For example, you could use OQS_STATUS_SUCCESS for boolean, or OQS_ERROR_AUTHFAIL as a type of error message format.
That and demonstrate correct usage in the tests and examples.
@dstebila As for NIST/SUPERCOP, that brings me around to a conversation we had earlier; SP800-185 3.2 states if S=N=0 cSHAKE output should be SHAKE. That would require adding a branch to the code that toggles the domain code from cSHAKE(0x04) to SHAKE(0x1F), all so you can test an invalid input.. does that make sense to you? I guess the point is, just because NIST does it, doesn't mean it is correct.
Closed by #219.  Pulling out @Steppenwolfe65's comment into new issue #220.
