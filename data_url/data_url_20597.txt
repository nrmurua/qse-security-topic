open-quantum-safe/oqs-provider#23 detected that one algorithm's claimed NIST level was incorrect. This was not detected earlier also because the OpenSSL generate.yml can deviate from claimed NIST levels in liboqs. This issue to suggest a cross-validation of generate.yml with claimed liboqs NIST levels.
One a bit surprising detail is that oqs_kem_default isn't defined in generate.yml (while oqs_sig_default is), and it is instead added with custom template code. I'm not sure if this is necessary for OSSL111. This might have to be considered in cross-validating the NIST level for the default algorithm.
In open-quantum-safe/oqs-provider#24, the default kem is instead added as an extra yml-entry. It could make sense to take this over here as well.
One a bit surprising detail is that oqs_kem_default isn't defined in generate.yml (while oqs_sig_default is), and it is instead added with custom template code. I'm not sure if this is necessary for OSSL111.
Interesting and true observation. I can't see a reason for this either. @xvzcf : Do you recall why this is so?
#316 indeed thus "only" checks all other algs -- and could be extended to actually generate the "[bits_]security" levels instead of just validating them -- again, of course only those in generate.yml -- thus apparently currently excluding oqs_kem_default.
Interesting and true observation. I can't see a reason for this either. @xvzcf : Do you recall why this is so?
There isn't custom templating code for the OQS_KEM_DEFAULT algorithms, they're just present outside the templating system.
As for why this is so, I don't think there's a good reason, and the BoringSSL and OpenSSH v8 generate.ymls also list the OQS_KEM_DEFAULT and OQS_SIG_DEFAULT variants. Bringing OQS_KEM_DEFAULT into the templating system might have just been a TODO item I never got to.
Maybe off track, but is there a need anymore for OQS_KEM_DEFAULT and OQS_SIG_DEFAULT?  When we had many more algorithms, it was a way of configuring at compile time which one of several algorithms was to be used, especially when that algorithm was not explicitly supported in our OpenSSL fork.  Now with the reduced number of algorithms and OpenSSL templating, I don't think I would create this if I was starting from scratch. So that makes it a candidate for removal, unless it is being used signficantly.
So that makes it a candidate for removal, unless it is being used signficantly.
How do we find out if anyone is using this? Personally, I also don't like the concept of having one fixed name/ID for something that completely changes (code/implementation) between builds -- and thus would support removing it.
