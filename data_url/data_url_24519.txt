The following pulse (sample rate = 24.41 kHz):
where qupulse_inst.awg1.make_properly_quantized_time(time) finds the next largest whole ns to comply with the 16-sample quantization and sample.scale_and_rename_pulse_template() just scales the pulse should result in the following:

But it actually plays back this:

Note the plateau at the end of the pulse.
After a lot of playing around I am now sure that something goes wrong in the qupulse waveform generation whenever nothing significant does not happen before or after the relevant pulse segment. I.e. the pulse gets corrupted at the first and last significant pulse segment.
This can be seen by the fact that both extending the final jump operation as well as the marker yields the following:



This is especially visible when concatenating a pulse manually. Note that this issue also appears at the start of the pulse if I do not include a significant hold there:


Also note that the linear ramps are always as long as they should be, it just seems like the waveform "catches up" with the ramp in the beginning or the jump to 0 in the end.
The Problem also gets worse for lower sample rates even though the sample rate is still much larger than what would be required for the pulse.
At 12.2 kHz:

At 97.65 kHz:

Changing the timescale of the pulse to 1ms at 24.41 kHz:

This causes a slower ramp for the first triangle but otherwise looks better.

At 48.82 kHz it looks better:

And at 390.62 kHz it is completely broken:

Interestingly at 292.96 kHz and 4.68 MHz (Base frequency 2.4 GHz) it looks perfect:


The timescale = 1s pulse looks also fine at 292.96 kHz (2.4 GHz base)

How do the waveform files that get generated by this look like?
The hdawg driver should create one big waveform and write this to a textfile in pathlib.Path(self.api_session.awgModule().getString('directory'), 'awg', 'waves').
