Some statements from CONTRIBUTING.md don't seem to be up-to-date any more:
For now, we only accept pure, portable C code.
--> Should this be updated? Maybe with guidelines/goals regarding 'optimised' (ASM) code (incl. the structure of META.yml -- e.g., can one rely on the "example" structure defined by kyber's META.yml?). Any differences for (how to) add(ing) 'common' code (e.g., seedexpander (#292) or optimised variants of shared code, e.g., https://github.com/XKCP/XKCP)? Or are such optimizations going beyond the 'clean' in 'PQClean'?
Those documents, including the README, could probably use a do-over indeed.
The /common code should probably be limited to the stuff that was specified part of the NIST API. We've not been concerning ourselves with optimised variants there much â€“ the main reason for the AVX2 Keccak files existing in /common was that it was the quickest way I could get 4xKeccak working and it was only necessary for AVX2 code.
Fitting in optimised (AVX2) code has been a bit of a struggle, admittedly. On the one hand, it's nice to have these optimised implementations if you consume PQClean somehow. On the other hand, inherently we quickly run into compatibility issues with supported platforms, compilers and operating systems, especially when assembly code is concerned. I've also had to work around the "no ifdefs" restriction to get some code to work....
Allowing assembly implementations is perhaps even something that we should reconsider. The SPHINCS+ implementations don't use assembly, and this greatly reduces many of the headaches in portability. But at the same time, it's nice to verify that these implementations agree on the same testvectors...
Thanks for the background. I personally am glad and thankful to have as few as possible sets of PQ implementations (and interfaces, build environments, test vector assurances) to understand/utilize. The optimised variants incl. their META.yml were very helpful integrating Crystals (and any other algorithm with such optimisations). I'd otherwise have been forced to use upstream code, deal with its idiosyncrasies -- all not very appealing. So, for whatever it's worth, if I were you I'd keep accepting optimised implementations -- but provide the same level of integration guidance you have for the clean code.
Regarding shared code, well, I'm also not certain yet: One the one hand, it'd be good to save size if not every algorithm comes with its own, say Keccak, code. But on the other hand, shared code creates an integration overhead (testing as well as everyone agreeing on an API: Not just "upstream" algorithm providers but also "downstream" users (like liboqs). That said, what's the reason for not sharing/using as-is such "common" code between PQClean and OpenQuantumSafe to "amortise" such cost? Probably a question also for @dstebila .
Regarding shared code, well, I'm also not certain yet: One the one hand, it'd be good to save size if not every algorithm comes with its own, say Keccak, code. But on the other hand, shared code creates an integration overhead (testing as well as everyone agreeing on an API: Not just "upstream" algorithm providers but also "downstream" users (like liboqs). That said, what's the reason for not sharing/using as-is such "common" code between PQClean and OpenQuantumSafe to "amortise" such cost? Probably a question also for @dstebila .
Generally I'm not opposed.  However the AES and SHA implementations in PQClean are really there just so everything can be compiled and tested, and are not intended to be performant.  For liboqs, we do want to have moderately performance AES and SHA implementations.
Generally I'm not opposed. However the AES and SHA implementations in PQClean are really there just so everything can be compiled and tested, and are not intended to be performant. For liboqs, we do want to have moderately performance AES and SHA implementations.
What then would speak against PQClean taking the liboqs AES&SHA "common" code? Licenses? The ASM/AVX2 etc. code in there? The latter shouldn't be a problem if/as ASM PQ code is already in PQClean .... But then again, I do not know what the intended separation/differentiation between PQClean and liboqs are/should be. I'm just no fan of doing things (common code in this case) twice...
The simplest answer is that we had to get code for that in OQS before PQClean existed.
What then would speak against PQClean taking the liboqs AES&SHA "common" code? Licenses? The ASM/AVX2 etc. code in there?
One of the original ideas in PQClean was to allow to build everything with at most the following
The more logic we need to select underlying implementations, the further we deviate from that.  We'd probably also need a more advanced build system. And going in that direction quickly brings us closer and closer to PQClean being a library itself, which is defined to be a non-goal...
Thanks for the background, @dstebila @thomwiggers:
The simplest answer is that we had to get code for that in OQS before PQClean existed.
Then I understand why not all PQ code in liboqs comes/builds "via" PQClean.
One of the original ideas in PQClean was to allow to build everything with at most the following [...]
If that'd remain a hard goal then I don't see how the optimised variants can be built (well, they can't as soon as they have assembly files and need to switch on CPU feature flags) i.e., they probably don't belong in PQClean... Not having them here of course would mean that liboqs would have to integrate from each upstream separately... :-(
So I won't comment any more having received helpful answers to my questions. Thanks again. I shall remain curious which way things evolve/get documented...
