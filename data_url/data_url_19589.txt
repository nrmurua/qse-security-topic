Hi,
I am using the package to decode an unrotated SC. I used the function of "decode_to_matched_dets_dict" to get the minimum weight perfect match, which shows the pairs of detectors. However, if I wanted to know what is the shortest path between a pair of detectors to get the data qubits that the path passing through, what would be the function suggested? I have searched the document and found nothing related though. I am presuming maybe I should write it on my own?
Thanks!
There are a few approaches:
Hope this helps!
Hi Oscar,
Thank you so much for the reply. It's really helpful, particularly the third point.
1.Regarding the first point, maybe I have a misunderstanding here. I am using stim and pymatching together. It works perfectly if the target is to predict the logical observable. But I am expecting to get the detailed errors as what qubits might have flipped.
2. For the second point, I have run matching.decode over a stim circuit, but the result given by the function just reflects the logical observable. I guess the reason is that in the course of building the matching graph, fault_ids are not really specified except for the logical one.
Ah I see, so you're interested in inspecting which specific error mechanisms have occurred. I agree that you can't get that information from matching.decode when the decoder is configured to use logical observables as fault_ids. One other thing you can do is use the stim detector error model to construct a sparse check matrix and numpy array of priors. You can then sample from the priors yourself in numpy, and when you use the check matrix and log ratio of the priors to construct the pymatching.Matching, each column of the check matrix is assigned a fault id. So with this hack you can inspect what was sampled and decoded (in the basis of detectors, rather than circuit elements). This won't be as fast as using stim for simulation, though.
Ah I see, so you're interested in inspecting which specific error mechanisms have occurred. I agree that you can't get that information from matching.decode when the decoder is configured to use logical observables as fault_ids. One other thing you can do is use the stim detector error model to construct a sparse check matrix and numpy array of priors. You can then sample from the priors yourself in numpy, and when you use the check matrix and log ratio of the priors to construct the pymatching.Matching, each column of the check matrix is assigned a fault id. So with this hack you can inspect what was sampled and decoded (in the basis of detectors, rather than circuit elements). This won't be as fast as using stim for simulation, though.
I can roughly capture the idea. But could you shed more lights on "priors"? I don't what the meaning of the word in the context.
By priors I just mean the probabilities of the error mechanisms given knowledge of the error model, but not the syndrome. E.g. for this detector error model (DEM):
by a prior for an error mechanism I'm referring to the error probability assigned to it in the DEM. If you assign an index to each error mechanism in the DEM (e.g. its row number), you can store the priors as a numpy array, and have a check matrix H representing detectors (e.g. each column is an error mechanism, each row is a detector, H[i,j]=1 iff error mechanism j flips detector i). Likewise, you can construct a logical observables matrix L (where L[i,j]=1 iff error mechanism j flips observable i). You should use scipy.sparse.csc_matrix not dense, but e.g. here it would be:
You can construct a pymatching.Matching using check matrix H with weights log((1-priors)/priors). You can sample bitstrings from the priors distribution, and check for logical errors using L.
(But I'm not sure what you're trying to do precisely, so if you don't care about speed then maybe decode_to_edges_array already does all you need)
(But I'm not sure what you're trying to do precisely, so if you don't care about speed then maybe decode_to_edges_array already does all you need)
Yah, decode_to_edges_array is indeed enough for my case since speed doesn't bother me. But I would love to investigate the check-matrix idea if the performance becomes an issue in the future. Thanks for all the helps and explanation Oscar. I will leave you to decide if the issue should be closed or not, although I've got what I am looking for.
Ok great, I'll close the issue in that case, since I already have an open issue to add more documentation
