This is my proposal to implement #942 using Displays.
MeasurementDisplay is like a measurement gate, but it's allowed to perform operations before measuring. It also knows the number of repetitions that should be performed. Since it's a Display, it's a no-op as far as the rest of the Circuit is concerned (see #982). The most important example would be PauliStringMeasurementDisplay. This would actually be an Operation and not a Gate. The number of repetitions could be a Symbol, so we might want ParamResolver to be able to resolve things into ints (rather than only floats).
We could add a measure_displays method to the SimulatesSamples simulator interface, or define a SimulatesMeasurementDisplays interface. In any case, it needs to translate to the Quantum Engine API. The results are returned in a TrialResult
The measurements attribute of TrialResult could have keys that refer to MeasurementDisplays instead of MeasurementGates. Since MeasurementDisplays can have different numbers of repetitions, we'd need to figure out something to do with the repetitions attribute of TrialResult (get rid of it, maybe?).
I wonder about putting repetitions on the display.  If you have a circuit with two displays and different repetitions how does it know which one to use?
Displays should act completely independently of each other, I think. The questions of "which repetition count" dominates shouldn't even come up, because they are populated by entirely separate runs (otherwise you could see spurious correlations between displays when sampling).
Of course, if we can prove that a given circuit is of a class where two displays can be computed simultaneously, then we could do that behind the scenes. We could perhaps have an option to allow correlated sampling...?
Obsoleted by #1215
