Circuit with an identity gate fails to transpile, when we want to translate it to another universal gate set. In this case I wanted to convert a larger circuit to the universal basis ['rx', 'ry', 'rz', 'p', 'cx'], and this should be possible thanks to the universality of this gate set as mentioned on Wikipedia with reference to Williams, Colin P. (2011), Williams, Colin P. (ed.), "Quantum Gates".
Run this snippet of code with the simplest circuit containing an identity gate:
It raises the error: QiskitError: "Cannot unroll the circuit to the given basis, ['rx', 'ry', 'rz', 'p', 'cx']. Instruction id not found in equivalence library and no rule found to expand." It comes form the UnrollCustomDefinitions transformation pass.
This circuit transpilation works if we remove the identity; I double-check this also with an arbitrary larger circuit including and removing the identity operation. Another trivial way to make it work is to avoid the translation to the new universal set, thus by setting basis_gate=None, but this is probably not what we want, since a user should be able to transpile to the preferred universal gate set of her quantum computer.
I expected the circuit to transpile to the desired universal gate set without error(s), even if the circuit contains an identity gate (for whatever reason).
As a fix, we could remove all the identity gates before this UnrollCustomDefinitions pass, so that it doesn't fail in the conversion. This should be possible since the identity gate doesn't change the qubit state, behaving like a no operation (noop). Maybe we can add another basis pass which does exactly this.
(Orthogonal to this suggestion, I am wondering if this problem is the tip of a larger problem, since there is at least another issue ( #7393 ) that is somehow related to both the id and unroller.)
This is because id in Terra isn't actually an identity gate for legacy reasons, it (rather unintuitively) represents a delay cycle.  Both #7146 and #7403 would already fix this, but we can't merge them yet, because we still need to support the legacy behaviour until it's completely gone from our backends.  @kdk knows more about when this will be.
I'll close this as effectively a duplicate of known issues for tracking purposes, but we will implement a fix as soon as we can do it without breaking API stability.
