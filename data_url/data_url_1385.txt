There are lots of things that can produce a state vector. Integers, ProductState, QuantumState, circuits (and thereby gates and operations), StepResults, TrialResults, ActOnArgs, CliffordTableaux, and others. Each of these have different ways of getting at the state vector. It would be nice if we could just do cirq.state_vector(x: Any), pass any of these things in (with optional kwargs) and have it return the state vector. The implementation would look a lot like to_valid_state_vector but with additional support for checking for dunder methods. And of course each of the custom things above things would have to implement the dunder.
As a result of this, we could abandon the relatively ad-hoc QUANTUM_STATE_LIKE and STATE_VECTOR_LIKE unions as discussed in #4582, This would free up qis functions like fidelity and von_neumann_entropy to accept Any arguments instead of QUANTUM_STATE_LIKE, and avoid the need to handle each instance of the union independently, but still allow them to handle specific types independently as desired. (Open question -- does that then cause confusion -- does fidelity(circuit1, circuit2) make sense?)
@viathor @mpharrigan
Obviously same thing for density_matrix.
I think it's important that we distinguish between the current STATE_VECTOR_LIKE types, which can produce a state vector in polynomial time, and the broader class of objects which can produce a state vector in an arbitrary amount of time. Accidentally passing a large circuit as a state vector and OOMing your device isn't a good user experience.
Not worth it at this point. Will reopen if the qis library gets some love.
