In BackendV1, there is a dictionary of settings in BackendV1.configuration().timing_constraints. transpile accepts a timing_constraints option that works with this dictionary. With BackendV2, the entries that were in timing_constraints are in BackendV2.target as attributes. With BackendV1, to change a timing constraint, code would get  BackendV1.configuration().timing_constraints, modify the value in the dictionary, and pass the dictionary to transpile. With BackendV2, code needs to pull the individual attributes from Target into a dictionary, modify the value, and then pass the dictionary to transpile.
The part that seems awkward to me with V2 is that code needs to know all of the timing constraints and where to pull them from whereas for V1 it can just pull timing_constraints and make its modification and keep all the other values as is. Are the timing constraint entries guaranteed to always be 'acquire_alignment', 'granularity', 'min_length', and 'pulse_alignment'? I noticed this in the context of Qiskit-Extensions/qiskit-experiments#881 where code was trying to set a timing constraint but because it was not setting all the timing constraints it was losing the values provided by the backend for other constraints. Maybe that example is a niche case though (it was a workaround for backends not reporting timing constraints; I think the workaround can be removed but otherwise the fix will require accessing all of the Target entries as described above) and really the user should not be modifying timing_constraints, leaving that for the transpiler to pull from the backend directly.
I think the workaround can be removed but otherwise the fix will require accessing all of the Target entries as described above) and really the user should not be modifying timing_constraints, leaving that for the transpiler to pull from the backend directly.
I agree with this. Timing constraints comes from how the hardware microarchitecture controls pulse sequence, thus an end user should not be able to modify. Current code is a temporal hack at the time when we first introduced this mechanism and provider code was not sync with it. Regarding the format, I think provider can tell custom constraints and we don't restrict format. For example, backend can report channel wide timing constraints. Since such custom format is not supported by Qiskit Transpiler, the provider must provide provider-specific transpile pass with the staged pass manager.
Thanks, @nkanazawa1989, I will close this then with the thought that a provider-specific transpile pass is the ultimate solution (and in the short term the user should not need to deal with these settings any more).
