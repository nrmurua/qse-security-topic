Is your feature request related to a use case or problem? Please describe.
I would like to accelerate simulation of Cirq circuits with evaluation on GPUs. I have tried using Cirq-Qulacs, but I believe production has ceased on that project, and I could not figure out how to get it to compile successfully. I also believe that qsim is developing a framework for this, but it is still in pre-release, and I have not been able to get that to compile successfully either. It is very important to my research that I be able to speed up circuit simulations significantly, and I believe GPU acceleration is the best way to do so. As such, my other idea to do so is to convert the circuits to a series of matrices representing each gate operation, which can then be multiplied together on a GPU very quickly using CUPY. I don't believe there is a way to do this already in Cirq (please let me know if there is).
Describe the solution you'd like
There is a method in Cirq which will convert a circuit to an equivalent unitary matrix (cirq.protocols.unitary). I assume this works by converting each gate operation in the circuit to it's equivalent unitary matrix representation, and then multiplying all of the matrices together. However, this method is very slow, because of the final step, multiplying all of the matrices together. If this final step could instead be evaluated on a GPU with CUPY, it would significantly speed up circuit simulations. As such, I would like a method which does the same thing as cirq.protocols.unitary except the last step, instead returning a list of each gate operation in the circuit, in order, represented as a unitary matrix. I believe this should be quite simple to implement based on the existing feature in Cirq.
What is the urgency from your perspective for this issue? Is it blocking important work?
P0 - this should land no later than a week
If you just need the list of unitaries corresponding to each operation in the circuit, you can do:
However, note that the size of each unitary matrix in the list could vary based on the number of qubits on which the underlying operation acts. So you won't be able to simply multiply all these matrices in naively.
If you need a single unitary matrix corresponding to each moment in the circuit such that all the matrices are of the same size and hence can easily be multiplied together, you can do the following:
A small example demonstrating the workflow is as follows:
Hi @as3232cornell ,  The preferred way to perform simulations for larger numbers of qubits is to use qsim.  Here is a guide to which simulator works best for different sizes and whether you want to incorporate noise or not https://quantumai.google/qsim/choose_hw
If you are stuck installing qsim, I would recommend posting an issue there describing what problems you are encountering when installing.
It would also be useful to know the number of qubits and depth of the circuit you want to simulate.
Looking a bit more at your request, a list of unitaries, one thing is that I think you would really like unitaries plus the qubits they act on.  The reason for this is that the unitary on all n qubits is 2^n by 2^n.  One can do this already as @tanujkhattar said:
