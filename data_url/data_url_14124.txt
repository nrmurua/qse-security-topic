gives
TypeError: unsupported operand type(s) for %: 'ParameterVectorElement' and 'int'
It is breaking
run above for a backend
It should work like a parameterized gate
No response
I tried stepping through the function. I haven't been able to pinpoint the cause, but these are the variable assignments.
This comes from the InstructionDurationCheck scheduling pass.
When the transpilation reaches:

It has to check whether the duration of the delay is supported by the backend. However, being parametrized, when it reaches the if instruction it fails since it tries to check if the duration (which is a parameter) modulo acquire_align and pulse_align is zero. This is where the error comes from, since we didn't assign any values to the parameter.
This is also the reason why for simulators it doesn't happen, since this pass doesn't happen for qasm_simulator.
One possible soution is to ignore Parameter gates in this pass:
The same for ParameterVector. Rescheduling will need to be done at a later time. I would like to work on this task if it's ok
Should I wait to be assigned in order to start a PR on this or should I submit a PR with my proposed solution?
I think a PR with a potential fix would be welcome.
@nonhermitian: what's your use-case for a parametrised delay post transpile?
It's easy to make the code not error, but it's rather less clear to me that this is something we should safely allow (i.e., should we instead just emit a better error message?).  The error is raised during scheduling, which is requested because the transpile call is for a backend.  However, scheduling has to ensure that delays / measures / gates / whatever all start on alignment points of the hardware, and that's not possible to do if one of the delays is parametric.  If the transpiler output an actual circuit here, it could give the false impression that one can do assign_parameters({t: ...}) on the output and get a runnable circuit.
If the intent is that this circuit shouldn't undergo scheduling, you can set scheduling_method="none" (string "none", not Python built-in None).
edit: @SoranaAurelia - it might be best to wait a little bit (sorry for the slow response on the issue), just so we can work out what the solution should look like.  It's not always the case that things that error should succeed; sometimes it's that they should just have a better error message.
I want to see if I can make doing many schedulings faster than it is today.
@jakelishman I totally understand that, I thought that maybe a transpiled circuit with a parametrized delay could be one use-case someone would want, and I didn't see a problem in having that and maybe including a warning when this situation is encountered as to not give the wrong impression that the circuit will be "runnable" as you stated, but maybe I should've expressed it better. I wasn't sure who else will look into this, that's why I also asked earlier of other solutions. But I do think you are right that maybe it's not a common feature someone would want, and maybe changing the message would be better in this case
Sorry, I forgot to loop back and comment on this after it was brought up in a developers' meeting last week.
My concern with the workflow here is that I think it'll be very difficult and error-prone for a user to do anything valid with the output of a circuit compiled with parametric scheduling, and Qiskit ParameterExpression cannot represent the alignment constraints that the backend gives.  For example, a circuit with a parametric delay on one qubit implies that its fully scheduled version has all qubits have a parametric delay on them, and we have to output a single circuit with a static unconditional expression for all delays (no if a < b { c } else { d } or things like that), but there are alignment and joint-measurement constraints that will affect all qubits.
In general I think it'd be better for one of the pulse / scheduler developers to comment more, especially about how this will fit with work like the lower-level pulse compiler in the works.  It's not clear to me that this workflow is something we should bend to make work immediately, though - I think that right now it would be very difficult for most users to do correctly, and if it's intended for specialist investigation in the short term, it'd be safer to do that by forking the scheduling pass and adding in the capabilities locally for experimentation.  It's a better user experience to fail safe than to silently return a circuit from transpile(x, backend) that in general won't be eligible to run on that backend.
So I think a few things are being confused together.  In the original post I am not doing any scheduling what so ever.  I think my point is that that should not fail.  It should work like it does a parameterized gate, which can also have impacts on scheduling for a given input angle.  I agree the scheduling part is different, and the goal with parameterized delays is to try to make that faster.  The above was just a test case to see what happens for parameterized delays.
Ah, sorry, I slightly misunderstood: the behaviour of transpile is that all scheduling is elided by default, unless there's a delay.  When compiling to a backend with scheduling constraints, the transpiler still needs to run a alignment pass to ensure that the delays are aligned for the hardware constraints, but that's not actually possible here, so I think it's correct in producing an error (though obviously it should be a better error than the current system).  I think the default behaviour probably should remain "fail safe", since the alternative is "silently decay if it's not possible to produce a valid output".
I was going to suggest that the correct course of action is to set scheduling_method="none", but that doesn't actually work - we must not have a way to set that at the moment.
Would a workable solution for you be for us to do both of:
In the meantime, you can work around this by dropping to a stage lower in the pipeline (not ideal, but it'll get you moving):
I believe current awkward implementation of scheduling is the result of some design error. The timing constraints is something a backend compiler must take care of. Here is some background story:
In a typical waveform generator setup, we have granularity that represents a number of sample that is loaded to DAC memory in parallel. Because of this hardware design, the scheduling clock should be integer multiple of the granularity (scheduling clock := granularity * sampling clock), otherwise instruction cannot be properly scheduled on the hardware. There is not explicit definition, but conventionally the Qiskit backend dt corresponds to the sampling clock, and if you provide the delay value in units of dt you must take care of this alignment. The benefit of using the sampling clock is that we can offer full AWG bandwidths to pulse users who deal with raw waveform samples, e.g. optimal control researchers. However, this requires Qiskit to be backend hardware aware. If a user violates this alignment constraints, the behavior of real backend is undefined. It could raise an error, or maybe runs your circuit with unexpected scheduling and returns nonsense results (IBM backend is latter case).
Considering the potential user percentage, I would recommend to ask backend providers to report scheduling clock, and drop timing constraints from our backend model. This allows circuit scheduler to drop validation and realignment subroutine, and delay parameterization can be enabled safely, as long as assigned number is positive integer.
(edit)
Scheduling on parameterized duration is still tough, even if we drop timing constraints. If we have multiple parameterized durations in a circuit, scheduled time t0 could become too complicated expression to handle. In the example case, you don't need scheduling at all and what @jakelishman suggests seems reasonable solution (and what I suggest allows you to drop automatic duration validation and transpile(qc, backend) works without the trick). On the other hand, if you really need scheduling, we need another solution.
Yeah, no the workaround works in this case.
