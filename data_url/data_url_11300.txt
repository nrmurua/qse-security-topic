As discussed at #232 , our current implementation of the Bravyi-Kitaev transform comes from arXiv:1701.07072, and this definition is actually different from the one given by Bravyi and Kitaev in arXiv:quant-ph/0003137, which is the same as the one in arXiv:1208.5986. Apparently this fact had gone unnoticed until that discussion so I thought we should discuss now whether or not we should change our implementation. If we want to implement both, then I'm asking which one should be our "canonical" one and be assigned the function name bravyi_kitaev.
The two transforms actually correspond to different variants of the Fenwick tree data structure; the one in arXiv:quant-ph/0003137 is also called a binary indexed tree and it is the one that is actually used in practice because it can be implemented efficiently as an implicit data structure (elements are stored in an array and parent-child relationships computed using bitwise operations on the indices of the array).
One reason to change our implementation is that the one from quant-ph/0003137 can be performed faster. That's because the parity and update sets can be computed from the mode index using arithmetic (actually, bitwise) operations, rather than actually traversing a tree data structure.
Another nice property about the binary indexed tree version is that the form of the transformed operators depends less on the number of modes. For instance, the annihilation operator a_5 looks the same whether the total number of modes is, 9, 10, ..., 15, and then at 16 (the next power of 2) just one more X operator gets attached. On the other hand, with the current implementation, a_5 looks different for all these different total number of modes.
Now that I think of it, if one of them gives slightly lower weight operators in the cases in which they differ, then we should probably go with that one. I haven't investigated that yet though. This should probably be the first thing to look into ...
@kevinsung  Operator weight depends on the structure of the tree, right ? (the width and depth or however it is actually called)  For a number of modes that is 2^integer, Fenwick and binary BK seem the same - I think when you are in between the 2^integer and 2^(integer-1) in the binary BK, you basically delete the upper part (I mean thepart closer to the root)  of the tree. This clips the update operators (the part that is X or Y).  I guess comparing the shape of the trees for non-integer power cases is going to be an answer.  I assume the binary trees are going to be wider and not as deep  (have more Zs and less Xs) then the Fenwick trees. So what is better, a broader or higher tree ?
Yes, a binary-indexed tree for non-powers of 2 can be thought of as taking the Fenwick tree from the next power of 2 and omitting the higher indices.
Ok when N is a power of 2 the weight of an annihilation operator is always exactly floor(log N) + 1. I believe that with the Fenwick tree version (currently implemented), it can never be smaller than this, but it can be strictly larger. I haven't proved this but here is an example from running it:
yields
For each pair in between the --------, the first one is the Fenwick (currently implemented) and the second is the binary indexed tree. As you can see the first one is sometimes longer than the second one (albeit only by one). Also apparent is how the indices of the second one stay uniform throughout, while for the first one they can change wildly.
I think this is enough reason to warrant switching implementations. The code is much simpler too; you can see a complete implementation here. There is no need for a separate file to contain the Fenwick tree data structure.
I like the original version. But I feel like the fenwick version is also useful in a pedagogical way.
We can maybe change the default openfermion implementation to the original version and add a fenwick version into binary codes?
I have verified numerically for all possible annihilation operators in systems with up to 1000 modes that the original Bravyi-Kitaev transform (arXiv:quant-ph/0003137) results in an equal or lower weight operator than the currently implemented one (from arXiv:1701.07072). In many cases the weight (or many-body locality) is less than half as much. It would be nice to have a proof of this but I don't think I'm going to spend much time on that now.
This is very interesting @kevinsung , thanks. This suggests we should probably implement the original one at some point.
No, there are only 2. The original one and Seeley one are the same. The Fenwick tree one is different, and that is the one we have implemented, but it is inferior for 4 reasons:
I already have an implementation of the original one so I can submit a PR for that shortly.
