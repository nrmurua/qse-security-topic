Add Readout Mitigator classes bases on the current code in ignis:
https://github.com/Qiskit/qiskit-ignis/tree/master/qiskit/ignis/mitigation
Add the following classes:
All classes should get as an input:
and return:
The input data format of the mitigator for now can be left up to the method rather than defined in the base class such as assuming an assignment matrix.
Probably the only thing the base class needs to define is the abstract methods for applying mitigation, which as you suggest is just two methods. quasi_probabilities and expectation_value, and for querying which qubits it is defined on (ie if it was a full A-matrix for qubits [0, 2, 4] you should only be able to apply mitigation to for counts coming from measurements on a subset of those qubits).
I think initially we should just focus on the single-qubit tensor product case as the default, and maybe also include the complete case as an option. One current issue to note with the ignis tensor product code is its not as scalable as it should be. IIRC it builds the full diagonal vector as a numpy array (so that limits number of qubits to <32), and it also converts count bitstrings into ints for indexing that vector, which breaks for 64-bit count strings due to Numpy not having bigints. In these cases we need the Callable or Dict way of specifying a diagonal and applying mitigation to avoid computing the full vector. The CTMP code would need a fair bit of work to move over since all the Numba code would need to be re-written in Cython, and updated to support >64 bits which currently have the same issues due to numpy/C use.
If the goal of a base class is for things like algorithms to be able to consume different mitigators internally, then I do not see the point of the most recent changes.  Namely the way of grabbing calibration data and applying the corrections need to be the same, as does the return type(s), or at least the way they get consumed does.  Otherwise each mitigator needs to be hard-coded as is done now.
It also feels odd to attach quasi_probs and expvals to the mitigator itself.  Basically the mitigator is the A-matrix.  The action of A gets applied to the noisy counts (essentially as Ax=b) returning the desired quasi_probs.  The A-matrix does not play a role in computing the expectation values, save for supplying some bound on uncertainties, and thus having it be a method of the mitigator just seems odd.
Having said all that, I have more or less had to forge ahead with the way M3 works given that work in this direction has not progressed far in the 3 months since this issue was brought up.  The design choices there do not align with the thinking presented here, so perhaps a happy medium is out of reach.  However, as someone who is not a big fan of the monolithic nature of the algorithms, I do not think this is the end of the world anyway as the mitigators should not be consumed in the manner they are today.  Instead, they should be used mainly as part of an expval routine and the like.
closing since #6485 is merged.
we will open separate PRs to handle:
