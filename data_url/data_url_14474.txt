With the introduction of BackendV2 and the Target class to model QPU constraints to the transpiler we now have more flexibility in expressing what a particular backend device supports. One of the new things we can now express is whether a backend works with multiqubit gates > 2q. In BackendV1/BaseBackend we could put these gates in the basis list but nothing would know about how they worked on the device or what qubits they applied to. With the target we can easily express how these operations work on a particular target device. However, the transpiler still has an implicit assumption that we're using at most 2 qubits for each gates. This is primarily a constraint of the layout and routing phase as all our algorithms are built using a graph object which can't represent connectivity for > 2 qubits at a time. To fully support backends that support operations that act on more than 2 qubits we'll need to revisit the preset pass managers and figure out how we handle this type of connectivity. I don't think we necessarily want to change things if the target has <= 2 qubit operations only, but we should be able to handle the case when we have > 2 qubit gates too.
This also came up recently as @IceKhan13 is working on a AWS Braket provider (see: qiskit-community/qiskit-braket-provider#10) and some of the backends support a native cswap gate.
As a first proof of concept, maybe we can look at supporting a layout/routing algorithm like the one described in https://arxiv.org/pdf/2102.08451.pdf , which unrolls to three qubit Toffoli gates prior to layout and routing, and then tries to choose the best Toffoli decomposition available for the given placement. That should help us surface anywhere in the transpiler we're assuming two-or-fewer qubit gates.
