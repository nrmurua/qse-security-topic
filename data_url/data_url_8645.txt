In the mcsolver function, it seems that (read from tutorial) the quantum jumps happen when a random number is generated larger than (1-dp), where dp is no jump probability. And this is the only option for jumping in the algorithm.
In theory, there is another strategy to choose jump--that is to use the concept of waiting time (see Dum and Zoller's PRA 45 (7), 1992 paper, for example). That is to say, we check the no jump time t to see if it is longer than the waiting time $\tau$: if t is longer, then a quantum jump happens; otherwise, there is no jump.
Could anyone make the mcsolver flexible enough to let users freely to choose which strategy to use in the algorithm? Each of these two strategies have different meanings and their own advantages: the jumping probability strategy is good for simulating measurement models; the waiting time is more efficient if one just wants to know the averaged result.
If currently none can implement this idea, could you provide a direction for me to write another mcsolver to use the counterpart strategy of jumping? Thanks.
Regards,
Qi
Hi Qi, thanks for your post.
If you want to work on this it would be a very welcome contribution, and we can assist you and guide you along the way.
However, I think it is difficult to write a general solver using waiting time distributions, because they usually require some analytical treatment and are therefore problem specific. As far as I know, if you don't have an analytical mean of finding the correct waiting time distribution you need to use the comparison of the decaying norm and a random number. In the paper by Dum et al that you refer to they also use this method, which is very similar to the one we use in mcsolve (the description you give in the first paragraph is not quite correct; we do use the decay of the wavefunction norm in the condition for when jumps occurs, like in Dum et al). See Fig. 1 in that paper for example.
However, in some problems the waiting time distribution can be obtained analytically, and then it could be beneficial to be able to specify this waiting time distribution for the mcsolver in some way. Is that the kind of feature you are asking for?
Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?
I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the array[1, 10, 11]? ...
At this stage, I have to resort to the original author of the code, and would like to hear your opinions and detailed guidelines. I will write some test codes in Matlab first in the coming weeks, if I have time. Thanks for your response.
Cheers,
Qi
Picking a new random number at each time step would be an expensive way to do the computation since each call to the random number generator is costly. One could pre-generate a large array of random numbers before hand, but there is no way to know if you generated enough since we are using an adaptive step size ODE method.
You are correct about the way mcsolve does its calculations.  The other array you are talking about [1,10,11] is an array that tells the solver about the time-depdendence of the Hamiltonian and/or collapse terms.  These arguments could be clearer, however since it is an internal thing, we have not bothered to mess with it.
Regards,
Paul
On May 3, 2014, at 9:24 AM, Qi notifications@github.com wrote:
Sorry, I made some mistakes in my previous post, and you are right on the paper. I think I can summarize the two MC simulation strategies into two kinds: one is that we generate a random number at each time step, and then compare it with the jumping probability (1-P(no jump)), and decide which jump to make using the jumping operators; the other one is that we generate a random number, and let it to be the no-jumping probability, and let the system evolve until it ends at the so-called waiting time by judging if the probability of no-jumping reaches the generated random number, and then decide which state to jump. My hope is that our mcsolve function can allow users to choose which strategy to employ in the simulation, as both of the strategies are valuable for different purposes, as I have claimed in my earlier thread. This is the feature I am looking for. Is that feasible and reasonable?
I read over the mcsolve code a little bit. From my understanding, the core algorithm of the MC simulation is in the ODE's single-trajectory definition part (_mc_alg_evolve...). Looks like the code is applying the second strategy I mentioned before. But I am not totally sure, as I am confused and got lost on many variables. Like, what does the RHS of the ODE mean? How comes the array[1, 10, 11]? ...
At this stage, I have to resort to the original author of the code, and would like to hear your opinions and detailed guidelines. I will write some test codes in Matlab first in the coming weeks, if I have time. Thanks for your response.
Cheers,
Qi
—
Reply to this email directly or view it on GitHub.
As this question has already been addressed, I am closing this issue.
Is there some paper or other material that discusses the relative merits of the two approaches beyond numerical effort, either drawing a random number in each time step as in Mølmer at al, J. Opt. Soc. Am. B  10  524  (1993) or by choosing a wait time as in the Dum and Zoller Paper? At first glance, they don't seem to be mathematically equivalent to me. @i2000s, you mention that the former method is more appropriate for measurement models. Do you have a reference that explains this in more detail, by any chance?
@goerz I think one of Mølmer's papers (maybe the one I have pointed out) addressed the equivalence of the two methods. Sorry, I don't have a definite paper to point out at this moment. I was actually organizing the Julia community to work on this direction (see JuliaQuantum) from scratch, and hence didn't follow up the efforts in the measurement simulation within QuTiP.
When I was writing my paper on continuous measurement (PRA, 93.023817), I came up the argument that the former method may be more appropriate for measurement models. This is because measurements have to happen in evenly spaced time steps determined by the detector's integrating time, so it is intuitive to use a random number to judge if on each measurement step the quantum jump will happen. There may be a way to use the second method to implement the same measurement simulation model, but I didn't think too much on it. In reality, I developed another more efficient method without actually evolving the density operator in my paper to simulate continuous measurement using a set of stochastic equations for squeezing thousands of atoms' state which has not been included in QuTiP yet. Sorry I don't have more useful reference that explains this point in more details at this moment. Good luck!
