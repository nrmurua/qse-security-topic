The logic for dispatching sublattices needs to be refactored to allow associated metadata to be written to the DB at the same time as the sublattice itself.
The dispatcher's current approach to handling sublattices is to send a _dispatch_sublattice job to the workflow_executor. This job performs an out-of-process ct.dispatch() on the sublattice workflow function, which in turn builds the sublattice transport graph and submits the sublattice to the dispatcher's /api/submit endpoint. This causes the dispatcher to write the received sublattice and its transport graph to the DB, call run_workflow asynchronously, and return the sublattice dispatch id to the execution of the parent lattice. Only at this point is the electron_id property is attached to the sublattice db record.
Problems with this approach
Although electron_id is already known when the sublattice is dispatched, it is only written to the DB some time afterwards. The sublattice and its parent lattice are unrelated in the DB during this window; the sublattice record would be irrecoverably orphaned if the execution is interrupted.
To support an upcoming UI feature (see DB enhancement proposal: add root_lattice_id fieldsÂ #1159) we will also need to add a root_lattice_dispatch_id property to each lattice and sublattice. Writing root_lattice_dispatch_id after the sublattice is dispatched will not work; the information might be needed before that write occurs.
Instead of calling /api/submit, the workflow_executor should simply return the built-out sublattice. The dispatcher can then recover the sublattice and its transport graph via the TransportableObject.json attribute and write the entire sublattice record atomically.
Acceptance criteria:
