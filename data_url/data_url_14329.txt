The base classes, reference implementations, and backend implementations of primitives do not take a session while qiskit-ibm-runtime version of primitives takes session to reduce latency. Here is a sample code of runtime estimator with session.
If users implement algorithms with the base class or reference impl of primitives, the code cannot take advantage of session when they replace the primitives with the runtime version. If users implement algorithms with runtime primitives, they need to adjust the code to test their implementation using the reference impl.
So, it would be useful to introduce a fake session and extend the base classes of primitives to take the fake session as an argument.
If Session is not part of the defined interface, a reference implementation must not add it.
This kind of thing keeps coming up every time the IBM provider does something - they are absolutely welcome to add extra behaviour that conforms to the interface, but Terra must implement the interface and only the interface, and Terra cannot use any provider-specific components. When we start breaking from this, we start either implicitly evolving the interface (which will then lead to this same issue being opened on Aer, and on BackendEstimator, and on the next implementer of primitives, etc etc), or we head down the QuantumInstance path.
Also, I don't actually see what the problem is here - assuming the user passes the primitive into the algorithm (which is what I thought happens?) there's nothing stopping them from using a session like this. You can't do a literal drop-in replacement in the creation code (because you need an extra with), but that's completely normal - the rest of the primitive usage is (should be) fully consistent and through the defined API.
Thank you for your comment, Jake. I ask @adekusar-drl to describe the details of this request.
If I recall correctly, the idea was exactly the same as Jake mentioned above - have a possibility to replace reference primitives with runtime ones without changing the code. While I agree that simplification of transition from one set of primitives to another can be handy, I admit that a fake session might not be the best way to go. Let me summon @woodsp-ibm. Initially, I guess, it was his pitch.
the rest of the primitive usage is (should be) fully consistent and through the defined API.
I should be clearer on this point: I mean that all the running of circuits on primitives is a defined part of the API, and so this code should look the same no matter what Estimator is used, but the actual constructor of an Estimator isn't part of the interface, so it's totally normal for it to look a bit different between implementations.
If there is meant to be a single defined construction method, then this needs formalising into an API that everyone can implement. For the Backend path, such a factory class is (approximately) Provider, as an example.  I personally don't see a need for a unified construction interface here (I think they generally don't reduce any complexity, they just move it to the construction of a different object), but I'm not the best person to design the UX of these interfaces.
I would agree that we shouldn't add a session to the base interfaces, or even reference implementations, if that's not needed for the execution. Adding sessions where it's not needed seems also confusing ("this is a simulator, why do I need a session which reserves a backend for me?") and in comparison to that, the overhead of adding a with Session when moving to the backend seems smaller ðŸ™‚ Plus, you'll anyways have to do some extra steps setting up the runtime service.
It had come up in a discussion about having tutorial/howto but using the real backend instead. I had mentioned we had done this in the past where we put code in the notebook that was commented out that the user could change simply enough to comment the simulator logic out and use this instead.
In this context the Session came up in that such switch may not be so easy if a Session really needs to be explicitly given where more than one primitive was involved and logic is best nested under some with Session construct then. I mentioned perhaps some dummy Session object - might alleviate that and facilitate users switching between say reference primitives and actual device. While that might facilitate the coding changes between running locally versus on IBM runtime it does seem rather a stretch for just some dummy session object that would do nothing, especially since Session is currently just a runtime aspect rather than perhaps something that could be defined abstractly more general for "running primitives together" e.g. shared transpiled circuits pool if same circuits were used by different primitives etc. Of course a Session could be opened and explicitly closed such as to avoid nesting etc - maybe that's not the ideal thing to show in a tutorial. In the end maybe the user just has more work to do with the code in going back and forth when experimenting say between local use and runtime. Figured it might be worth a discussion.
The idea of FakeSession was discussed when session was introduced in runtime. I said it should not be included in the base class and reference implementation. Constructors are not included in interfaces, and in fact, I think the options are often different. session is one of them.
Also, including session makes implementation difficult. This means higher hurdles for users to create third party primitives.
I don't think I would expect session to be mandatory, just optional the way things are today. Question is, like the session in runtime, would/could it be helpful to have the reference/Aer primitives support some session similarly to facilitate user moving between these and the runtime. You wouldn't have to use session any more than you do with the runtime - its just that it would be optional a similar same way such that all which would be needed, should you want/need to use a session would be switching it and the primitive imports and configuring them per whatever type you switched to.
