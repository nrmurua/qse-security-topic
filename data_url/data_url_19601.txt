Many thanks for this very useful program!
It would be helpful to add documentation for decoding non-CSS code errors.
In your paper (arXiv:2105.13082) you mention that this can be easily adapted to decode certain non-CSS codes. However, it is not immediately obvious to me how this can be achieved.
For CSS codes:
For non-CSS codes such as XZZX code or twisted surface code, the stabilizers and logical operators have mixed Pauli operators.
Do you have any suggestions on how to use PyMatching for these cases?
Hi @Svk1190. thanks very much for raising this. I highly recommend using Stim for error correction simulations. For example, you can use Stim to define the stabiliser measurement circuit for the XZZX surface code. Stim will then automatically construct the matching graph, and there is glue code you can find in the Stim getting started notebook which converts the Stim matching graph to a PyMatching matching graph for decoding. You can simulate full circuit-level noise models in Stim, but since the noise model is fully customisable you can also allow some (or all) of the gates in the measurement circuit to be noiseless if you want to assume a code capacity or phenomenological noise model, for example.
I've already reference Stim in the documentation ("usage" notebook), and it will be mentioned in the next version of the paper, however I also just mentioned it in the README to address your issue.
You don't need to use Stim to simulate the XZZX code of course, but it's what I'd recommend. If you want to construct it manually yourself, you need to make sure that each edge-like failure mechanism has an edge in the matching graph, and then use the "fault_ids" attribute of each edge to keep track of physical or logical frame changes that occur when the edge is flipped. An edge in the matching graph just represents a failure mechanism that flips one (or two) "detectors". It need not be a single-qubit X or Z error in a CSS code.
Hope this helps but let me know if there's anything else you'd like me to clarify.
