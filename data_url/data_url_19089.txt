There's some potential confusion about the Result object, see the comment on https://arxiv.org/abs/1902.11284v4 by @nathanshammah:
After Eq. (12) on page 10, it would be clearer to cite Result as qutip.Result, otherwise it seems the Results are a krotov class. I am a bit confused here, because looking at the code, there is a result.py file and a Result class defined therein, but running help(krotov.Result) prompts an error message; indeed help(opt_dynamics) tells it's a qutip.Result object from the mesolve dynamics.
The Result object returned by krotov.optimize_pulses is indeed a krotov object (krotov.result.Result, fully qualified), not a QuTiP object. The opt_dynamics from the example is a propagation result, not an optimiztion result. Both Objective.mesolve and Objective.propagate return a qutip.solver.Result instance for the result of a propagation, but this is entirely different from krotov.result.Result.
It seems like it might be a good idea to expose krotov.result.Result as krotov.Result, so that it shows up in the top-level API documentation (https://krotov.readthedocs.io/en/stable/API/krotov.html). It wasn't originally included at the top level because users should not instantiate a Result object manually, unlike the core classes/functions optimize_pulses, and Objective/gate_objectives/ensemble_objectives that are directly used when setting up objectives or running an optimization. However, as @nathanshammah's comment illustrates, while users wouldn't instantiate a Result, they nonetheless have to interact with the Result returned by optimize_pulses, so it'll probably avoid confusion if it's obvious where exactly this object comes from.
