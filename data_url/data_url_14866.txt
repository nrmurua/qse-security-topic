In the following code
The transpiler performs a mapping but only initial_layout is updated not the final_laytout is set to none
gives
This should give
see code above
This should give
In the pass_manager after choosing the initial_layout to the swap mapper set the final_layout and only update it after the final layout.
Personally I find the notation very confusing. It took me a while (actually I never did @nonhermitian explained it to me) to realize initial_layout is not the initial_layout but the initial_layout to the swap mapper and the final_layout is the layout  after the swap mapper (also no idea what 'input_qubit_mapping' is). Personally I think layout should just be the final one but if the user wants the history of how the layout changed then the should have meta data that correlates passes used with layout changes. But I think this would be a longer issue. My suggestion is to perform a quick update to set final_layout for this example and then in the future create an issue for what should be in the layout after the transpiler and how a user can get meta data that includes how the layout changes.
Actually None is equivalent to a trivial final layout. So it would be:
The final layout is mapping the qubit object in it's position in qc_ibm.qubits at the start of the circuit (after the initial layout) to the output position after routing; not the original circuit's position to the final position like the name implies. So if qc_ibm.layout.final_layout is None that means routing wasn't need and there is no output permutation caused by swap mapping. That being said we can update the default in the transpiler output to always populate final_layout even if routing doesn't run, that probably would make it easier for people as you don't need to explicitly handle the None case.
The input_qubit_mapping object attribute is the positions for the virtual qubit objects in the input circuit, that information is lost from the transpiler's output circuit and if we want to reverse the permutations caused by the transpiler we need to know where the qubits started in the input circuit. The best example to see how all these attributes are used is in Operator.from_circuit (
The TranspileLayout object is basically already what you're describing where each stage tracks the permutation it causes to the circuit (per pass is too fine grained as earlier permutations may be changed later in the pipeline). That being said the names are confusing (I also don't like the structures we use for this as I would just like arrays of integers), but it's an interface that people are relying on and while not super ergonomic it is workable. For me the path forward here is to improve the documentation, right now we have some description in: https://qiskit.org/documentation/stubs/qiskit.transpiler.TranspileLayout.html#qiskit.transpiler.TranspileLayout and I feel like we can improve that and also include better examples of how to work with it.
@mtreinish while I agree with all you views and why I just started an issue on this. I still think there is a bug as whatever pass is used in optimization permuted the qubits so in this case final_layout should be changed as it is different from the initial layout I used in the circuit. I agree that it is none as the assumption is initial_layout= final_layout in this case so this is my fix I am proposing that if a initial_layout is set before the swapper we copy that into final and if the swapper changes it great but this implies final is the same as the circuit I made which it is not. The transpiler picked a better set.
