This is a discussion topic is for an alternate signal representation that could replace the pulse representation in #109. There are many ideas in this document, some of which I believe is likely out of scope.
As discussed synchronously here is a proposal for a pulse-level representation based on signals and channels. A signal corresponds to the logical signal that must be applied and is mapped to a physical hardware resource which is a channel. It is hoped that this proposal is a more "natural" model for pulse-level control and is extendable to varied hardware in the future.
Note - Some of the syntax/language used within this proposal is different than in #109. I am not tied to any of this, I just found it helped with consistency.
A signal is a generalization of a concept of a pulse. A signal consists of a discrete time-dependent function s(t), ℤ->ℂ of max unit-norm and a clock-value (marker) t ∈ ℤ, t >= 0. In a sense, the time t is an "index" into the signal. The clock-value is propagated from its child signal with the initial value originating from the clock of the channel on which the signal is applied.
Openpulse should supply many types of builtin signal production operations such as
Signals may be composed via transformation functions to form new signals that are derived from the input parent signals. For example let new_signal = mix(envelope, wave); produces a new child signal that is a mixture of its parent envelope and carrier wave signals. Combining signals in this way forms a "signal tree", where signals are edges between signal production/transformation leaves. Within the signal programming model, signals are constructed(composed) from the bottom-up. The root of the tree is the root signal which is eventually supplied to a channel. The clock-value of a signal is propagated from its clock. Within this formalism, builtin signal-generation operations such as gaussian are source nodes that produce a signal (ie., no input edges).
A signal network has a correspondence with a traditional microwave schematic. Unlike qubit operations, signals are not linear and may be reused by splitting them, ie., they may be cloned. In practice, we allow reusing the named edged without requiring an explicit split operation.
A signal is defined by its ancestor signal production/transformation nodes, $s_n(t) = f_{n-1}(s_{n-1}^{(0)}(t), s_{n-1}^{(j)}(t)) = f_{n-1}(f_{n-1}^{(0)}(s_{n-2}^{(0)}, ...), ..., f_{n-2}^{j}(s_{n-2}^{(j)}, ...))$. This automatically gives many nice properties. For example, if all dependent signals are differentiable, so must be the final signal by the chain rule.
When outputting a signal on a channel the intermediate signals in the signal network are only useful insofar as to describe the output signal, this enables the compiler to restructure the signal network to better map to the available hardware. For example, if the hardware is capable of providing support for a carrier, it may natively represent a signal of the form mix(envelope, carrier), otherwise it may choose to rewrite the signal as a sidebanded envelope.
Signal production operations are signal sources that maintain clock relationships when coupled to an output channel.
Each takes as input one or more signals, applies a transformation, and produces a new signal. Note these do not mutate the input signals but are more akin to piping the signal into a transfer function. Signals are classical and may be copied without a problem. It is up to the compiler to choose how to implement the required transformations on hardware:
channels are the interface between the logical signal world and the physical world. They are representations of the IO ports of the device. Within a pulse program a channel's primary responsibility is to represent a "real-world clock" that can only advance through delay instructions, tx instructions for txchannels and rx for rxchannels as all signal operations are eventually defined with respect to channel clocks.
The base channel type is channel. There are two primary channel subtypes:
Signals are transmitted and received with the tx and rx functions on the txchannels and rxchannels respectively.
If channel production operations are signal sources, the transmit operation is the signal sink (ie., no output edges). Piping the signal out of the logical Openpulse domain into the physical hardware.
Note - Added so that document is self-contained, these are supported in the existing proposal already under different names.
The following operations are supported to fetch the configured channels for the specific device.
Alternatively, one could declare a channel of a given name directly and rely on the compiler to bind this to a physical channel on the device by the declared name.
Playing simultaneous pulses on two separate channels with a shared phase/frequency relationship. Similar to requirements for cross-resonance gate.
Here we use a kernel operation on the signal to discriminate the signal to a bit.
Note - faust is a functional programming language for DSP that has many interesting relevant concepts.
I like the proposal. Some minor comments:
Could the definition of mix add clarification that it multiplies? Current definition is
"mix(sig: signal, sig: signal) -> signal - Mix two input signals to produce a new signal."
Explore Praschandt's suggestion to send multiple things to TX/RX.
piecewise(sig0: signal, sig1: signal, time: length) -> signal - Output `sig
Looks like the sentence got cut off. I'm assuming it should say something like output sig0 followed by sig1
I like the way this is forcing me to think about things, so kudos! Just a couple of comment/questions for now:
The concept of a channel and signal feel useful to me -- the latter actually just being a carrier that holds a frequency, phase, and time. Like you said, the power is that a signal can be shared between channels to signify a true physics relationship, and the time advancement of a channel and signal seem straightforward during a transmit/receive -- both advance for the time requested.
But I'm not seeing the value of making the envelope a signal type. Why can't it be a separate type that a transmit/receive ingest? e.g.
The operation would be to perform complex multiplication between signal and envelope with the side-effect of advancing the time of channel and signal. You're basically there in your "Cross-resonance like gate" example, and I don't see where it's useful for an envelope to have a persistent time as it seems to just reset in your "Clocking example".
I'm also little unclear on the idea
Within the signal programming model, signals are constructed(composed) from the bottom-up. The root of the tree is the root signal which is eventually supplied to a channel. The clock-value of a signal is propagated from its clock.
Maybe I missed it or am misunderstanding, but  I'm nervous about the complexity. Why can't  the signal you're inputting into a transmit/receive/shift be the one and only signal that is advanced? Could you describe an example where this tree structure would be useful?
I like what I am reading. Conceptually I often think of a signal as envelop(t)*exp[i (w t+ phase)]. So this makes sense to me.
I definitely echo some of the comments that giving the user more of the DSP to hold and manipulate in their hands feels powerful. The one thing I kept getting caught up by though is reasoning about the timing of the in-place updates such as phase shifts or scaling e.g. carrier.phase += pi/2. By having declarative signals and by separating the timekeeper (now the channel) from the in-place frame actions (now the wave) it feels actions become non-local and harder to reason about particularly when sharing a carrier between channels. E.g. taking something similar to the clocking example:
Something similar happens with the signal tree and in-place operators. This issue would go away if we dropped in-place operations and made a copy every time but that solution seems to make the most common operation I'll want to do (frame shifts) annoying to have to generate to generate a new label every time.
A few other minor bits and bobs:
@caryan
Something similar happens with the signal tree and in-place operators. This issue would go away if we dropped in-place operations and made a copy every time but that solution seems to make the most common operation I'll want to do (frame shifts) annoying to have to generate to generate a new label every time.
This is exactly the path I went down as well and I echo your sentiments about the in-place updates. I'll try and put my thinking cap on and resolve this.
@psivaraj
I like the way this is forcing me to think about things, so kudos! Just a couple of comment/questions for now:
The concept of a channel and signal feel useful to me -- the latter actually just being a carrier that holds a frequency, phase, and time. Like you said, the power is that a signal can be shared between channels to signify a true physics relationship, and the time advancement of a channel and signal seem straightforward during a transmit/receive -- both advance for the time requested.
But I'm not seeing the value of making the envelope a signal type. Why can't it be a separate type that a transmit/receive ingest? e.g.
The operation would be to perform complex multiplication between signal and envelope with the side-effect of advancing the time of channel and signal. You're basically there in your "Cross-resonance like gate" example, and I don't see where it's useful for an envelope to have a persistent time as it seems to just reset in your "Clocking example".
I think as you say "The operation would be to perform complex multiplication between signal and envelope with the side-effect of advancing the time of channel and signal". It seems like special-casing a common case which may be fine. Perhaps a more gracefully solution would be to allow the equivalent of
transmit(ch, duration, *signals) so that transmit(ch, duration, envelope, carrier) and ``transmit(ch, duration, mix(evelope, carrier))` would be equivalent.
I'm also little unclear on the idea
Within the signal programming model, signals are constructed(composed) from the bottom-up. The root of the tree is the root signal which is eventually supplied to a channel. The clock-value of a signal is propagated from its clock.
Maybe I missed it or am misunderstanding, but  I'm nervous about the complexity. Why can't  the signal you're inputting into a transmit/receive/shift be the one and only signal that is advanced? Could you describe an example where this tree structure would be useful?
Perhaps the wording is unclear. Since the input signal is composed of other signals the clock value must be propagated to these "signal functions" to obtain their output value at the current top-level time. Pythonically this might be equivalent to the call tree below:
When transmit(ch, s3, duration) is called ch[t_curr], will emit [s3(t_curr), ..., s3(t_curr+duration-1)].
@eggerdj
I like what I am reading. Conceptually I often think of a signal as envelop(t)*exp[i (w t+ phase)]. So this makes sense to me.
Absolutely. The model above could be extended to the continuous domain such that t ∈ R, where there are no problems (besides that it doesn't represent the reality of signal generation). One of two strategies can be taken. Set dt to be the least common multiple of all sampling rates. This is the most simplistic approach but limits resolution. The other approach is to set dt to be some common factor of all relevant sampling rates. It would be up to the hardware to error at compilation if the desired signal could not be resolved (eg. some sample multiple like the restriction of 16 in our current systems). This is assuming the system is engineered sanely and this is feasible. Even if it is not there is likely some tolerance around timing alignment and this could be expressed with an attribute on a barrier barrier<"epsilon"=1e-10>(ch1, ch2).
The idea here is that it can enable the construction of more complicated piecewise signals, eg., a gaussian square I could define one gaussian pulse for the rise/fall and then shift it appropriately to sample the rise/fall components, combined with piecewise of a constant pulse to build the final signal.
It combines two signals to produce a new signal in which the sig1, t<= t_in, sig2, t>t_in. See the example above.
A phase is just equivalent to multiplication by a complex factor for all signal outputs, this might be better named as angle? I think its not straightforward what freq would be in this context.
There are two clocks and I think this could cause some confusion. The signal itself has a clock, which defines the t_i for the first pulse sample. There is also the clock for each channel, which defines where pulses are played relative to each other. It might help to clarify this somewhat. I do agree both may be useful.
There aren't two clocks. Clocks only exist on channels. A signal is merely a function accepting a clock (time) value from a channel to produce a value s(t), ℤ->ℂ as defined above.
Apologies. What I meant is that one might confuse the time index for the signal itself, that is t_i for s(t_i), with the time which represents the clock value for a given channel.
The description may lead to this confusion. You mention "signal's local clock" and the "target channel's clock". This makes is seem like there are two clocks. Instead, I think we should distinguish between the signal start index (or start time index) and the clock time on the channels.
It might even be easier to just think about a signal as a discrete set of samples, rather than possibly shifted or modified from some prior signal.
For instance, if you have
then sig0 is just the array [0.0, 1.0, 1.0].
It may be more confusing to think of it as shifted in time by two samples from env0.
After thinking on our discussion regarding mutating signals last week, I am not so sure a timestamp is required to mutate a signal. The timestamp is inherited the next time the signal is used. There are two concepts of order in the signal formalism.
1. Instruction ordering. This is how we synchronize instructions on channels and signals. Instruction execution is based on the order of the instructions in the program but does not imply a modification of the clock-value directly, these are determined by actions on channels.
2. Time ordering. Transmission instructions increment the time-value. This time value gets input from the
The only thing that matters from the perspective of updating a signal when played is the definition of said signal and the time-value it receives. An update to the signal is defined by its ordering, this is independent of the time it is made at.
edit -- After discussion the above is not quite right, the update time does matter, eg., in the case of a frequency update and more consideration must be given.
I think some additional clarification for the rxchannel could be beneficial. We should note that the output is a raw signal to which one can apply qasm3 kernel functions to get IQ data (what in today's open pulse is called kernel) and binary data (what in today's open pulse in called discriminate).
Additionally, one potential benefit of the rxchannel is it can track timing of data acquisition. But how can one delay on this channel? One option is barriers. But we may want to allow for some notion of adding a delay on an acquire channel without actually capturing a signal for this time.
Closing as this proposal is addressed in #184.
