As a result of a few changes in #546, some IonQ tests are failing in the recent nightly integration tests. These two separate changes (removal of non-compliant functions), when combined with pre-existing issue #512, are the cause.
The tests are failing because for the 4 problematic tests, the entire program is being optimized out, and we are essentially left with an empty program, like this:
The reason for the empty program is because the test programs are essentially performing no meaningful operations on the qubits, and the measurements are disabled (due #512), and the IonQ backend is throwing errors on these empty programs.
The bug can be reproduced locally in the dev image by performing the following steps (after substituting your IonQ key):
It's not entirely clear what the correct behavior of this empty program should be (again, it is empty due to #512 combined with the fact that everything has been optimized out), but it probably shouldn't throw a runtime error like this.
Yes, it is a regression. Last known working version was the version before #546, which was 60a1a9c.
No response
@bmhowe23 Could you make a suggestion for how to best address this?
There are a couple of cudaq functions that provide a convenient way to express common patters (sample, observe) that involve "adding" measurements. Sounds like we are not properly reflecting these measurements at the time when we optimize. (If we strip them for submission to IonQ, we should only do that right before the submission and after all optimizations have run.)
The tests that are failing have no meaningful operations and the compiler is correct to optimize everything out in my opinion. For example, the first iteration of load_value.cpp calls load_value(0), which performs no x operations (since 0 has no bits set), and since IONQ_TARGET is set, no mz operations are performed either. No operations remain, and that seems correct to me. The change that #546 introduced was to eliminate the non-compliant __quantum__rt__array_start_record_output and __quantum__rt__array_end_record_output functions from the resulting bitcode, so nothing is left in the function.
I believe we can choose from the following two options to resolve this issue. (I'm open to other ideas, too)
I prototyped option 2 above, and it appears that both Quantinuum and IonQ backends do not support the tail call void @__quantum__rt__initialize(i8* null) instruction that is specified in the Base Profile, so it doesn't seem like that option will work for us. In that case, I'd recommend option 1 above (disabling the tests).
