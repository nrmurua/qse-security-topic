Ignis APIs are currently too tied to physical qubits. For example to generate quantum_volume circuits, you have to say which physical qubits you want it for. Same with T1 experiment circuits.
However this is too limiting because it limits what the compiler can do (e.g. optimizing quantum volume circuits), and you have to think about which qubits you want to target. Instead, the API can just generate "model" circuits, and relegate the task of layout, routing etc. to the transpiler. If a user wants to enforce specific layouts, the transpiler has a mechanism for that.
I would disagree because ignis is about characterizing noise on specific physical qubits
My comment is about separation of responsibilities. I like how ignis separates circuit generation from fitting and filtering. In the same vain, i think circuit generation should be separated from how the circuits are run. Since terra already has mechanisms to specify which physical qubits to run a circuit on (using initial_layout=...), it seems like ignis can just generate the circuits and then the user selects the qubits (potentially multiple runs), without going back to circuit generation (which just generates the same circuit in many cases).
Along this same line, I am worried about how the transpiler actually handles QV circuits.  Even if you specify the initial_layout the circuits are widened to the full size of the device, and qubits outside of the layout can be used for swaps:
Qiskit/qiskit#2405 (comment)
This is different than what we actually do when running the QV circuits.  We compile to a given subgraph (hence the reduced cmap functionality), so there cannot be any swapping with outside qubits, and then run those on the actual device using the initial_layout which does not modify them since they match the topology.  So, depending on how your swap mapper decides to swap, the full width circuit may not actually be the correct QV circuit.
If you use an initial_layout that satisfies all the two-body interactions, then the mapper will not insert any swaps.
Even if it did, I don't understand why that wouldn't be a "correct" QV implementation? For QV we're interested in getting heavy outputs for a model circuit. How that is achieved is entirely up to the system as I understand it. Inserting extra swaps will be stupid, but not wrong.
I guess my question is, if you enlarge a circuit to the full size of the device, is it guaranteed that swaps will only involve those qubits specified in the initial layout?  Your comment on the extra qubits being space for swapping causes some concern. If the qv circuit is 5 qubits, but your swapper uses another qubit outside of this, then it is not valid.
I guess I am saying there could be a difference between transpiling a N width circuit on a subgraph of a device vs doing it on the full width of the device. In the latter case, the number of qubits used could be larger than the input circuit.
I was thinking about similar issues to the above recently, so Dave pointed me here.
Regarding "If the qv circuit is 5 qubits, but your swapper uses another qubit outside of this, then it is not valid." ... I was also bothered by this behavior initially when I discovered it, but after thinking some more, I concluded it probably should be valid after all.
For instance, say I have a ring of four qubits labeled 0,1,2,3, with 3 connecting back to 0, and say I can achieve QV = 2^4 on this device if I use that 3-0 connection, but without that connection I'd be stuck at QV = 2^3. Now say I add a perfect qubit labeled 4 that sits between 3 and 0, so I can still entangle 3-0 with the same exact fidelity as before. Are you saying that the quantum volume of qubits 0,1,2,3 in this modified device should be lower than in the original device even though all of the operation fidelities among those four qubits have remained the same?
just add to this if we can use ancillary qubits to make a better quantum volume then that is ok. I Agee with Ali on the volume and I agree with Ali on the circuit building should be device independent in ignis.
