Cirq has abstractions to represent individual qubits (eg: LineQid, GridQid, NamedQid etc.) and gates act on qubits to produce operations (often using op = gate.on(*qubits)). However, this approach doesn’t scale very well as we construct larger composite gates that can act on a larger number of qubits; many of which are logically a single grouped entity. For example, the ArithmeticGate is used to do arithmetic operations on integers represented by “registers” of qubits. Right now, a user needs to manually apply an arithmetic gate on a set of qubits and ensure that the implicit ordering of qubits is correct.
The goal of this design discussion is to make it easier to work with logical groups of qubits (i.e. qubit registers) throughout the Cirq stack.
A Register represents the a logical set of qubits that a gate is expected to act upon. Note that the Register doesn't actually store any qubits -- it just represents an expectation of a (potentially multi-dimensional) sequence of qubits and assigns a name to this logical group. Registers represents a collection of individual Register instances.
The Register and Registers classes together represent a more sophisticated way of specifying  _num_qubits_ for a gate in Cirq -- i.e. a cirq gate can expose a Registers object, that conveys the number of input wires to that gate along with a name and size attached to each input wire.
Introduce a new abstract base class GateWithRegisters, derived from cirq.Gate, that exposes a new interfaces to:
See the following snippet for a better understanding.
This makes it significantly easier for users to define new gates that act upon qubit registers and apply these gates on qubits to get back operations.
Once we have the GateWithRegisters infrastructure setup, we should add multi qubit versions of existing common gates like Multi Control Multi Target CNOT / CZ, Multi Target SWAP etc.
One can consider adding additional container types to manage the sequences of cirq.Qid that will be passed around gates to construct operations. Specifically, container types to represent LittleEndian vs BigEndian encodings of integers corresponding to qubit registers can be added, which would be useful for users to correctly apply gate with registers on ordered sequences of qubits.
If a circuit is composed entire of multi qubit register operations acting on well defined qubit registers, we can update the Circuit.to_text_diagram_drawer method to draw a single wire corresponding to the entire qubit register instead of 1 per qubit. However, this would work only for limited cases when a single multi-qubit wire is not "split" in between the circuit. For more general drawing capabilities supporting multi-qubit wires; we'd need an overhaul of the TextDiagramDrawer.
I'd love to hear thoughts of other maintainers and contributors, specifically @daxfohl @dstrain115 @dabacon. Please let me know if there are additional features that are relevant upon adding support for qubit registers but are not captured in the original proposal. Once there is consensus, I'll create smaller subtasks which can be taken up by 20%ers and other community contributors.
My first thought is there's nothing here that can't be done just using arrays of qubits in code. Is it worth the added complexity?
Second thought is that diagramming is an interesting use case that isn't directly doable without formalizing registers. But to enable that, would it then be disallowed to reference a single qubit in a register? Otherwise, how would you diagram that? Like if you had an ArithmeticGate on a register, and later had a CX on one qubit of that register, you'd have to have a horizontal line for the register and a horizontal line for the qubit, which would be weird. But disallowing referencing a single qubit would probably break decomposition; you couldn't decomp a gate referencing a register if there was some other gate that referenced the same register. Anyway, a lot to think about there and IDK if the ROI is there just for diagramming.
Third thought is serialization, need some way to do this to make registers preserve their meaning when serialized.
Fourth thought is maybe look to Verilog or VHDL for inspiration.
Fifth thought is, is there any reason a register can't just be a struct, that can contain qubits, classical bits, constants? Probably a dumb idea but figured I'd mention it. ArithmeticGate can operate on more than just qubits.
My first thought is there's nothing here that can't be done just using arrays of qubits in code. Is it worth the added complexity?
One of the primary objectives of introducing registers is to make it easier for users to "manage" these arrays of qubits. The easier management includes a) having a better interface for gates and not worry about supplying qubits in the right order when calling gate.on(*qubits) or splitting a sequence of qubits in the right sizes within _decompose_(self, qubits)  etc. As someone who has tried using this feature for writing composite gates that act on registers of qubits; I can confirm that the added value here is significantly higher than the slightly increased code complexity.
Cirq cync decision: will leave open for discussion for two more weeks and also break it up into sub-tasks
Cirq cync decision: need to break into sub-tasks, open to 20%ers
Is this considered done now with cirq_ft?
bump
