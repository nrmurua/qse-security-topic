Right now the transpiler has a pass for running dynamical decoupling but to use it one has to manually construct a PassManager using the pass and set that as the scheduling stage in a larger preset pass manager (or skip scheduling in the preset pass manager/transpile() and instead run it as a standalone pass manager second step). It would be good if we had a better integration of this as a scheduling step in the default pipeline. I think this involves two primary components, the first is building a scheduling stage plugin for running dd. After #10545 we're now solely using the plugin interface for scheduling and it is trivial to add another built-in plugin for running dd with scheduling_method="dd" (or dd_alap and dd_asap) that uses PadDynamicalDecoupling instead of PadDelay. The second part (and is probably why we didn't do this sooner) is provide a way backends to inform the gate sequence and spacing to use. This likely just means adding 2 new fields to the target for a backend to optionally specify the sequence and spacing. If it's not specified we can just pick a default (probably X-X).
This likely just means adding 2 new fields to the target for a backend to optionally specify the sequence and spacing. If it's not specified we can just pick a default (probably X-X).
Sounds like we need Options object attached to Target. In my opinion Target represents device (static) configuration and DD is user provided (configurable) setting. I'm not sure how much we can rely on Qiskit DD framework because IBM devices doesn't report conditional operation and measurement latency, and DD across (mid-circuit) measurement is not really trustable. IBMProvider provides a scheduler plugin but its implementation is basically to give up the scheduling around measurement operation. I guess end users tend to put too much confidence on DD.
Well I wasn't really viewing it as user configurable here. My assumption (probably a faulty one) was that a backend can declare it has a known good/default dd sequence and spacing that works reasonably well on a given backend. In that case a field in the target makes sense to me as it is a property of the backend that running DD with a y - y sequence provides good results. For user configuration/experimentation the pass can still be manually instantiated with any options somebody wants to use.
