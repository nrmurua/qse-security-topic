I have an experiment, BugScan, that runs a subclass BugSubRoutine multiple times. On the first run of BugSunRoutine the RTIO outputs are as expected, but for subsequent runs the RTIO events generated by bug_package.profileSwitcher are missing:

I would expect the three executions of self.sub_routine.run() to generate identical results.
I am using Artiq 1.1, with the nist_clock gateware on a KC705.
Experiment code:
Mediator class, bug_package.profileSwitcher:
Device entry in device_db:
Can you trim this down a bit?
I have managed to trim it down substaintionally - the problem can be triggered without using a subclass. I had not noticed this initially as the bug appears and dissapears with small changes in the code.
The following experiment, along with the mediator class in my earlier post, triggers the bug.

Are the diagrams made with artiq_coreanalyzer? Could it be some experiment switching related issue - what happens if you do time.sleep(1) at the end of run?
And can you keep removing code? There's still a lot.
The diagrams are made from artiq_coreanalyzer, and match the actual TTL outputs.
Adding a sleep(1) after the call to kernel_func() does not fix the bug.
I have managed to simplify it further - the experiment is now self-contained.

The kernel_test() function runs set_profile for i=0..3, this is correctly output on to [ttl4,ttl5].
Then kernel_func() calls set_profile(0) and set_profile(1), but the profile lines do not change properly, and it seems like the self.profiles[i].on() / off() calls set ttl5 for i=0 and i=1.
Reproduced. More trimming (symptom is TTL5 is high at the end):
@whitequark The compiler's attribute writeback feature corrupts the profile list.
Note how the list incorrectly contains twice the first object after the kernel has been run.
If that's not straightforward to fix, I propose dropping attribute writeback. It's not documented and I doubt anyone uses it, it might be a performance drag (and slow kernels are a problem), there are nasty corner cases with RPCs, and dataset management has developed since then.
This has nothing to do with attribute writeback. Rather, any list [a, b, c...] which contains objects of anything but builtin types will arrive as [a, a, a...].
