Qrack's QStabilizer implementation is currently strictly  limited to Clifford group operations (plus non-observable phase). We'd like to extend this, if we can do so with practical efficiency.
T-injection gadgets are a good first step towards practical generalization of pareto-efficient stabilizer simulation. As the "magic state" required seems to be prepared with the non-Clifford T() gate, but the gadget only requires 1 ancilla per T() injection, it makes sense to provide the magic state via a single QBdtNode. This might be much simpler in practice than previous attempts to generalize QBdt/QStabilizer interoperation.
Immediately upon preparation of the magic state for one injection gadget, in interoperable context with a stabilizer state, the QBdtNode has two equally superposed branch amplitude multipliers that point to the same or different substate trees; in this case, these substate pointers are stabilizer pointers, to the same stabilizer simulator object. The branch amplitude multipliers are offset by the application of a single T() gate after H().
Refer to the link to the T-gadget diagram in the original post:
With a QBdtNode-like logic, the magic state is initially fully separable and trivial to prepare in itself, (as with Schmidt-decomposed SchrÃ¶dinger method over QBdtNode branches, not within stabilizer formalism). If there is only one QBdtNode, measurement is trivial, as by calculating probabilities from  just the node's probability amplitudes, picking a branch by probability, and selecting that branch (stabilizer) substate as "collapsed." Then, the "hard" part of the gadget is CNOT(), before the magic state ancilla becomes separable again after measurement and can be discarded.
We're acting this gadget always on a pure stabilizer state. In stabilizer simulation, as implemented in QStabilizerHybrid, the possible single-qubit probability expectation values of any qubit are 0, 1, and 1/2. We can check which of the 3 possible values the stabilizer state is in, without disturbing the state or "extreme" overhead in simulo. If the expectation is 0, CNOT() is equivalent to doing nothing. If the expectation is 1, CNOT() is equivalent to deterministically acting X(). This leaves the only potentially entangling condition of 1/2 probability expectation, in a Clifford qubit state.
CNOT(q1, q2) is equivalent to H(q2); CZ(q1, q2); H(q2). Then, after magic state preparation, the CNOT() part of the gadget is like acting H(q2) on the stabilizer qubit q2, then acting nothing on the |0> branch of the QBdtNode state while acting Z() on its |1> branch, then acting H(q2) on the same stabilizer qubit q2 again.
After measurement, we throw away the magic state anicilla, as measurement must render it separable.
Rather, I think I have stabilizer control and QBdtNode target backwards above, but the point is that CNOT() can be decomposed to just H() and CZ(), which are trivial to apply either direction at the interface between simulation methods, as demonstrated.
Rather, H() is "nontrivial" in this case, exactly because of the orientation reversal between stabilizer and QBdtNode. (Phase() and Invert() would be "trivial," only.) However, this should be relatively straightforward to adapt from more complicated and less successful method hybridization work in a branch currently on the repository. (So, no free lunch, I guess.)
Starting from a pure stabilizer state, I believe the end result is that we are left with a single QBdt qubit pointing to two stabilizer branches, with the same number of qubits as the state before T(), overall. We can internally re-map qubit indices to put it in index position 0 at the top of the tree, and so forth.
We can avoid that cost for qubits with 0 or 1 probability expectation, as opposed to 1/2, but those conditions are probably not demanded in practice, after circuit optimization.
It might be worth considering again that the control qubit of CNOT() in the T()-injection gadget must be in (potentially phased) equal superposition, then.
TL;DR: The net effect of considerations above is that T() gate injection can be represented by a QBdtNode qubit with QStabilizer branches. First, teleport the stabilizer qubit target of T() into a QBdtNode, and Dispose() the stabilizer qubit measured in teleportation. Then, act T() on the QBdtNode qubit. This requires managing a dynamic domain wall between a QBdtNode tree with terminal QStabilizer branches. (T() acted on |0> and |1> eigenstates can skip the overhead of QBdtNode usage.)
My attention has been brought to a very interesting article in PRX Quantum: Fast Estimation of Outcome Probabilities for Quantum Circuits, with thanks and credit to those authors. I'm still reading the paper, but consider the alternate T() gadget construction in Appendix A.
Without QBdt, the QStabilizerHybrid layer already has a single qubit "gate fusion" layer over pure stabilizer states. I think this might be enough to implement their alternate gadget, which starts the ancilla in |0> when CNOT() is acted.
#972 does indeed accomplish the aim intended above, using the "reverse t-gadget" in Appendix A of Fast Estimation of Outcome Probabilities for Quantum Circuits.
