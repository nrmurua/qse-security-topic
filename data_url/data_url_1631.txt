I've been thinking about this a while and figured I'd toss this out there to get a quick idea of general sentiment on this.
Is your design idea/issue related to a use case or problem? Please describe.
Sorry, a bit of stream of consciousness to follow.
This comes up as I'm thinking about flow control, and how to design it. Following the precedent of tags in Cirq, we would create a ClassicallyControlledOperation wrapper type and use it. But then I get concerned about wrappers-of-wrappers-of-wrappers. Like what happens when you get a TaggedOperation(ClassicallyControlledOperation(TaggedOperation(GateOperation()))), etc. with_tags has some special handling such that it prevents a TaggedOperation(TaggedOperation), but as we start adding more different types of operation wrappers, this becomes more cumbersome and fragile.
These wrappers also are challenging to maintain, as they require to continually update the code in multiple places whenever new protocols are added or modified. I get concerned that wrapping-order could influence things like diagram drawing, when probably it shouldn't, and workarounds could be rough.
And of course there are times when users expect isinstance to produce a specific type, but get TaggedOperation. I know, I know, but still...
By comparison, qiskit's flow control is handled by a c_if field on its Operation equivalent, and that's all. Their design allows mutability however. Cirq's operations are immutable, so would require a bit more than a mutable field to support tags and flow control. But perhaps a dataclasses.replace would be sufficient.
Describe your design idea/issue
Generally flatten the Operation hierarchy, preferring direct support of common functionality within the Operation class, rather than relying on wrappers and subclasses. In particular, bring tags directly into Operation, with_tags can use dataclasses.replace or copy.copy perhaps.
(ControlledOperation I think is still fine, as it truly is a different kind of operation than the thing it wraps. i.e. I'd not expect isinstance(X.controlled_by(q), X) to be true).
Moving the logic shouldn't be too difficult. But deprecating TaggedOperation publicly might be painful. We may have to keep it around for a long time regardless and face issues for people who are using isinstance(TaggedOperation).
Possibly we can extract the tags functionality out into a mixin class, that would then allow easy and consistent tagging of other types of objects.
@95-martin-orion Did anything come out of cynq here, or was there not enough context to go into it without me being there? (I should be able to make it next week).
@95-martin-orion Did anything come out of cynq here, or was there not enough context to go into it without me being there? (I should be able to make it next week).
I think we'll want to have your input on this for a proper discussion. I skipped over it this week as similar items have come up before (e.g. with issue #3678) and some of the main decision-makers on that discussion were absent (@Strilanc and @maffoo).
I've looked into this a bit while starting classical control. This would be easier if Operation was implemented as a dataclass and with_tags could just use dataclasses.replace to create the clone. But it's not, and changing that would be a huge ordeal. The other option would be for with_tags to use the copy module to clone itself, but that comes with pretty big caveats given the diversity of Operation subclasses.
Classical control is now going to use a similar wrapper style, which seems to be the only other option if we can't use dataclasses and want to avoid copy, and it seems like it may be odd to use wrappers for some things but not use wrappers for tags.
Seems like the TaggedOperation wrapper is the best option available without major rework, and the ROI of the rework is questionable. We could also ask whether it's worthwhile to make a metaclass for Operation such that isinstance(tagged_op, SomeOperation) automagically unwraps the tag, but that's a separate question.
I'm going to close this for now.
