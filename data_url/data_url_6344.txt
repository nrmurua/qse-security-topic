Copied from #548:
'Per "What Limits the Simulation of Quantum Computers?", (https://journals.aps.org/prx/abstract/10.1103/PhysRevX.10.041038), we were also asked a question during our Unitary Fund talk, about whether we had a quantifiable notion of a "approximate entanglement," with regard to QUnit's Schmidt decomposition. This paper somewhat answers that question, by proposing a simulation technique that treats entanglement as the principle components of SVD in order to throw away small principle components, introducing a proportional error in fidelity, but greatly reducing the computational complexity of calculation the circuit.
The simulation method that the paper develops is similar in principle to using our Decompose() method, which is basically parallelized Schmidt decomposition, but for cases of imperfect decomposition. That method assumes that Schmidt decomposition can occur exactly on sub-spaces implied by the method parameters, which is a very special case in general ideal quantum computer simulation. However, if Decompose() were to be tested with Compose() called on the resulting separated subsystems, then with ApproxCompare() on the round-trip result vs. the original, then the imperfect Decompose() could prove tolerable to a quantifiably small loss of fidelity.
The existing ApproxCompare() method should first of all take a variable sum-of-square-differences threshold, to help this methodology. Further, rather than going to the trouble of only being able to calculate the sum-of-square-differences to hit-or-miss and throw it away, we add the SumofSqrDiff() method to expose that calculated value directly for the user.'
After that PR, this work can be carried on to fully support "approximate separability" as an optional feature for QUnit. I will experiment with incorporating this notion into the QUnit algorithm, which will be off by default in favor of exact simulation. For a modest error threshold, this could give a huge improvement in performance, at least for benchmarks resembling the (contrived) random universal circuit.
We already expose sufficient functionality via the API for users to start probing this, if users wish, but I think the important Qrack library development consideration is incorporating the QUnit class into the technique. To this end, one of my first priorities is to optimize QUnit::Decompose() to complete its function without calling Compose() across the set of qubits to be separated, first. This is one of the must critical pieces to enable "approximate separability" optimizations in theory, before exploratory work to ultimately incorporate the technique as a subsystem for QUnit, as a convenience. The optimized Decompose() method would expose enough to let the user start to experiment with their own approaches while leveraging QUnit, though.
To this end, from the last comment, the right first step might be a "grab-bag" Decompose() method, decomposing any random array of bit indices of a QInterface, but, while this simplifies user code, it greatly complicates the Qrack API internals correspondingly. I'm considering it, but this might be reserved for a second pass, as this would be easier for me to implement once the QUnit Decompose() optimization is completed, I think.
It looks like the Decompose() optimization works. Having written it, the start/length parameter based Decompose is much easier to implement than the "grab-bag."
While that's great for general usage, one of the big challenges for Qrack to implement "approximate separability" seems to be knowing at all when Decompose() or TryDecompose() could be applied for an approximate case. Checking whether it can, in flight, is costly. I'm considering how this might be alleviated.
