Can we pass non linear constraints to minimize function. if yes can you give me some example. Your help would be greatly appreciated.
Could the team help answer the question on handling nonlinear constraints for all the algorithms in scikit-quant? We have not found an example that let user specify nonlinear constraints. Appreciate your help!
No team here, just me. There is currently no uniform way to handle nonlinear constraints, as each optimizer has their own way both in terms of how to communicate unfeasible points and what happens in response. SnobFit has by far the cleanest approach: simply return NaN and it will keep on querying the objective function until it has filled its batch.
As-is, for SQNomad, raising a Python exception should do the trick, as that gets communicated to NOMAD. You'll get an unsuppressible error message in the printout for each failed point, but just ignore that. Note that I haven't actually had time to try this, though.
Thank you wlav. I think we are asking how to specify nonlinear constraints for NOMAD? for example, below how to pass nonlinear constraints to the following function:
result =  minimize(objective_function, x0, bounds, budget, method='nomad')
We tried to mimic how scipy.optimize does as you do have scipy interface, but it does not seem to work:
nonlinear_constraint = NonlinearConstraint(objective_function, -np.inf, 0)
res = minimize(objective_function, x0, args=(False,), method='nomad', bounds=bounds,
constraints=nonlinear_constraint, options=options )
As said, there is currently no such thing as it is not common across all optimizers. What should work is explained above, where you'd check the constraint in the objective function and fail the call with a python exception if it is out of bounds. This is what NOMAD calls a "hidden constraint" and is something that all the optimizers (perhaps with the exception of Py-Bobyqa) support (except that their behavior in response may be unexpected). Again, I have not tested this as it hasn't come up for our problems yet (all of which have tight range bounds).
So it seems your interface does not support nonlinear constraint yet, can I interpret this way? Otherwise, in your minimize function, you should allow user to specify constraints, same as scipy optimize does. So for us, we can not leverage your implementation to run nomad if we have a constrained optimization problem (constraint functions have bounds).
In another words, how easy or difficult to add the capability in your current implementation to allow specifying constraints function? Let us focus on nomad for now. Thank you!
Indeed, not through the top-level interface as it doesn't make sense for all optimizers I'm interested in. It is supported through the feedback from the objective, as explained, although as-is not uniformly to all optimizers, and the reason that that exist this way, is because those optimizers each support non-linear constraints in their own way and I haven't had the time to think through finding (or reframing) the commonality.
As for SciPy, it is the outlier here in pretending that there is such a thing as a uniform interface. In fact, if the optimizer does not support non-linear constraints, SciPy will simply give you a RuntimeWarning and subsequently ignore the argument. I.e. caveat emptor. I think that is a very bad interface.
In another words, how easy or difficult to add the capability in your current implementation to allow specifying constraints function? Let us focus on nomad for now.
Again, just call the constraint function from your python objective and raise on out-of-bounds. That, I'd say, is absolutely trivial, only that it is a subset of constraints that NOMAD allows. It should also work in SQNomad as-is, but I haven't tried yet.
As to NOMAD, which has a very rich interface that includes different definitions of infeasible, incl. e.g. whether it applies to a region that can be traversed but not contain the solution, calling different black box objectives depending on the nature of the constraint, etc., etc. Well, that full interface is accessible already when running the NOMAD C++ executable which in turn can run Python executables as the black box objective, with data passing back and forth through stdout printing. Iow., that interface does not and never did require SQNomad as it's a completely different use case. Instead, if you're interested in such an approach from Python to Python, you should just bind the existing NOMAD C++ interface into Python and use a parameter file as explained in the NOMAD manual (also has Python executable examples). Note that going that route will also solve parallel execution as contrary to the SQNomad approach, there is no GIL problem when running separate processes.
