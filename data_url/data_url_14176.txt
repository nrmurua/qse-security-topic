I would like something like this to added in quant_info and estimator. It will then allow us to  build observables from projectors instead of just Pauli operators
where 0 would be the |0><0| projector, 1 is the |1><1| and + is the |+> <+| and same with -. We would need a symbol for the +1 and -1 eigenstates of the Y operator maybe r and l for right hand and left hand to make the connections to quantum optics etc.
That would be quite nice.
Indeed, this is handy.  E.g. Quantum Volume becomes the expectation value of projectors over the heavy set.
Also it will simplify Kernel methods and I think it will also allow the calculation of matrix elements in chemistry easier. The only additional question I have  is do we also allow non-projectors for example |0><1|. These can be made from adding projectors so from a pure math it is not needed and if the users wants these they would need to provide the array of projector operators needed to sum together to give these. However, the case against this is  if we allow it to be passed to the estimator directly  estimator can internally construct the minimum set of hermitian observables to be measured and then return these non-hermitian observables to the user and there could be examples where this results in less calls to the hardware.
For the record I vote not to add these non-hermitian elements and force the users to make the over complete hermitian set to calculate these if they are needed.
This feature request is bordering on adding additional requirements to the quantum_info package when the Qiskit/Terra team is already struggling with increased responsibility just around the corner with new stability guarantees coming.
The point of a composable library and interface is so that we do not need to define new objects that need support in various interfaces.  Anything that can be passed to an Estimator as an observable must be normalisable to a SparsePauliOp or we break every existing Estimator, including the IBM ones, the Qiskit/Terra reference ones and the Aer one.  So if we always must normalise to SparsePauliOp, then we don't even need a new object - we just need an easy way to generate a SparsePauliOp with the properties you want.
This doesn't even need to be in Qiskit/Terra: that's the goal of a composable library.  Here's a helper function that you can use right now that replaces the hypothetical SparseProjOp, with all released versions of Qiskit that include the primitives, and it'll automatically work:
It just generates an observable as a SparsePauliOp that represents the projectors.  This is what a hypothetical implementation of Estimator would need to do anyway even if we added the proposed object, but my way, we've got no additional API surface that needs supporting, and you can even start using it immediately.
For example, using the example given in the original comment, here's it working right now on Qiskit 0.44 / Terra 0.25:
this does not work as it hides the exponential in code. The point is to use basis directly so we don't need to sum them all up and can stay sparse. It is also why we can not today do machine learning examples efficiently and I believe it is why I have seen multiple rewritings of estimator. I agree that it has changes in many locations but the point remains that we are limited without it for various algorithms that use estimator on projectors and adding a method that does an exponential is not the solution.
Yes, changing this is a fundamental entirely breaking change to every Estimator that has been written to the public interface, because the API was not designed to allow operators other than SparsePauliOp after normalisation, which will always have the exponential problem when you want to write in a non-Pauli-operator measurement basis.
It's not a small feature request, and implementing it safely without breaking every existing Estimator would require the introduction of a versioning system to the interfaces, then a very careful upgrade path.  That's a significant design undertaking that the primitives team would need to do.  That's not to mention the API design of the new object being suggested here, the combinatorial new features and testing that it works throughout quantum_info in conjunction with other operators, and the on-going maintenance cost of such an object.
This is perhaps one example of why there are multiple rewrites of Estimator, but there will be more things just like this.  At first it was "Pauli-basis measurements are the only thing needed", now this adds "Pauli-eigenstate projectors are needed too" - an API like this either needs to know that it can represent everything worthwhile efficiently, or it needs to be designed with safe expansion in mind, which the primitives are not currently.  Good interface design is hard, and people won't stay around attempting to build on shifting sands while we make multiple new versions trying to iterate to something correct.
Making the allowed types to an interface wider (accepting more types) is a backwards compatible change. Designing for forwards compatibility is much harder, and we have typically not endeavored to do so.
The Sampler and Estimator have been in the wild for about 1.5 years and I think it is perfectly valid to refine these interfaces based upon what we have learned so far about how they are getting used.
The computational and Pauli basis are the standard basis of quantum mechanics and while I agree it is a lot of work I'm not going to go into why it was not done and any argument on philosophy of design. I agree with you on these points and we need to fix going forward and its why mixing quantum and software is actually very difficult. However, if we want a estimator that is useful we need to support both Pauli and Computational (in the operator sense) otherwise it is incomplete and will never allow us to develop algorithms on top of them.
Generalizations beyond these I agree should be out of scope and I would argue that most are not primitives (like an over complete non-hermitian basis) or a generalized phase operator.  However, we can have long debates on what it means to measure phase in quantum mechanics or what it means to have an over complete non-hermitian basis (like the coherent states of cavities) but when it comes to hardware we need to have a hermitian operator defined over a operator basis that can be efficiently described and the two most common are Pauli and Computational, if you can come up with others we could consider them but to rule out computational when algorithms such as Kernels exist is a significant miss that needs to be rectified.
Blake:
Making the allowed type to the public part of the interface wider is backwards compatible (that's similar what my helper function does, it just skips the intermediate object), but making the allowed type of the normalised operators passed to the implementors is not, which is what's required here to avoid the exponential explosion.
For example, an Estimator instance is required to implement an concrete method
while the base class takes observables: Iterable[BaseOperator | SparsePauliOp | several | other | things], which is normalised into Tuple[SparsePauliOp, ...] by the outer interface, and then given to the concrete implementor's _run.  If we now change the interface such that wrapper instead normalises to Tuple[SparsePauliOp | OtherObject, ...] and gives that to _run, that's now unsound because SparsePaulOp | OtherObject is not a subtype of SparsePauliOp.  Any current implementor of Estimator would fail when passed those objects.
Fixing this means adding new abstract interfaces to Estimator so the superclass can determine what it can safely pass through to the inner object (or leave the normalisation up to the inner objects, or use an asymptotically worse fallback, etc), which isn't super easy to do neatly, but mostly my point is that this is why there's versioning required.
Jay:
While I'm loathe to bring back the contention when I recognise you were trying to find common ground, I think my argument is actually kind of the opposite of this: we've already identified one new place where the initial design didn't account for something, so I think it would be best to assume that there will be others in the future as well, and make sure that the Estimator is defined in a generic manner that allows for future expansion, if we need to change it now.  Just to be clear: that doesn't necessarily mean knowing what the future operators will be, it means defining the genericisation of the typing and the responsibilities of the re-use / normalisation such that particular concrete implementors can expand to accept some abstract type T without requiring the whole ecosystem to move with them.  The current client-side normalisation and implicit-only re-use makes that more difficult (though some of the MVP-scope goals slightly easier).
To find the common ground again: I'm totally on board with the idea that there are other observables, including the Pauli eigenstates, that are worthwhile.  Adding new objects to quantum_info is a non-trivial design and then maintenance burden that I really want to flag as something we often forget, but that's a secondary concern to making sure that the interface is extensible without us enforcing that every other hardware provider needs to move in lockstep with us; it's already very difficult to get Qiskit/Terra, Aer and the IBM backends (client- and server-side) to move in sync, let alone things outside our immediate control.
If we had made SparseProjOp as a subclass of BaseOperator, it would work with the existing primitives, albeit inefficiently. So I recognize that it is not API breaking, as all we need to do is add an efficient path. So it's possible.
Some of this functionality already exists in Qiskit, so its inclusion is not that far fetched, e.g. https://github.com/Qiskit/qiskit-terra/blob/06416d7ee75500c50cfddc67574421cf73913f8a/qiskit/result/sampled_expval.py#L23
That being said, I am not sure the full runtime stack is capable of handling non-Pauli operators.  For example, I am pretty sure all of the resilience_level settings for the Estimator that are not zero would break with a non-Pauli input.
IMO you only need a BaseOperator if you plan on constructing these via composing, tensoring etc.
As far as an input to Estimator is concerned, a perfectly suitable data container for a sparse pauli-measurement basis observable is just Dict[str, complex/float] where str can contain any characters in I, X, Y, Z, 0, 1, +, -, r, l for terms in either Pauli's or their eigenstates.
