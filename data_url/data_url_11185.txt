Hi all, I have not found a function in openfermion that would allow me to compute the matrix exponential of a (in my case second-order) polynomial of fermionic (or majorana) operators (the matrix exponential will here be a unitary operator). The dumb way I do it is I calculate the polynomial using FermionOperator(), and then I use get_sparse_operator() to get its sparse matrix representation. Then I use scipy.sparse.linalg.expm() to compute the matrix exponential.
As far as I know OpenFermion does this capability directly. The sequence of get_sparse_operator -> expm() is the common mode of operation.
Thank you for the quick reply! I will use expm() then! But I was more thinking if there's a way OpenFermion could compute these matrix exponentials approximately using a Taylor expansion and quick commutator evaluations of the symbolic operators. But this probably will be super slow and inefficient except if the argument in the exponential has some special properties like in case of the fermionic number operator.
The datastructure we use for FermionOperators is pretty inefficient - we just store everything as a dict. I think doing the matrix exponential using the sparse form of the matrix will probably be faster than any Taylor expansion you could do here.
Michael, can you state more completely what you are trying to do? I suspect that whatever it is can be accomplished with very high numerical efficiency using our new OpenFermion-FQE (fermionic quantum emulator) library. It is accessible to you, but we are still working on docs / tutorials / release paper so it isn't really "launched" yet...
Hi Ryan, what I need to do is compute a polynomial of fermionic operators and take its matrix exponential, then multiply it with the vacuum state |0> (a one-dimensional array of length 2^N). In the simplest form, this will look something like this:
|Psi(M)> = U(M)*|0>
where M is a (2N x 2N) matrix and U(M) is a unitary of the form
U(M) = exp( sum_{p,q=1}^{2N} A_p * M_{pq} * A_q )
where A_p are Majorana operators ( e.g. MajoranaOperator() ). I construct the argument of the matrix exponential using OpenFermion and it is super easy and fast. Then I transform the argument to a sparse matrix and perform the matrix exponential using scipy.sparse.linalg.expm(). After that I do the sparse Matrix-vector mulitplication U(M) @ |0>.
This way of computing the matrix-vector product seems to limit me to around N=13 on my laptop, even though I can easily get the ground state of Hamiltonians as an array for systems of size N=18. I was just hoping that maybe there's some smarter way of doing this.
The FQE exploits number and Sz symmetry to save wavefunction memory.   Since Majorana's are translated to number breaking fermion ladder operators (they are a linear combination of raising and lowering). I'm not confident you will get a large savings with FQE.  If you have particle conservation then FQE can save you a lot of memory and it implements very fast products.  In fact for dense fermionic Hamiltonians with N or Sz symmetry we implement the matrix exponential with Taylor or Chebyshev series.   We also have custom routines for fermionic monomials but that would require you to Trotterize your U(M) expression leading to an approximation.
@ncrubin: Some of the models I consider are in fact number-conserving, meaning that matrix elements of M which would change particle number (those not containing an equal number of creation and annihilation operators) are zero. So for those type of systems it would be extremely helpful if I could try FQE
FQE can be found here (https://github.com/quantumlib/OpenFermion-FQE).  Happy to answer any questions as you get started with the library.  Like Ryan said, we've soft launched the library and would appreciate feedback!   FQE will digest FermionOperators so you won't have to do anything very fancy to get started.
@ncrubin Thanks a lot! I will make sure to try it for number conserving systems, and of course just see what it can do in general. Cheers!
