It is unclear, and seemingly impossible after trying hard, to select a quantum algorithm for KEM/KEX of my choice, or at all for that matter. The example given with the internal TLS server/client designed for testing works like a charm, but if I wanted to choose a quantum algorithm for KEM/KEX say for a vpn, or generate the parameters to use one for a configuration file, there seems to be no way of doing this. With the OQS-Openssl_1.0.2 one can specify the ciphersuite and that takes care of it because in that version the ciphersuite definition includes the KEM/KEX, but in OpenSSL 1.1.1 KEM/KEX is no longer in the ciphersuite, and creating "curves" for the Qalgorithms using the OpenSSL API for EC is no go.
Even the demos for nginx/curl/httpd do not mention how to choose one over the others. Could you please advice on how to do this?
Thank you.
For TLS 1.3, the OQS key-exchange algorithms only pretend to be elliptic curves in the ssl layer, so that an algorithm can be negotiated using the supported_groups and key_share TLS 1.3 extensions. They haven't been added to the EC API since they aren't really elliptic curves, and cannot be manipulated as such.
Thus, you should be able to specify a PQ key-exchange by passing an OQS algorithm name to an option/directive through which an EC curve/group can be named. This option will vary based on the application, but, for example, to use frodo640aes:
Now, if, for example, you want to support both frodo640aes and kyber512, and no more, you can replace frodo640aes above with frodo640aes:kyber512. The "Key Exchange" section here gives a full list of the OQS key-exchange algorithm names you can specify.
N.B: OpenSSL 1.1.1 has implementations of both the TLS 1.2 and TLS 1.3 protocols, and it is in TLS 1.2 that "ciphersuite" refers to "signature algorithm + key exchange method + symmetric authenticated encryption scheme". In OQS-OpenSSL 1.1.1, we have added post-quantum key-exchange algorithms to the TLS 1.3 protocol only.
I tested with OpenVPN, it does not work. No Quantum KEMs/KEXs "curves" are recognized. The server uses the below curves as expected, I tested, but with "kyber512" and "frodo640aes" as per your example I get:
The function that get's called in OpenVPN to handle the ecdh-curve parameter uses OpenSSL code, but apparently is not able to find the curves nid by name .  See below:
EDIT 1: I found the problem:
It is unclear to me how to extend this table for the OQS algorithms: what the values would be and if there is any extra logic that needs to be added anywhere else to make this work like a charm.
Now the openvpn curve list makes sense, it is exactly the list above.
For the OpenSSl s_server/s_client in the 1.0.2 archived fork using TLSv1.2 I was able to verify that kyber1024 works because I can see that "random bytes" used in the exchange are the exact size it should be for that parameter per the NIST submission paper for kyber, and also because the ciphersuite for that algorithm is chosen by the server when it's the only one the client lists as available -- I wanted to make sure it chose that one.
But, nginx on TLSv1.3 under OQS-OpenSSL-1.1.1-stable is a different beast. For one thing, I am never able to see the TLS handshake in traffic, never happens...it is a mystery to me what is going on there, or if my chosen cipher suite in the nginx conf file is ever chosen. Also, the output of the openssl s_client  is not exactly showing if the KEM/KEX chosen is actually used. The only thing that is clear is that the certificates are being validated; I can't say anything beyond that.
Could you please confirm or let me know I did something wrong.
Update: The reason I was not able to see the nginx traffic is silly...it turns out you have to enable docker containers to have access to your network, else all traffic is internal to docker. So open ports to the outside world with  -p hostport:containerport or the whole thing with --network host. After that I was able to see the nginx traffic and it looks fine.
May I suggest you try out OQS-nginx: When running that, openssl s_client always shows the temp k[ex]  (type) chosen, e.g.:
(generated by executing the example code): Use any of the KEMs supported and you will see Server Temp Key (type) changing, as well as data lengths and timings change (roughly in line with what is expected for each algorithm). You can even trigger classic EC, e.g., by passing (KEX=)X448 as the curves parameter.
@baentsch  Ah, yes I see that. However, I still cannot see the TLS hello in the traffic, can you see the raw packets with that key negotiated?
@ReverseControl Yes. openssl s_client -debug.
@baentsch I still cannot see the TLS handshake in traffic; that is to say, capturing traffic independent of openssl for verification.
Using the debug flag I noticed the following:
Is this public key meant to be the kyber2014 public key? Because the size of that key, per the NIST submission paper, is exactly 1568 bytes which is not 9472 bits.
I tested with OpenVPN, it does not work. No Quantum KEMs/KEXs "curves" are recognized. The server uses the below curves as expected, I tested, but with "kyber512" and "frodo640aes" as per your example I get
OpenVPN doesn't work with our fork TLS 1.3 OpenSSL 1.1.1 fork. Even if you had the code to find the curve, you still get errors because OpenSSL is trying to parse the alg as an actual elliptic curve. More modifications would be needed on OpenVPN to make this work.
The TLS1.3 OpenSSL 1.1.1 fork works just fine with nginx; i looked at the source code and it does not seem to do anything that much different than the OpenVPN source code to handle TLS, other than being much better organized and readable.
What needs to be done to make OpenVPN work with the TLS1.3 OpenSSL 1.1.1 fork? I can give it a shot to integrate it, after all nginx already uses it and it works like a charm.
What needs to be done to make OpenVPN work with the TLS1.3 OpenSSL 1.1.1 fork?
This is on the list of things to investigate...
Update: The reason I was not able to see the nginx traffic is silly...it turns out you have to enable docker containers to have access to your network, else all traffic is internal to docker. So open ports to the outside world with -p hostport:containerport or the whole thing with --network host. After that I was able to see the nginx traffic and it looks fine for nginx.
@christianpaquin why can't we have nice things that just work? :(
