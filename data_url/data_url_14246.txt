In the follow up to #5774 the one piece missing from the transpiler is supporting specialized instructions through the transpiler.
The primary piece missing from this is the BasisTranslator which doesn't have a mechanism to choose between multiple valid mappings. The other issue with the BasisTranslator is it doesn't know how to evaluate if a tuned variant of gate in the target is valid from a generic entry in the equivalence library. For example, if the target supports both RZX(theta) and RZX(pi/4) on a qubit the basis translator doesn't know how to either choose between them and also reason about about RZX(pi/4) matching anything in the equivalence library.
To address this we'll need to teach the basis translator to apply some heuristic when traversing the equivalence library. The easiest way is probably to apply a weight to the dijkstra search that the pass runs on the equivalence library based on the error rates in the target. This should give use the ability to pick better equivalences when there are multiple available.
The other piece is a bit more complex we need to look at the mapped circuit from the equivalence library and determine if the specialized version of the gate in the target is present in that circuit. If it is then we can use it, if not then we can't. The problem is that the entire basis search right now is based solely on the name of the gate, which is the unique identifier for gates, but the basis translator doesn't know of any relationship between just names. For example, continuing with the RZX example from above, if RZX(pi/4) is named "rzx_45" and RZX(theta) is named "rzx" the basis translator doesn't know what "rzx_45" is or that it is a specialized version of "rzx" when performing the basis search.
