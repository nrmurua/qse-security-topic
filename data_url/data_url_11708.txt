Using the IQAE algorithm on the real backend fails due to the operations or gates placed after the measure of target qubit.
No additionnal gates after the measurement.
With the simulator, we don't get this behavior. I think that transpiling on a real backend may cause this error. When i run ae.construct_circuit(k, measurement=True) with different values for k, i notice that there is no added gates after the measure of the qubit. But if then i transpile the previous instruction on real backend, the measurement doesn't appear sometimes at the end. So, i think just add a barrier before the measurement can resolve this issue.
Also a client of IBMQ Network is wondering if it is possible to compute at first the Q ^ k operator and then finding the circuit for the final operator instead of implement k circuits of Q? @stefan-woerner maybe you know which approach is optimal in the number of gates?
Although the transpiler shouldn't push any gates behind the measurements, I could reproduce a case where this happens. Thanks for finding this bug, I'll add a barrier before the measurement.
Concerning the pre-computation of the Q^k: the algorithm iteratively chooses the next k_next based on the output of the circuit with Q^k_old, so it is not possible to know the sequence of powers k beforehand. Is this what you are suggesting, or something different?
Sorry, i meant if we know already the value of k, how to implement the circuit Q^k? In the qiskit code it's implemented recursively(k times), but the client is asking if it's better to compute first the operator Q^k (product of k matrix) and then create the circuit associated.
This only works in very special cases (e.g. for 1 or 2 qubits). In general, we do not know how to compute Q^k other than repeating Q k-times.
@AzizNgoueya could you check if the problem is fixed with the latest version of the Aqua master branch? If not, then we can re-open this issue.
@Cryoris i just tested on the master branch and i can confirm that the measurement is always at the end. Thanks
