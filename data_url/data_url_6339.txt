Similar to the situation we used to have with QHybrid, QPager has one (or more) QEngine types, but it is a QInterface. If QPager were a QEngine, it could potentially "telescope" on top of itself. While QPager "meta-qubits" have not yet seen practical returns in our library, this is the primary theoretical reason I think we might want "telescoping" QPager types.
Implementing the virtual and abstract methods of QEngine directly within QPager would probably be about as hard as it was for QHybrid, which was not difficult. For a rainy day, it's worth making QPager a full QEngine subclass by the same approach as QHybrid.
To actually use this functionality, we would also need to refactor the qfactory.hpp header. (Tangentially, Benn was not totally happy with that header, as it basically remains to its same form today, and this might give a reason to rethink the factory in general, for all the mileage it's gotten us.)
A bit more info the Unitary Fund Hackathon:
QPager as a layer has since given major performance returns, with and without a QUnit (Schmidt decomposition) layer on top of it. QPager is basically a "paged" "Schrödinger method" simulation like the original Intel QHiPSTER or IQS. It can be used to "page" a single conventional quantum computer simulation array of amplitudes over multiple OpenCL devices in equal segments, but it also already shows big advantages for single OpenCL devices, using all 4 maximum allocation segments typical of NVIDIA GPU VRAM, including speed and qubit width improvements.
A QEngine type is an abstract class that represents any "Schrödinger method" simulation. QPager has a collection of QEngine types for its "pages," but since QPager therefore is a "Schrödinger method" simulation, in equal segments, it also can be a QEngine sub-class itself. It just needs to implement the abstract methods in QEngine. Generally, all Qrack QInterface types are best-off inheriting from the most specific abstract sub-class interface they can, which would be QEngine for QPager. (QUnit, on the other hand, is not a simple "Schrödinger method" implementation, and it therefore should not be a QEngine.)
The task, here, is to make QPager inherit directly from QEngine, which means implementing the QEngine abstract methods in a way analogous to how QEngineCPU and QEngineOCL do.
We have too many Unitary Fund Hackathon issues, and I think this one is among the least transparent and immediately necessary.
I don't think this is practically necessary, anymore.
