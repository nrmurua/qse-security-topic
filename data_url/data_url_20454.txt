Currently the API for KEX makes it a bit difficult to implement a KEM transform like Fujisaki-Okamoto generically.  This is because the message is generated randomly inside each implementation.
It could just be done on a per algorithm basis. This might be the best bet since we are concerned about benchmarking. In that case which of the current algorithms do we want to focus on?
One solution (to do it generically) that would involve a somewhat major architectural change is to implement a generic interface to asymmetric encryption then implement KEX in terms of that for the algorithms it applies to.  The transform can then take a generic asymmetric encryption represented by a struct and return a new generic asymmetric encryption that is wrapped with for example Fujisaki-Okamoto.
In pseudocode in a paper, one would usually try to capture this by explicitly writing the random coins as an input to the algorithm.  If our API had that as an argument, then we'd be done(ish).  We don't have that.  But we do have a RAND object as an input -- to apply the transform, could we instead pass in a (possibly custom) RAND object where the seed has been pre-populated by the transform?
Let's leave this to the individual schemes for now, rather than making it a global transform.
