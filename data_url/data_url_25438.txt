Users sometimes create workflows where an electron (A) refers to another electron (B). For example, beginners may inadvertently create more electrons than necessary because they are unaware that the electron magic only applies to the top-level functions within a lattice. This could also happen when users are simply experimenting with different ways to modularize their workflows.
For such workflows, the executor for A will need the executor plugin for B in its environment. Such pip dependency requirements are easy to miss because the executor plugin isn't referred to explicitly in the body of electron A, and the resulting workflow failures can be puzzling.
In the following example, the braket executor for task_1 wouldn't be able to unpickle task_1 unless it also has covalent-ssh-plugin installed.
One way around this is to JSON-serialize the electron constraints in the electron decorator before passing it to the closure returned by the decorator. Such metadata are presently serialized only after build-graph and before the workflow is sent to the dispatcher; this is too late since any function that refers to an electron will have already acquired a dependency on the electron's executor plugin when it is stored in the transport graph.
The following demo now works in the linked PR:
@kessler-frost does this also help in the other discussion we had for passing executer before hand while dealing with qiskit plugin?
@santoshkumarradha Hmm, I'm not sure.
