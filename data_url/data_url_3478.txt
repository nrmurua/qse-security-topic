@mpharrigan It looks like WFSim is meant not to look so much like a QAM, but the only other interface we supply for poking memory values in is through a QAM. What's an acceptable interface to this functionality for WFSim? Another method for poking memory values in one-at-a-time? Passing a dictionary of memory references + values at run time? Something else?
yeah I don't know. memory_map argument to wfsim.wavefunction()?
Thanks for this addition, it is very useful for quick testing of the same parametric program between QPU, QVM or using the WFS.
However, for the QAMs, methods like qc.run(executable, memory_map) expect the memory map to be of the type memory_map: Dict[str, List[Union[int, float]]]
Is there any way that the memory_map dictionary type for WavefunctionSimulator (which is now Dict[MemoryReference, Any]) could be changed to be consistent with the str,List notation? Or should it rather be the other way around and should the dictionary memory_map always have MemoryReferences as keys for the dictionary?
It might be I misunderstood something about the proper use of MemoryReference, but in the documentation/tutorials it currently suggests using strings as keys for the memory_map dictionary, while the value is a list of floats or ints of length ...
Oh no! If the types are mismatched, that's completely my mistake. I'll look into this when I get into the office tomorrow morning. Sorry about this!
@vincentelfving : I opened a PR at #809 that will repair this. Thanks very much for saying something!
@ecp-rigetti thanks Eric, and for opening #809 ! Besides the method wavefunction, should we also modify the type requirements of memory_map in the methods expectation and run_and_measure?
On top of that, I noticed that there is something missing; In my view, a user would already have declared classical memory registries and they are already in the Program() that is delivered to let's say WavefunctionSimulator().expectation(program) , because that would be consistent with the QAM case where a parametric program is compiled and then passed to a QuantumComputer.run(binaries, memory_map) call..
That means, instead of adding a function like augment_program_with_memory_values , the actual ForestConnection or API or WavefunctionSimulator backend needs to insert the values given by a memory_map dictionary into the user's program at the points which have been specified by the user when he declared the MemoryReferences with the same string names as the keys in memory_dict. As it is now, the calls to self.connection._expectation don't carry the information of which values should be inserted into which parameters.
Hope this makes sense? And is that actually feasible? If not, what is a reasonable workaround?
Good catch again about the other calls in WavefunctionSimulator. I updated the PR to catch those type signatures too.
I'm not sure I understand your second concern. The lists appearing in a memory_map determine what goes where: if you want to poke a value into the second member of the array named "theta", then you should pass in a list whose second value is what you want. Meanwhile, DECLARE directives are treated as global: there's no part of the program that happens "before" a DECLARE or "after" one. Accordingly, you can treat everything as happening at the start of the Quil program (which is what a_p_w_m_v does): put all the DECLAREs at the top, and then use a sequence of MOVE instructions to populate the array entries with whatever the user wants. Since a_p_w_m_v gets called before self.connection._expectation does, I would think that this array initialization is successful.
I fear I'm misunderstanding you. Feel free to explain it to me againâ€”perhaps with some sample input, the desired output, and the bad output that pyQuil / QVM gives you currently?
@ecp-rigetti thanks for the explanatios! I just checked my codes again and with the latest modifications of #809 , it all works splendidly and the parametric compilation workflow is now also the same for WavefunctionSimulator, which makes life a lot easier.
Case closed I think, thanks for the very fast response.
