(Related to #943 and #944...)
Back when I first adapted QStabilizer from Aaronson's tableau algorithm and layered QStabilizerHybrid on top of it to allow interoperability with state vector simulation and QUnit, I noticed that measurement "broke" simple assumptions from state vector representation about subsystem separability.
When we determine that a state vector subsystem is separable in QUnit, there is no physically measurable degeneracy in the representation. There shouldn't be any in stabilizer representation either, compared to state vector representation of the same state, but measurement of entangled subsystems "breaks" locality of separable qubit subsystems via our current Decompose() and Dispose() implementations for QStabilizer. These operations should always work on any separable subsystem, but, in practice, they fail for definitely separable subsystems when nonzero stabilizer representation cross-terms exist with any qubits in the complementary separable remainder, which only occurs after measurement. Further, naive application of Aaronson's Gaussian elimination algorithm doesn't seem to amend this particular degeneracy, (not that we should necessarily expect it to do so).
Originally, QStabilizerHybrid was a "reach" feature. It was a success for it to work at all, (and with QUnit), and I simply let these cases described above cause QStabilizerHybrid to revert to state vector representation, with full generality. It only seemed to be a performance "glitch" that didn't hurt numerical correctness. However, in QBdt extended stabilizer representation, (#943 and #944,) this becomes a major roadblock, because we seem to need to use the quantum teleportation algorithm to cross a "domain wall" between quantum binary decision tree simulation method and stabilizer simulation method, and teleportation requires measurement in a way that seems to sometimes or mostly run afoul of this case.
For the above reason, it's time to address the incompleteness of QStabilizer::Dispose(). From long experience with all these methods of Qrack, the reader might accept my assertion that some (degenerate) stabilizer tableau representation always exists that represents the same state and can be Schmidt decomposed by the existing Dispose() implementation, (as seems obvious from the fact that we do Schmidt decompose these very states anyway, just after the very costly step of first converting from stabilizer to state vector representation).
It's math that I need to understand, now, and I will begin studying it in more depth this weekend. QUnit might actually be the first component to benefit from the research, as separable cases no longer will need to fall back to state vector representation before internal calls to QStabilizerHybrid::Dispose().
Looking at Aaronson's tableau paper and the Nielsen and Chuang textbook again, I only learn so much that I hadn't learned from them before. At least, I realize that the "standard form" of stabilizer codes as produced by Gaussian elimination in Nielsen and Chuang is not generally unique. Maybe we can we adapt Dispose() to work with this form, maybe we can produce a unique standard form, or maybe there's a slightly expedient but brute-force route.
By brute force, QBdt would greatly benefit from being able to recognize stabilizer states and press them into stabilizer nodes lower in the tree, in short order of development priorities. We already can convert freely between "ket" and quantum binary decision tree representations, as well as from stabilizer to ket, (thanks to Aaronson himself). If we can convert single QBDT branch pairs to single stabilizer qubits when possible, we may "close the loop" on all three representations. This might be not optimal, but it might be the least personally frustrating route, admittedly.
(If we go the route of QBDT to stabilizer representation conversion, when possible, we'd replace the teleportation algorithm with a full conversion of the stabilizer state to ket representation upon demand, then to QBDT representation, then revert as much of it to stabilizer as we can, less the necessary depth to complete a demanded universal gate.)
I'm thinking of even alternative methods, but there might be momentary advantages to triage between stabilizer, state vector, and QBDT representation. Specifically, stabilizer states might find relatively compact representation as QBdt node sub-trees, (though I suspect that the compression is effectively proportional to entanglement).
Review of the literature makes me fairly confident that our rowswap() adapted from Aaronson's CHP can always be used without changing the logical state of the tableau. (The same seems to be true of rowmult().) This might allow us to recover some ability to call Dispose() after measurement.
rowswap() alone doesn't generally correct the problem, considering 02936f8. Additional rowmult() in measurement might, though.
Another potential approach is to adapt Aaronson's printstate() in CHP to output a table of stabilizer generators that can be used for state preparation. State preparation would be easy with post-selection, but, again, we want to avoid entangled measurements.
(See https://quantumcomputing.stackexchange.com/questions/6408/deriving-a-state-vector-from-a-stabilizer-states-generators)
(Thanks in part to some Monday morning banter with Dr. Cassandra Granade and Dr. Sarah Kaiser...) There was a bug in this particular case of my stabilizer measurement method, this entire time! Once that was fixed, Gaussian elimination does the job one expects, here.
At least the solution implementation was ultimately easy!
(See 8fa95bb for the bug fix, by the way.)
