Describe the issue
In mesolve, all the intermediate result for each t in the tlist will be saved. If the given tlist is very long, this can be a bottleneck for time and memory. In the Option class, there is an option store_states, but it does not work as I expected. Setting it to False does not turn this off.

According to the code above, there is no way to completely turn this off. One has to either save expectation values or save the intermediate states.
To Reproduce
gives
@Ericgig @jakelishman
This is expected. I don't see any reason to compute the state at a time if you don't want the state or and expectation value... If you only want the last state use tlist=[0, t_last]. Also tlist does not have to be a linear space, if you want to save only the few last values you can do: tlist=[0,990,1000], etc.
If you need to use an array coefficient and this is your restriction on tlist, use qutip.Cubic_spline (or build the QobjEvo before the solver, but I don't remember if it is safe in v4).
We probably shouldn't mutate the given Options object, but the call as written here doesn't make a huge amount of sense - why would you want to run the integrator but not have any output stored at all?  You'd just be spinning your processor.
That said, if we're going to do something different to what the user requested we should at least emit a warning.  There's also interplay with store_final_state here too; it's questionable technique to do e_ops=None, store_final_state=True with a tlist with more than two elements, but probably people who aren't familiar with nsteps will do something like that, and it seems a bit picky to prevent/warn on that when the intention seems clear.  I think that the current behaviour doesn't take this case into account when falling back - it'll store all states, which in the 4.x branch is a fairly major time sink (but much much faster in 5.0).
What behaviour would you expect for your use case?  I'd probably do something like:
Thanks!
@Ericgig
If you need to use an array coefficient and this is your restriction on tlist, use qutip.Cubic_spline (or build the QobjEvo before the solver, but I don't remember if it is safe in v4).
This is exactly my case. I see, I can just give mesolve a Cubic_spline object, very nice. I didn't know that give tlist to mesolve is same as asking these intermediate results. I was using it just as a match for array coefficient.
Actually, I've been using array coefficient for a while and I don't even know such functionality exists. And I remember someone else mentioned this to me before, so I shouldn't be the only one. I see in the doc there is a section mentioning it. Probably we could stress it a bit more.
@jakelishman
We probably shouldn't mutate the given Options object, but the call as written here doesn't make a huge amount of sense - why would you want to run the integrator but not have any output stored at all? You'd just be spinning your processor.
Sorry, my post was a bit unclear. I only need the final result. So I set store_final_state=True, but that doesn't change the behaviour of store_state at all. Indeed, I'm doing so just because I didn't know the solution Eric pointed out before.
For me a warning before changing Options would be nice. And probably pointing out the solution Eric mentioned?
Ok, cool.  I don't think there's any situation we should be mutating the Options class we're passed in though - I'd consider that a bug no matter what, since that leaks like your print statement shows.  We can just duplicate it on entry, then modify that.
To me it's not clear that passing several items in tlist should override an explicit store_states=False - as long as we allow you to  pass an array as time-dependence, there is a sensible reason to pass more items in tlist than you need results for.  Sure, you may also be able to use Cubic_Spline, but if we punish you for using arrays by swapping your options, why do we provide them?  I think we should only warn and change the settings if nothing is going to be stored - store_final_state should be enough to suppress it and not store the intermediate states, even if that implies the user might not be doing the fastest possible thing.  I don't necessarily think we should try to promote ideal usage through runtime warnings if that's more verbose to type - that's what documentation is for, and some people will do stuff because it's faster to type, since they work interactively.
When no options and no e_ops are given, the solver should store the states, otherwise nothing is done. Since the default value si store_states=False, the solver don't know that the value was explicitly given or the default. We should have store_states=None as the default. This allow us to respect an explicit False while keeping the expected behaviour when no options are given. I will make this change in the v5 solver (And make sure no Options are modified).
tlist was never meant to control time dependence, it represent the time at which the solver look at the state (+ first and last times). I added array support as coefficient as a shortcut to Cubic_Spline and I used the already existing tlist, but this is clearly a limitation and in v5 they will be controlled independently.
