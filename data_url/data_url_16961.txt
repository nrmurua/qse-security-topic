This only applies for OpenPulse enabled backends, for users trying to get data from the backend to build Pulse Schedules.
backend.configuration().control(qubit: int) returns a trivial mapping to a ControlChannel with index specified by the given int qubit. This is not correct. It should be possible to determine the correct channel by inspecting the backend hamiltonian, if it is provided.
Right now the easiest (and hacky) way to get the correct channel is by reverse engineering the control channel index by inspecting the cmd_def of backend.defaults().
I think the Pulse simulator does some hamiltonian parsing to figure out the same information that would be required to implement this feature. That is probably a good starting place. It should be implemented in qiskit.providers.models.PulseBackendConfiguration.control.
Yes. This is absolutely important feature. To be more specific, this is what we need to do in current pulse module for getting a control channel instance to drive CR with a combination of two specific qubits.
This is not smart solution, and cr_drive should be provided by backend. However, a device Hamiltonian depends on system architecture, and it might be difficult to create general parser to extract qubit-channel mapping. Functionality of control channel is also system dependent.
We can start from comparing Hamiltonian of several different architectures, e.g. fixed-frequency, tunable coupler, frequency tunable superconducting / spin / trapped ion qubits, and check if we can create general model to map channel-qubit topology. If not, we need to think about adding BackendConfig to describe control channel functionality in an explicit manner.
As a first step to tackle this issue, adding qubit_channel_map (List[List[]] containing qubit, control channel and measure channel info in each inner list) to the backend configuration schema seems like an option. I'm open to suggestions for the name - qubit_channel_map.
