It should be possible to do this:
Currently you get:
I assume qc2 is a similar circuit to whatever the input was that generated trans_qc. It looks like the cause of this is two-fold, the first is the way ancilla allocation is done we're modifying the initial layout in place so that it has all the idle qubits set in the layout. The way I'd normally think to fix this is just store the layout in a separate property before ancilla insertion so that the initial layout is just the input qubits. But, VF2PostLayout actually complicates this a bit because we can set the layout post-routing we might end up with a wider circuit than the input due to inserted swaps and it will always work on the wider layout, but we want to ensure the layout in initial layout reflects what VF2PostLayout selects. I think to do this accurately we need to store the input layout to FullAncillaAllocation so we store it prior to ancilla allocation, and also update ApplyLayout to update that based on the partial output of VF2PostLayout. I think doing that for 0.24.1 is probably in scope.
I do think we probably should also return the full width initial layout because I think it would be also be useful depend on your use case, but I think that also relates to #9476 and how we want to handle ancilla expansion in the layout.
Yes, the circuits are the same.  Really I want to use the same layout that was found for the previous circuit without having to chop up the Layout object myself.
Fwiw, given some input_qc and output_qc = transpile(input_qc, ...), then a suitable initial_layout input for transpile is:
That's a list of integers suitable for any other input circuit of the same width as the first input.
Perhaps the solution that seems most logical here would be if initial_layout didn't contain information about how the additional virtual ancilla qubits were mapped to physical ones (and vice versa).  However, even if we made that change, the use here would still need additional special constraints to be satisfied by the circuits: they'd need to use the same bit instances.  Changing that requires a whole change to how qubits and clbits are represented in Qiskit, so that's not practical right now (although worth exploring).
On that basis, I think the circumstances required for any modifications to the object returned in initial_layout to be immediately usable (without any mapping) are too special to warrant the breaking change it'd require.  Including the mapping as a utility function is more plausible if still a little bit of a special case.  If we can think of a solid name that doesn't make it sound like too much of a special case, I think it's reasonable to include.  That said, it's a sufficiently simple operation that I don't know if it needs to be in Terra.
