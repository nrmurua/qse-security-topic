I have two questions / feature request regarding template matching and arrays.
Below there is a code example that uses a blackbird template to extract the gate parameters a user might request in a blackbird program.
Q1: There is a line in the example blow that seems to define a 2-D array:
I couldn't get it working with a 1-D array, and did not find anything related in the docs. Is there a way to define a 1-D array instead?
Q2: Q2: While my template defines an array parameter (e.g. squeezing_ampltidues), the template matching returns the individual elements (squeezing_ampltidutes_0_0, ..._0_1, and so on). Is there a trick to get an array or list back from the template matching?
Thanks @lneuhaus.
I'll clarify the things we discussed earlier here, so that it's easier to track.
Q1: Due to how arrays are implemented in Blackbird, all arrays could be seen as matrices, i.e. there's only one type (which Blackbird calls "array") which internally works like a 2-dimensional np.ndarray. So there's no way to define a 1-dimensional array as per your example.
Q2: This is also per design, although perhaps not the most intuitive nor effective way. It's done this way due to how free parameters are handled internally. When defining a parameter array, like in your first example in Q1, it gets transformed into an array of many free parameters. This way, internally it works the same as if you would have written out all parameters separately like this:
The match_template function then attempts to match these free parameters in the Blackbird template with the corresponding values in the Blackbird script, and thus only sees the ones ending in _0_0, _0_1, etc. This could/should probably be updated so that it instead returns lists with the same shapes as when defined, although this is probably not high on the priorities list right now. Furthermore, even though re-writing Blackbird in a way that's compatible with more advanced logic, as in the above cases, would be nice, I doubt that'll happen soon.
Note: all free parameter names ending in _0_0, _0_1, etc., would currently be reserved for arrays like above. As long as the root of the name differs from a defined array it should be OK, but it's probably best to avoid naming free parameters with this naming scheme.
