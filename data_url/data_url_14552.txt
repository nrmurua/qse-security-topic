When transpiling a certain two-qubit unitary U, for which is_unitary_matrix(U) returns True the following error is given:
Either an error is thrown about U not being unitary when qc.unitary is called, or the decomposition should not error.
The tolerances in TwoQubitWeylDecomposition should be adjusted to match the default tolerances in is_unitary_matrix or viceversa. Another possibility is (provided that U is close enough to be unitary) to find the closest unitary to U, so that the decomposition goes through.
That particular bit of code changed (albeit only slightly) in #6896, but I just tested it, and it produces the same effect on main.
Changing the tolerances is pretty difficult to implement correctly, because the floating-point operations being considered in the two cases are quite drastically different, and unfortunately the matrix being unitary isn't even an absolute guarantee that this code will succeed.  I'm not sure what's meant by "the closest unitary", though - the concept of distance is pretty hard to nail down.
In this case, the matrix actually relatively far from unitary - in this case I find:
While it's not a perfect fix, as a temporary measure, are you able to use a more precise form of U?  Right now, the magnitudes of the errors makes it seem like immediate problem may be coming from only having the elements of U specified to 9 significant figures.
The error should be more descriptive, though.  Also see #4159.
One way to get a nearby unitary might be something like:
For the given example U the update is of the order 3.E-10:
I think (but I'm not schur) that changing the exception to a warning and normalizing D = D/abs(D) in a similar way after line 177 https://github.com/Qiskit/qiskit-terra/blob/06795bfa88f5bcb2c89d9d7a7621daa115a5cb18/qiskit/quantum_info/synthesis/two_qubit_decompose.py#L177 would similarly give the Weyl decomposition of a nearby unitary.
If so, the loop termination condition would need some thought, or we could dust off your slightly slower randomization-free diagonalization routine @jakelishman
The way I constructed the closest unitary is this
taken from here. Also in this case the update is of order 1E-10.
I was trying to get the problematic unitary (or not-so-unitary) in our algorithm with higher precision (the fact that there was a 1e-9 precision comes from printing), but it is non-deterministic and happens quite rarely.
This is another unitary (printed with higher precision) for which I get the error:
For which np.max(np.abs(U.dot(U.conj().T) - np.eye(4))) = 5.383681304527641e-13. Again, using closest_unitary defined above the error does not happen.
The closest unitary function you've supplied will always succeed, because it creates a 2q matrix where U @ U.conj().T is the identity up to a max difference of about numerical tolerance, regardless of how close the input matrix is.  If we're validating our input looks about unitary, then that isn't too much of a problem, but it still would be good to avoid an extra singular-value decomposition if at all possible.
I'm also not Schur (ðŸ™„) about whether just renormalising D in our approach would really solve the problem - it will ensure that the output matrix is unitary, but it still won't reliably pass the current np.isclose check.  That check is because the random algorithm sometimes fails by a long way, and we need some way to tell if we're in those cases, so we can repeat.  In that sense, we could just up the tolerance, or I could stick in the randomisation-free routine - that's a little slower (if I remember correctly), but if the input was a valid complex-symmetric (or close to one), it won't ever fail to diagonalise it into the correct form, so the isclose test becomes unnecessary.
Regardless of everything else, I think a closest_unitary() would be a useful addition to quantum_info. For this bug report, I guess it's an empirical question whether the best (in terms of speed and/or precision) approach is to start with applying closest_unitary() followed by the existing randomized diagonalization; or instead renormalizing D after a randomization-free approach using the as-supplied matrix (thereby skipping isclose() test). Is there a branch with your routine somewhere for checking?
Yeah, agreed that a closest_unitary function is useful.  Is this the only meaningful definition of operator distance that we want to consider adding as well?  I don't have another in mind, but just throwing it out there.
Because I am a fool, I had apparently deleted my old branch, but happily I was able to retrieve enough of the blobs from the depths of .git to reconstruct what I had on top of #6896.  I've put it up a branch (here's the comparison: main...jakelishman:deterministic-weyl-decomposition).
qiskit.exceptions.QiskitError: 'TwoQubitWeylDecomposition: failed to diagonalize M2. Please report this at #4159. Input: [[(0.4721638292945223+0.3042909989657806j), (-0.33229398169630664+0.27211948842897743j), (0.1011095965682541+0.4174268268048286j), (-0.06944655896172822+0.5574126561120751j)], [(-0.23379427491581675-0.36028952700716876j), (-0.542341468980306+0.14627858616257305j), (-0.10336810914783047+0.5521292672524615j), (0.22327151945422896-0.3669034407783363j)], [(0.1596861384428014+0.6044514527183461j), (0.330358794375403-0.001358482454473485j), (-0.1420309332827734+0.2982716756356982j), (0.47541894369461296-0.4060025239829998j)], [(-0.31512319119507964+0.09917738082237387j), (-0.03170892280287844-0.6243843093152571j), (0.5763757620358801+0.2421821678856728j), (0.22601598119007618+0.24094720322606808j)]]'
