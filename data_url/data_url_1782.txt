Is your feature request related to a use case or problem? Please describe.
I think the core of #3684 and #3677 is that simulator defies the single responsibility pattern. It is responsible for maintaining and transitioning state space as operations are applied, traversing the circuit, maintaining measurements, among other things. I think we fix this by decoupling some of those aspects of simulation, so I'm breaking this out as a separate issue. This will also be the next level of solving #2178.
Describe the solution you'd like
I'd propose breaking this into at least two separate things: a Simulation Algorithm and a Simulation Engine. The simulation algorithm would only be concerned with creating initial state from qubit sets, and modifying that state based off the current state and an operation. The simulation engine would be responsible for traversing a circuit and feeding operations into the simulation algorithm.
This creates a simpler interactive mode, where you only need qubits, a simulation algorithm, and some gates, solving #3684. It also solves #3677 since the simulation algorithm would have the functionality to create a state space from a list of qubits.
Then this allows you to do optimizations and tweaks around the simulations themselves independently of the simulation algorithm. For example, caching, aggregating waveforms, splitting into unitary/non-unitary parts, parallelization, logging, etc. Perhaps there's an opportunity for even further decoupling of simulation engine pieces in the future, but this seems like the first and most fundamental issue to handle.
Need to investigate other simulators and determine whether this type of decoupling is possible.
What is the urgency from your perspective for this issue? Is it blocking important work?
P3 - I'm not really blocked by it, it is an idea I'd like to discuss / suggestion based on principle
Could you provide more detail on the intended behavior here? In particular, many simulators (qsim, qFlex, and I believe quimb) achieve performance improvements over the Cirq simulator by analyzing the circuit as a whole. How does this mesh with feeding in operations with a Simulation Engine?
From my perspective, this model is oriented towards simplifying a future "interactive mode" for circuit execution, but I don't think that's our primary use case. Cirq is first and foremost a library for constructing circuits; outside of tests, the execution of those circuits should primarily take place on quantum hardware or faster external simulators, which largely prefer the "circuit in, results out" interface we currently use.
@95-martin-orion Yes there's a chance this approach won't be possible and/or useful depending on how existing simulators work. I haven't looked into anything other than our basic simulator yet.
The ideal result of this would be:
But I need to dig further into existing simulators to figure out whether any of that is even possible. Primarily I raised the issue now to get a high level opinion of whether this is something that's worth looking further into, or whether it's not likely to be possible and/or add much value.
Per feedback on the PR, it sounds like this abstraction doesn't add a whole lot of real world value. I'll go ahead and close it for now.
@mpharrigan Oh I see. Yes, I started integrating into the density matrix simulator and it appears that this would work there too. You could create a DensityMatrixStateManager:AbstractStateManager and inject that into the existing Simulator and it would work, so we'd be able to delete the rest of the DensityMatrixSimulator code. One caveat, we'd also have to inject like a CircuitTransformer that, in this case, would add the noise to the circuit before simulating.
I looked at MPS and Clifford simulators and didn't see anything that stood out as blockers there, but I didn't go in depth. So I think the abstraction could fit, for most Python simulators.
Still, I think this is a bit premature to work on right now. I want to get a better understanding of the other simulators, especially the C++ ones, and make sure the abstraction is one that adds the most value. Abstracting out the wrong thing would do more harm than good. So, closing for now but may revisit in the future.
