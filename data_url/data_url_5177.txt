For example, when I send the program H 1, the QVM rewrites 1 -> 0 as is expected behavior for using the least number of qubits possible, but for shared memory mode I actually want to apply a Hadamard gate to the qubit indexed 1, because my wavefunction persists from run to run. One can work around this by just applying the identity gate to all qubits at the beginning of the program, but maybe there is a better solution.
I wonder if this question should instead be: should the QVM respect certain PRAGMAs like PRESERVE_BLOCK? or otherwise should the QVM be configurable to preserve qubits.
@stylewarning thoughts?
This is really an issue with the idea of a persistent QVM. If a QVM persists, the interpretation of qubits shouldn't change from run to run. So the moral of this issue is correct. Shared memory mode sort of assumes that you're going to be repeatedly poking at memory, and you share the expectation as to where that memory will be.
We should incorporate this as a requirement for implementing persistent QVMs.
