As per discussion in #474, this notebook describes the semantics for a proposed Qobj.__call__ method that would generalize action on density operators and state vectors by superoperators and unitary operators. This would help make QuTiP more accessible and provide a consistent API for several closely-related group actions.
I quite like this. I find the operator-to-vector-vector-to-operator casting too cumbersome. I also think its OK notation wise, since we typically use parenthesis when superoperators act on operators. Another option however would be to add this functionality to Qobj.__mul__, such that Qobj.__mul__ is interpreted as 'acting on' if an operator is multiplied from the left on a state, or a superoperator from the left on an operator. Leaving out the parenthesis is also pretty standard notation.
For the Qobj.__call__ solution, I don't like so much that "A(B)" is interpreted as "A B A.dag()" when A and B are both operators though. This is not standard notation anywhere that I'm familiar with and I would personally be very confused by getting this result. If anything I would have expected an error or possibly the product "AB".
I'm glad that you like the __call__ option for super(oper); my thought there was that having __mul__ cas op-to-vec and vec-to-op could lead to some surprising behavior, especially when manipulating Choi states.
As for the proposed semantics for oper(oper), my thought behind making that return A * B * A.dag() is that this behavior would then be identical to to_super(A)(B), such that it would be a consistent with previously-used semantics within QuTiP. In particular, all of the superoperator representation conversions so far treat type="oper" Qobj instances as acting by conjugation.
Though I agree that adopting A(B) = A * B * A.dag() for the oper(oper) case could raise some potential for confusion, I think that it may be worth it for consistency, especially since __call__ would not conflict with any previous code. That said, given that it could be confusing, I agree it could make sense for it to raise an error.
Re oper(oper), I'd personally prefer to be "forced" to write to_super(A)(B). Actually I'd even more prefer to write sprepost(A, A.dag())(B). I honestly wouldn't have guessed that to_super does a conjugation (if I didn't already know), and at the moment I can't see it in the docstring, so the only way I'd find this out is by looking at the code. The docstring actually claims to raise a TypeError if the input is not a map. Even in the code, in the to_super function the only comment made if the input is an oper is # Assume unitary which is a confusing comment. At a minimum I think that this type of non-obvious behavior should be clear from docstrings.
For __mul__ vs. __call__ I see your point regarding Choi matrices representing superoperators. I would expect __mul__ to treat a Choi matrix simply as an operator. I think the case for a __call__ function is strong then.
Good point about the docstring, I'll go on and clarify that soon, then. Irrespective of whether it's good that to_super(A) == sprepost(A, A.dag()), I entirely agree that the documentation should accurately reflect the behavior of the function.
As for __call__, I'll make a PR based on the prototype then, with the oper(oper) notation replaced by raising a TypeError.
