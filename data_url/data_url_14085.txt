This is a feature I'd like to contribute to, and I'm making this issue to discuss the specifics and if it'd be used.
In Qiskit output, there's several built-in ways that I know of to visualize data.
There's plot_histogram, plot_distribution, and also of course simply matplotlib.
The current behavior of the plot_histogram and plot_distribution functions, as far as I can tell, will only ever display the counts for the final arrangements which had at least one count. An example of what I mean is that in a bell state where only the states 01 and 10 can ever exist, those are the only two to show up on the graph - there isn't a bar at 0 for 00 and 11. This is clearly useful for when one is dealing with many qubits or other scenarios, but when trying to intuitively visualize data, it doesn't seem natural to me. One primary reason why I think this is useful is that when switching from a simulator with no error to real hardware, new bars won't be introduced, just the values will be changed.
I'd like to propose adding another parameter to the plot_distribution, say the bool shownull which, when true, will display all states in the visualization, even those with a count of zero. Likewise for plot_histogram. This can have the default value of False to maintain current functionality while offering this feature seamlessly.
This is my first issue, so please let me know if I should format it differently or any other advice, and while I can easily do the above using simple matplotlib or using a combination of one of the above functions and data from the dict of the job, I'm not sure exactly how I'd implement it into Qiskit.
Thanks for your interest in contributing to Qiskit!
The plotting routines don't actually strip out zeros, it's more that the returned counts from experiments don't include entries at all for bitstrings that weren't observed.  If I manually make a counts dictionary and plot it, the zeros appear:

So potentially the main trick you want here is a helper method that adds in explicit zeros to the counts.  We have to beware here, though, that this will typically blow out memory, because there are $2^n$ possible bitstrings for $n$ clbits.  The Qiskit Counts object doesn't include enough information to know how many clbits should be included in the general case, so that would need to be passed as separate information (or inferred).  We've typically avoided putting in methods to Qiskit that involve producing the all-bitstrings result objects, because they're inherently unscalable beyond very small circuits and we don't want to given an impression that they're reliable, though I do acknowledge that for small-scale problems, they can be nice.
If it helps, this recipe will add explicit zeros into Counts objects, which you can pass your results through before sending them on to the visualisers:
In case you weren't aware, plot_histogram and friends can take a list of counts dictionaries, in some senses to support the exact use-case you're saying: the bars shown will be all bitstrings that appeared in any of the runs.  So if you've got counts_sim and counts_hw, you can do plot_histogram([counts_sim, counts_hw]), and it'll show all the bars that hardware detected, with explicit zeros for the corresponding missing entries from the simulator.
