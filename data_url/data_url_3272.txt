It's possible to have an unused memory declaration in a pyquil program. Why does this happen? In my case, because a program is being re-parameterized and in that process I copy_everything_except_instructions in order to preserve calibrations and defgates. The original memory declarations come along for the ride, which did not cause a problem in pyquil 3.
In pyquil 4, unused memory declarations cause the following error when submitted to the QVM.
@bramathon Thanks for this report, I'm not surprised you weren't able to find where this occurred in v3 as it comes down to something I found odd when I was rewriting the QVM client in v4.
The QVM lets you specify what memory regions you want back. In v3, this part of the request was based on the MEASURE statements in the program. However, v3 also initialized any declaration as an empty matrix in the returned memory. This led to odd result shapes in cases like this, where you would get back an empty array for a declaration that by definition must have 1 or more entries. Since the request is based on measurements, it avoids any issue with unused declarations.
In v4 I opted to request all declared memory back, regardless if it had been measured in the program. That way the QVM can consistently handle how memory is returned and the user can discern what they want or don't want with the result. However, this exposed a bug with copy_everything_except_instructions since it will copy over the state of the declarations property, which is maintained separately from the DECLARE statements that appear in a program. We use the declarations property to request memory regions back from the QVM, but after copy_everything_except_instructions, the corresponding DECLARE statements don't actually exist on the Program, and the QVM returns an error.
I've fixed copy_everything_except_instructions in #1600
Handled with #1600
