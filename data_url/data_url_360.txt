Presently, there are two distinct IRs for Quantum gates and their support. The first IR is in a memory SSA form where gate operations are ordered by their memory side-effects. The second IR repeats the semantics of the first IR in terms of the available quantum gates but has  threaded values with volatile semantics. Specifically, quantum values may only be read/used once and afterwards are considered mutated/destroyed. Quantum values are thus not SSA-values in this IR (although they appear to be).
There is a clarification needed between what is meant by quantum “SSA values” vs. classical SSA values. Specifically, in a classical sense an SSA value is read-only and will never change value; it’s state cannot change in the subsequent computation. In quantum computing, the “SSA value” is destroyed  and unrecoverable when it is used or referenced in any (target) quantum position in subsequent gates. Effectively, this means quantum SSA-values are not, in fact, SSA values but reside in a highly volatile quantum-value space. In our examples below, this means that a !quantum type value is volatile and can only be used once (as a target).
However, a !ref<!quantum> value has no such restriction. The reference is not volatile; the referent is. Exactly like other implicit memory-SSA IRs such as LLVM, the volatility of the underlying quantum state is fully ordered by the effective memory-SSA semantics.
This volatility property of a quantum SSA-value is a novel concept to classical SSA IR principles. Many useful transformations rely on SSA-values not being volatile in this way.
There is no semantic difference in many of the quantum gate operations between the Quake and QTX dialects. They both share a Common dialect subset of ops that are the same gates, but which use different type systems. There are other distinctive operations, but these are similar in differentiation to LLVM’s getelementptr vs. extract_value distinction. To be precise, the distinction between a memory SSA and a value SSA form.
In retrospect, it is hard to justify having wholly distinct dialects for this minor difference. Compiler IRs, such as LLVM and other MLIR designs, do not have this bifurcation. Instead they allow for the IR to mix memory SSA and value SSA forms freely.
Let’s take a simple increment of a variable as an example.
The memory SSA form is made salient with the load and store operations, while being simultaneously represented with the value SSA form of the add operation. There is no cause to separate the SSA representation into two mutually exclusive presentations.
The same thing should hold true for a quantum dialect. Indeed, the relationship between Quake and QTX amounts to folding the quantum loads and stores into the definition of Quake gates.
This folding is important because of the non-SSA volatile property of quantum "values". Without it, it would be required to load and store each quantum value before and after every single quantum gate. This would at minimum triple the size of the IR and have no practical purpose in reasoning about the IR.
The distinction between the dialects is then reduced to something trivial: the types of the arguments/results of the quantum gate. A particular gate does the same operation whether it has to dereference the quantum values or not.
Recognizing this, it is possible to consider a generalized treatment of mem-to-reg and reg-to-mem to perform load forwarding of any type over irreducible control-flow graphs can be performed. Whether the value is a classical type or a quantum type doesn’t change the algorithm. Furthermore, the distinction can be fully accounted for by overloading the gate to accept both memory and value SSA forms by way of type distinctions.
The above example shows us a quantum gate operation that is overloaded (by type) to have both a memory (reference) and register (SSA-like volatile value) semantics. MLIR lets one define operations as cross products of a name and set of types very easily. It’s one of its strengths as an IR framework. Note that the core semantics of the operation, what the operation means, has not changed, only the type of its operands and results (if any).
In a mixed-modality IR with both reference (memory) and value (register) semantics, one has choices and can freely use either mode or a combination of both. This greatly simplifies reasoning about the IR and eliminates the need to “fully convert” between the semantic levels. Full conversion and its implications thus no longer need be considered or bottleneck the IR.
For example, it is possible to write a function that has known-at-runtime characteristics, such as a library routine, that also contains fully optimized circuits (i.e., SCPs with quantum-values) as well. Moreover, issues such as “what is a vector of quantum values” can be decomposed into more fundamental concepts: (1) a classical vector of references along with (2) references that can be dereferenced to modify and use a volatile qubit state.
Another example is that it lets the compiler mix pass-by-value and pass-by-reference quite freely. Switching between one or the other becomes a question of optimization rather than a hard requirement.
All three of the above declarations are legal and have semantics.
Copy pasting some notes with initial thought on a possible breakdown of the work:
I am sure there are things missing, so please chime in to flesh this out further.
A PR to add a new "wire" type has already been merged. The second tiny PR is to add some new operations to make the wire type useful. More to come...
The unified IR changes have been merged and the old QTX IR was removed.
This is complete. If there are any additional problems, please file new issues for tracking them.
