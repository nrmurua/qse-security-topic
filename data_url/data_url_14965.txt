The test suite and CI are failing because of new deprecation warnings issued by Numpy 1.25 (removing some unnecessary aliases and deprecating some questionable array-to-scalar conversions that we first encountered in #10120).  There also seems to be some sort of behavioural change that's affecting the isometry tests and making them flaky, which is harder to pin down.
Run CI with Numpy 1.25.
No warnings, all tests passing.
No response
I'm not 100% sure what's going on with the isometry tests - the failures seem to have questionably large absolute differences between the expected and resultant matrices.  It's plausible that it's related to changes in sin and cos in Numpy 1.25: numpy/numpy#23399, but I'm still looking into it.
Here's a reproducer for flaky test behaviour with Numpy 1.25:
There are no ancilla qubits, so I think the unitary from the isometry is fully defined and there should be no deviations beyond standard floating-point stuff.  Instead, the Operator(Isometry(iso, 0, 0)) part is showing some very nontrivial non-deterministic variance in the off-diagonal elements each time it's called.
I've narrowed at least one component of this a little bit more.  This might not be the only issue, but I do know:
That call at the end used to produce deterministic output.  Now, the various values can differ between calls by an atol of somewhere in the region of 2e-16.  This then threads itself through the rest of the functions, occasionally flipping some global phases, and producing different matrices.  There's a call to np.linalg.eig in the middle of that above call, which I'm always suspicious of, but the 1.25 changelog doesn't mention anything obvious about how that might be affected.
This doesn't explain to me, however, why the operator for the output isometry differs significantly from the input.  Within a single construction, I don't know why minor differences in the FLOPs of the calculation can produce such different output.
I don't know if this is the root cause, but I've tracked down a seeming flakiness in the multiply ufunc with complex numbers in Numpy 1.25.  On my machine, the file
intermittently exits in the failure condition, with the imaginary components differing by 1ULP.  I couldn't reproduce that behaviour with Numpy 1.24.3 (or 1.25.0 without AVX2).
I don't really understand how that behaviour could cause a correctness issue in the Isometry decomposition itself - as far as I can tell it shouldn't attempt to recalculate the exact same FLOPs at any other time, so the decomposition should come out maybe differently each time, but correct - but it at least seems to be related.
I've filed the above issue as numpy/numpy#24000.  I'm not 100% sure it's a bug in Numpy, but I've chased this about as far as I can think right now.
This comment is meant to serve as a documentation point for workarounds for UCGate/multiplixer-gate synthesis problems with NumPy 1.25 and 1.26 on Intel Macs with AVX2 CPU extensions enabled.  The comments above this one describe a problem with these versions of NumPy in these conditions, which causes severe problems during our synthesis of multiplexed gates, most commonly encountered in Qiskit by calling UnitaryGate.control().
There are a few options for working around the bug, in order from easiest to most complex:
Install an unaffected version of NumPy.  At this point in time, we know that of PyPI releases: the 1.24 series and everything before it are good; the entire 1.25 series is bad; the current most-recent release 1.26.0 is bad.  I haven't checked the versions available on conda or conda-forge. You can track upstream progress on fixing the bug in BUG: Multiply complex128 ufunc inconsistent with AVX2 numpy/numpy#24000.
Disable NumPy's use of the AVX2 CPU extensions at runtime.  To do this, set the environment variable NPY_DISABLE_CPU_FEATURES=AVX2 before importing NumPy.  Typically this would mean launching python with that environment variable set, such as by running NPY_DISABLE_CPU_FEATURES=AVX2 python.
Install a version of the affected NumPy releases that was compiled using a compiler that does not exhibit the AVX2 bug.  See BUG: Multiply complex128 ufunc inconsistent with AVX2 numpy/numpy#24000 for details on the necessary compilers.
If Issue warning on known-bad combinations for UCGate synthesis #10906 has merged, and if you are sure that your NumPy installation is good, you can set the environment variable QISKIT_CMUL_AVX2_GOOD_NUMPY=1 before importing Qiskit to disable runtime warnings about the bad version.
