Implement function to request backend by type.
When a backend name changes, as happens for the real devices, this can break code which specifically requests the named backend. If instead there was a method to request a backend by specifying restraints this could avoid breaking code. This might mean requesting a device with a minimum number of qubits but could also be expanded to include other restraints e.g. quantum volume, simulation type, etc.
Currently all the backends return "configuration" dictionary. Perhaps this could be used for the filter.
Ok, so if I understood correctly, we want to to get the backend which better fits some criteria, right?
And you are suggesting that a possible solution would be including these criteria elements into the "configuration" that backends already have. That would imply:
At first sight, seems like this would indeed solve the problem, but these kind of filtering mechanism is usually more common when you are searching for something in a large data set, in our case, we only have a few backends.
Could we extract enough criteria elements from a circuit to find a valid backend?
I think we can start with just the simple thing; e.g. let the user specify the minimum number of qubits they would like and whether they want to run on a real device or a simulator. In the case of multiple backends meeting those criteria we return the one that uses the least credits (for remote) or is faster (local).
Perhaps the interface to the user for the above simple filter could just be them specifying "real" or "simulator" for backend and the sdk checks the number of qubits needed in their circuits.
Yeah, I like this approach. There's no even need to change the interface, we just have to add two new backends "real" and "simulator". The "real" one will choose one of the online chips and the "simulator" one could execute a local simulator if the number of qubits is less than a threshold or the online one otherwise.
Yeah, I like this approach. There's no even need to change the interface, we just have to add two new backends "real" and "simulator". The "real" one will choose one of the online chips and the "simulator" one could execute a local simulator if the number of qubits is less than a threshold or the online one otherwise.
I like it as well, having a "virtual" backend that chooses another one sounds like a neat solution!
I'm a bit concerned however about the initial separation between "real" and "simulator", as I'm not sure if it will end up being soon a bit of an exception when we add more criteria (in particular, with the proposed solution, it seems an user would not be able to specify "an online simulator with x qbits"?); but we can refine later.
One generic backend + requirement specification sounds good. It seems like there are parallels between the backend "configuration" structure and "requirements". Could we instantiate the generic backend with a configuration keyword (possible in current design) and the generic backend takes it as a specification request that it tries to fulfill with other available backends (e.g. by comparing against the configurations of the registered backends)?
I am not sure, however, whether a "requirements" specification should be a different object than the "configuration".
I'd like to discuss how we are going to expose this to the user, @ewinston Do you already have something in mind?. My suggestion would be: let's start with something simple and try to extract as much info as we can from the circuits.
I think we can close this now and point to qiskit 0.5.
