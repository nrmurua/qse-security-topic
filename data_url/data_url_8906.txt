This is a question about the memory layout of stim::simd_bit_table and how to correctly populate the table with samples via the C++ API.
I find that when I use stim::detector_samples the rows in the simd table alternate between being populated with some lit up detectors and rows that are completely blank. The code below reproduces this with all versions of libstim I tested:
The stdout then shows the following:
If I read this correctly, the first eight odd rows contain detector data and the ninth odd row is the observable. Please could you help me understand how I have managed to introduce this alternating horizontal pattern into the bit table? My sense is that I use the C++ API incorrectly because when I inspect the bit table here while executing the following python code the simd bit table is densely packed. So,
yields,
Well that's terrifying. Anything that can mess with the randomness of samples is a super critical bug, as it would compromise statistics like logical error rates that go into papers.
When I run your example code on my machine, there are no alternating rows. However, I notice that the results I get are the same as yours just without the rows...
I think I know what is going wrong, as I've actually run into it before. It's likely that libstim was built with -march=native which picked 256 bit AVX for the simd words while you built the code calling libstim without this flag which resulted in 128 bit SSE for the simd words (specifically, the two invocations of the compiler evaluated the "pick best simd size" macro differently, and then hard coded their choices into the two binaries that were then linked as if compatible). The really tricky thing here is that although the method you are calling does have a signature that says the size of the simd words, and the type does include the size, the mention is only in the return type of the method, and return types aren't included in overload resolution or in the .so file... so the linker happily links your 128-bit-word expecting code to the 256-bit-word providing code in libstim. It works in the python code because the underlying extension was built using the same flags for all files.
When I caught this size-mismatch issue the first time in a different context I templated the simd words class to make this silent failure into a compile time failure, but it misses cases like return values as you've just experienced, and I haven't yet gone the further step of templating anything and everything that touches simd word to make this truly impossible to happen.
You can work around this issue by adding -march=native to your compile flags, or removing the march flag from the libstim target in stim's source code. Properly fixing it requires templating a rather large part of stim's source code.
Thank you for the interesting and detailed explanation.
Adding the -march=native flag fixes the issue I reported. Further, I can confirm that, as you say, stim::MAX_BITWORD_WIDTH is set to 128 without the flag and 256 with the flag.
Do I understand you correctly that the longer term fix would involve turning functions such as stim::detector_samples into function templates so that something like this is possible in client code?
I would be happy to get involved in some of this work if that seems useful in future and aligns with the project's aims.
It's unfortunately a somewhat extensive change to make.
To template the method you called, you need to template the methods and classes that it uses (such as the pauli frame simulator).
To template the pauli frame simulator, you need to refactor the fact that stim stores a frame simulator function pointer for each gate. Presumably associating this data with the frame simulator itself, so that instantiating its template brings the needed function tables into being.
So this change spans all the way from the top (simulation method signatures) to the bottom (how gates are defined) of the library.
I'd be happy for someone to work on this, and it would be valuable to do (when this thing triggers a bug it's a serious failure and also very time consuming). Just... be aware of the scale of what you're getting into.
If you really want to do it, we could set up a meeting or etc to discuss it more. The C++ API in general is kinda terrible (a major reason I don't guarantee its compatibility across versions) and someone polishing off hard edges here and there would be nice.
I followed up via email and will close the issue. Thanks again for the fix.
