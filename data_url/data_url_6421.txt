Register-wise arithmetic, without carry, maps a single CoherentUnit input state to a single output state, one-to-one. However, the introduction of a carry bit allows for pairs of input states to be mapped to single output states. (Other carry arithmetic outputs might be simply invalid.)
ADD and SUB are correct, but ADDC and SUBC (with carry bit) are incorrect, as a result of the above. These operations could be implemented in terms of virtual gates, but this is slower than necessary. However, any optimized algorithm needs to match the output of gates. The overall phase of output states is some function of the two phase input states, (possibly the product of permutation state phase factors).
Carry arithmetic needs to debugged, with the correct phase output, preferably ultimately with optimization beyond virtual gates.
Serial implementation was straightforward, with adding probability and multiplying phases. (Refer to the CCNOT-like permutation matrices for the underlying matrices, to derive any effect on phase and composition of permutation states.)
For parallel implementation, I broke apart |0> carry-out and |1> carry-out outputs, with an effective or explicit memory synchronization fence between them. On either side of the fence, inputs-to-outputs are one-to-one.
