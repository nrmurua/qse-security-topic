https://github.com/lneuhaus/pyrpl/wiki/Lockbox contains the specification of the desired Lockbox API. Please go on and change it to your desires, or do post your remarks here.
I have added my comments inside the wiki page. I think this is converging towards a very nice solution...
What reason justifies NOT saving inputs and outputs as (Ordered)Dicts?
There are 3 aspects of the problem:
I am just saying that if output.name already contains the "name" of the output, and if that name is changeable, then actually storing the output in a dictionary lockbox.outputs[output_name] is not nice because both output.name and the dictionary key have to be "in sync". I find that storing the outputs in a list and then providing access functions such as get_output(name) makes more sense in that case, but I would say that it is mostly an implementation detail (especially because we can make a container class with a custom get_item later on if we change our minds).
Anyways, if names are not changeable, there is no point in storing them in a container structure (see next point).
Right now, it is a list of classes in the Model class, but I am not fully satisfied with that.
One of the caveats with this choice is that the name that is attributed to the inputs (defined at the instance creation time) is not obviously visible in the code (I think it is defined by the same function that finds unique names to the modules of pyrpl get_unique_name_list_from_class_list(self.model.input_cls) ). I think this makes the code difficult to read.
---> The solution that would be consistent with the approach used throughout pyrpl is to define the inputs this way:
For the outputs, we need to decide whether we can still create them "on the fly". This is nicer in terms of "user experience", but obviously, the following approach would greatly simplify the code (no need to update stuffs in the sequence and lockbox.default_sweep_output when an output is renamed/created/deleted)
I think we want to have the possibility to load/save the sequence independently of the inputs/outputs. This is ok as long as sequence is a submodule of Lockbox. The current situation is that the sequence states are saved within the lockbox. That means a lockbox state eventually contains many sequence states that can be individually retrieved or saved---> I would say that makes sense because anyways, all these stages depend on the name of the inputs/outputs that will change from Lockbox to Lockbox.
most importantly: imagine the following scenario; you are working on a cavity lock, then you realize that you need to add an extra output to control the temperature of the cavity. If we go for the predefined outputs solution, what you need to do is:
close the program-->make a derived class LockboxFabryPerotTemperature with an extra output-->the program should try to load the previous lockbox state at startup such that you don't need to re-enter every parameter by hand. That means, it should anyways try to load a generic "lockbox state" rather than lockbox state specific to LockboxFabryPerotTemperature. In the current BaseModule API, this is done by using always the same _section_name in all derived lockbox classes (in practice not overwriting it in the derived class).
It also means that the states of the lockboxes are all stored together (for instance, the 1st state would be that of a FabryPerotLockbox, the next one that of an InterferometerLockbox). The most flexible approach is probably to send an error message when the loaded state somehow doesn't fit in the current Lockbox type.
Finally, with this approach, changing the "LockboxType" on the fly is done by deleting the current lockbox object without touching the config file, creating a new LockboxType object, and loading the current state in the lockbox instance (or at least trying).
happy with current solution
