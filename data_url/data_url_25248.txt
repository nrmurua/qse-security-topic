It'd be great to have some utility function that is part of the Lattice object where the executors of the underlying electrons could be modified on-the-fly; something like Lattice.set_electron_executors(["local", "slurm"]), which would update the executors of electron 1 and 2 in a 2-electron lattice to "local" and "slurm," respectively. It's clear from the docs that you could set the executor of the lattice decorator, but this will apply a single executor type to all electrons in the lattice.
For an example of this challenge to be addressed, consider the following electrons:
The user's lattice might look something like this:
If I want to update the individual electron executors, I can of course set the executor kwarg in the electron decorators. But let's say these functions are used over and over again and are imported in a given user's workflow. The user doesn't want to touch the electrons as they are defined. If the user only wants to modify the executor of one electron in the lattice without touching the original definitions (or perhaps modify the executor of multiple electrons but with different executors in each case), it does not seem that there is a clear mechanism for doing this. This is going to come up for users who are building software packages around covalent where they are defining a curated set of electrons for users to import and use in their custom-defined lattices.
I tried using a class-based approach as shown in #1586, but that presented its own challenges and is quite clunky.
Hi @arosen93 , thanks for raising the issue! An alternate pattern which might help in your use case is to first define add and multiply as regular python functions and then apply the ct.electron decorator "on the fly" with different executors as needed. For instance:
This results in the following compute graph:

We demonstrate a similar pattern in the MNIST tutorial (see Cell 13).
Nvmd I see that @santoshkumarradha has given a much more comprehensive response in #1586 !.
@cjao: Thank you so much for the reply! You know, this is such a simple approach; I don't know why I hadn't thought of it. So basically, in my use case, it seems like the best option is to "just define the functions normally" and then the user (naturally) has full control over how to set the executors. It would have been a bit cumbersome if they had to use the decorator every time, but of course ct.electron() makes more sense here --- I should have thought of that one!
I'm going to go ahead and close this suggestion. I think the way you approached this is perhaps the most natural anyway.
Feel free to open it again if you wish, but I'm satisfied I think!
