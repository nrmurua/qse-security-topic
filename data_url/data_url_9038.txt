I apologise if this already exists and I was simply unable to find it in the docs, but it would be great if there was functionality to directly compute the probability of given measurement projectors instead of sampling a circuit many times and hunting for the instances of the desired outcome. For outcomes with a high probability certificate this is not horrendous but without it, sampling sufficiently many outcomes becomes infeasible.
I suspect the ability to do this does already exist but it not clear from the python API how to go about this. The closest thing seems to be the recently added peek_observable function but as far as I can tell this only indicates if an observable has a deterministic outcome or not.
This is surely possible as polynomial time fidelity estimation between stabiliser states is possible (and would also be a great feature to have).
Could you give an example where peek_observable doesn't give the answer you're looking for? In a stabilizer circuit running on stabilizer states, all Pauli product observables have expectation value -1, 0, or +1 and peek_observable gives that value.
From what I gather peek_observable indicates whether a given Pauli observable has a deterministic outcome (in which case it is +1 or -1) or it has a 50/50 random output. I wish to know what the distribution is for non-Pauli observables i.e. compute $\tr |0\rangle \langle 0 | \rho$ on many qubits. Of course, I could decompose the zero state projector into Pauli terms then use peek_observable but this seems like a very naive and inefficient way to compute it.
Although this does sound useful, supporting observables other than Pauli product observables (even if those observables correspond to a sum of a small number of Pauli products) is outside Stim's current scope as a nothing-but-stabilizers simulator.
If you do happen to have a fast algorithm for doing this, and are willing to write an implementation of it, then I'd reconsider. Until then this would just go onto the frustratingly large "things I could do but would never get around to" pile. For now I'll close this issue as out-of-scope. Thank you for the suggestion.
Ah I see, that is fair enough. I know that this is possible if the observable has a stabiliser representation (see here) and will write something sufficient in python using stim as a base - it won't be nearly as efficient as it could be with a C++ implementation but I think that is beyond me. If the functionality interests you enough perhaps you will find it worth to implement it, perhaps not. Nonetheless, thank you for the help.
