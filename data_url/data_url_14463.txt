Transpiling with a coupling map strips qubit names from instructions/data. It also scrambles the measurement, in some cases creating a measurement on an ancilla rather the originally targeted qubit.
Circuit, made by initializing an entangled state, transpiled with no coupling map gives:
Qubits:
[Qubit(QuantumRegister(3, 's'), 0), Qubit(QuantumRegister(3, 's'), 1), Qubit(QuantumRegister(3, 's'), 2)] [Clbit(ClassicalRegister(3, 'c11'), 0), Clbit(ClassicalRegister(3, 'c11'), 1), Clbit(ClassicalRegister(3, 'c11'), 2)]
Circuit, made by initializing an entangled state, transpiled with coupling map gives
Qubits:
[Qubit(QuantumRegister(4, 'q'), 0), Qubit(QuantumRegister(4, 'q'), 1), Qubit(QuantumRegister(4, 'q'), 2), Qubit(QuantumRegister(4, 'q'), 3)] [Clbit(ClassicalRegister(3, 'c11'), 0), Clbit(ClassicalRegister(3, 'c11'), 1), Clbit(ClassicalRegister(3, 'c11'), 2)]
I would expect that transpiling with the coupling map:
No response
The names of qubits after transpilation will not generally line up with any single logical qubit in the circuit before transpilation.  This is expected, and to some degree it's a completely unsolvable problem, because due to the constraints of a real backend, we'll sometimes need to perform swaps in order to get two logical qubits close enough in hardware to actually perform the measurement.  That means that at various points, hardware qubit $0 may be representing different logical qubits, including ones that were added as ancillas.
After transpilation with a coupling map, you're looking at the hardware qubits, not the logical ones, so you'll see a lot of this swapping.  The names line up with which logical qubit starts on each hardware qubit as a rough guide, but I'm not sure I can see a sensible way for us to do more than that.
Hi Jake,
Thanks for the response! So there are two issues here:
One is that the graphical representation does not reflect the class data of the circuit -- we see that the labeled quits and ancillas are displayed on calling the .draw() method, however the names and information have been wiped from QuantumCircuit.qubits. I believe that these should be in agreement at all times. If I call the draw() method, I would expect to see the correct qubit names, even if they are wiped.
The second is that on a circuit with n < N qubits submitted with a coupling map, we run into issues with partial measurement. Since bit-ordering is jumbled, and get_counts() returns "0" for unmeasured qubits, it's actually unclear what states we are getting without a lot of backdoor hacking. Maybe the alternate fix is to return a place holder for a partial measurement rather than a "0"?
I am not sure I follow here.  The names have changed because one has mapped from virtual qubits to "physical" qubits.  The number of physical qubits used need not be the same as the input if the system is larger than the input circuit width.  If I have multiple quantum registers, which one should these one or more additional qubits be assigned?  There is ambiguity there.
get_counts returns the classical registers that you attach to a circuit.  Those elements of said registers not assigned a measurement result are 0 by convention.  So if you assign the same number of bits as the number of qubits in the target device, but you do not use them all, then there will be extra zeros.  The bit-ordering itself is never jumbled, and is always well defined.  I noticed that your original code is calling the statevector_simulator in which case there is a permutation due to swapping that moves the state of the qubits around.  If this is your issue then yes it is a bit tricky, and has been a known issue for some time.  I have had an example PR of how to get this permutation (so you can undo it) here: #6827, but it has obviously not gained any traction.
