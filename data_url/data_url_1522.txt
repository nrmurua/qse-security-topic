The above fails with {'A'} != {'B:A'}. The parent path gets dropped.
Note this is independent of both #4611 and #4616, and likely more complicated than either.
Currently the logic in mapped_circuit applies both the parent path and repetition key in a single step, and only if there's repetitions. Thus it misses the parent path if there's no repetitions. What we need is for mapped_circuit to apply the repetition prefix first (if there's repetitions), and then later apply the parent_path prefix independently, regardless of whether there are repetitions.
Pretty straightforward, but the complicating issue is that with_key_path replaces the path rather than prefixing the existing one, so that in the above solution, the second step would overwrite the first. So likely the fix for this will require creation and use of a new with_key_path_prefix protocol. This should also be fairly straightforward, but will require this protocol implementation in a number of places. (Open question of whether replacing the path is ever required. All use cases that come to mind are exclusively prefixing a path).
Preferably we do this after #4611 is merged; otherwise that logic will need duplicated in both the deep and shallow cases, only to create a merge conflict later.
