The OpenQASM grammar - https://github.com/Qiskit/openqasm/blob/master/source/grammar/qasm3.g4  is the missing implementation of the Openpulse grammar https://qiskit.github.io/openqasm/language/pulses.html the objective of this issue would be to produce a grammar file that integrates with the existing OpenQASM grammar file.
@taalexander  do you have time to work with our mentorship team which is currently about to tackle creating an openpulse grammar (for lack of an extant one)?
( @AbeerVaishnav13 @nelimee @mrvee-qC )
Hi Jack, I've been quite busy in October, but I will see if I can or someone else from the working group might be able to help. I'll add you to that Slack channel to see if we can find anyone.
@aspcompiler and @jakelishman do you have any thoughts on how to best integrate this grammar?
Since the pulse grammar depends on the defcalgrammar statement, in #246, we try to delay parsing of the pulse grammar by matching the body of a cal or a defcal block to a single token so we can it them with a secondary parser.
Then the question is how do we define openpulse grammar? This depends on what can appear inside cal and defcal block. If the majority of OpenQASM grammar can appear inside OpenPulse, repeating them for OpenPulse is tedious. We did an experiment of OpenPulse by extending OpenQASM in that we added new types for frame, port and waveform. We had additional grammar like:
I think I have a couple more questions to ask before I can have a proper opinion on it.  Sorry this is long - I've laid out how I understand things at the moment so you can correct me if/where my premises are wrong.
If my understanding is correct, the way I'd suggest handling a reference grammar for OpenPulse is to make a completely separate ANTLR file (or files) for it, even if that means duplicating several rules from OpenQASM 3.
I had interpreted the existence of defcalgrammar as meaning that the contents of cal and defcal blocks were completely opaque to the langauge OpenQASM, and that OpenPulse was a completely separate language.  In theory, I expected that an OpenQASM 3 lexer+parser would be within its rights to simply lex the cal and defcal {} blocks into a single string token, and later pass it off to a different lexer+parser that is determined contextually by the defcalgrammar statement.
In order to facilitate this, the calibration grammar, I thought, needed to be a complete grammar in its own right, including a complete set of tokenisation lexer rules, and then a complete grammar on those tokens.  My reading of the OpenPulse spec, is that at the moment it doesn't seem to be quite complete: I see things like
but the symbols += and / aren't defined on the OpenPulse page, and it doesn't say what the semantics of pi / 4 should be (floating point constant divided by (presumably) integer literal).  I don't know if this is just yet to be written, or if the idea is to implicitly use OpenQASM 3's type semantics (I assume the latter).  Either way, my understanding was that a defcalgrammar isn't required to use OpenQASM 3's type semantics or operators; that's up to the grammar to decide.  At the very least, any grammar needs to be able to extend the type system and (potentially) overload operators - there are types in the OpenPulse type system that aren't present in OpenQASM 3 (e.g. waveform).
As long as OpenPulse is choosing to inherit some rules in OpenQASM 3's grammar, then I think it should have to specify them itself in its own grammar. In the spec, of course, it'd be fine to say things like "the meaning of + when operating on symbols that were declared in the containing OpenQASM 3 spec is identical to its meaning in OpenQASM 3".  That's still a complete definition - it's just that implementing in ANTLR by putting two separate languages in one file would make it seem as if OpenPulse and OpenQASM 3 are two parts of the same language, while the idea of defcalgrammar grammatically allowing an arbitrary string implies that they're separate.
I know that any new grammar is going to need to introduce new symbols, which won't necessarily be valid OpenQASM 3 symbols.  It may also want to use symbols that do have a meaning in OpenQASM 3 in a new context.  This poses a problem if a new grammar can use the } symbol in an unrestricted manner; we'd need to ensure that a fully compliant OpenQASM 3 lexer could always determine which } symbol is the end of a defcal or cal block, without needing to parse the defcalgrammar statement.  This isn't unsolvable at all (Li and I had a couple of possibilities in #246), but may require an addition to the spec.
In practice, of course, I know that a compiler for one particular backend is likely only going to support one grammar, and so for simplicity and efficiency is probably going to treat OpenQASM 3 and the supported calibration grammar in a unified manner.  My text above isn't concerned with how real-world implementations will actually generate an AST, more about how they're allowed to by the spec.
My questions are:
My understanding is that OpenPulse was developed by implicitly re-using several symbols and rules from the OpenQASM 3 grammar for ease of use.  However, another calibration grammar isn't absolutely required to do that.  If so, I think that when we're producing the reference grammars, we should be explicit that OpenPulse's re-use of many of OpenQASM 3's syntactical constructs is because it explicitly chooses them to be the same (and possibly write that in the OpenPulse spec, too), rather than any property of calibration grammars that requires them to do that.  That's why I'm keen (subject to my understanding being correct) to completely separate the OpenQASM 3 reference grammar from the OpenPulse reference grammar.
If there is meant to be a much tighter coupling between OpenQASM 3 and permitted calibration grammars (i.e. if the answers to questions 1 or 2 is "yes"), I think we'd probably need a much bigger overhaul of the reference grammars, so we can separate out the "core" rules that are required to be shared between OpenQASM 3 and calibration grammars, and rules that are only for OpenQASM 3 (or other).
Yes, the language of the specification needs to be cleaned up.
No
The grammar must of course be capable of referencing the input arguments to the defcal.
In places where a calibration grammar uses the same symbols as OpenQASM 3, is it allowed to prescribe different meaning to them? For example, would a calibration grammar be allowed to use the ^ symbol to mean "power" instead of "xor"?
Yes, but this would be unwise.
N/A, see 1.
@steleman may be able to way in on how he was able to use some cool features of Flex/Bison to implement the Openpulse grammar.
Yeah, ok, those are the answers I thought, thanks.
Yeah, I totally agree that any real implementation won't completely separate out the two parsing bits there, because I can only assume it wouldn't be very inefficient, and it'd be a pain to do.  For the reference ANTLR grammar (which isn't required to be the most performant), I think it's best for it to be a complete implementation of everything allowed by the spec, including handling really stupid rules that different calibration grammars can do but almost certainly shouldn't.
It's possible in ANTLR to inherit rules into two separate grammars, I'm more just thinking about how we present things to users here: for a reference grammar, I don't want to give the impression that OpenPulse is getting special treatment by being a "part" of the OpenQASM grammar, even if every real world implementation actually does that.
I'm very interested in hearing what flex/bison can do here as well, because I'm learning these tools as I go along.  In particular I'm interested about special ways flex might have for swapping lexing mode to handle the new tokens, or things like that - the parser component of ANTLR and Bison are perhaps less easily comparable, since (I think) ANTLR's a generator of LL(*) parsers, and Bison generates (among others) LALR(1).
I had a brief encounter with flex/bison many years ago. My impression was that ANTLR LL() is much more forgiven than LALR(1) whereas one often has to worry about shift/reduce conflict. It is much easier to translate a grammar from LALR(1) to LL() than the other way around.
In any case, we need to define the grammar first; parser generators are just tools. Since OpenPulse is closely related to OpenQASM, it would be advisable to design syntax/semantics as close as possible. Also, the published grammar only defines the syntax for the parser and the semantics is actually handled by the compiler implementation.
@jakelishman's example actually remind me more about what I did with my experiment. I rewrote
to avoid introducing new syntax for dot expression and operator:
I used SetPhase/ShiftPhase extern functions to manipulate the phase. pi/4 was parsed as binary expression by the parser and then handed to the compiler. Hope this being a data point on how we can simplify the work on OpenPulse grammar design.
From a consistency standpoint, I preferred and advocated for what you have posted @aspcompiler however the larger group pushed for the current syntax. I do know that in our internal Flex/Bison implementation we have implemented the dot notation without trouble.
We don't have trouble with dot notation either and will support whatever that is formally defined in OpenPulse grammar. I should clarify that the experiment that I shared was merely to find out what I need to minimally to implement pulse before we have formally defined OpenPulse grammar.
