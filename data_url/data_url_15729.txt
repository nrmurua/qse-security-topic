When using CVAR expectation within a VQE algorithm, there is a slight chance to get a negative variance which causing numpy RunTimeWarning. Therefore the estimator error isn't saved to the intermediate results.
The bug is due to floating point error (subtracting two almost equal quantities).
Return variance equals zero in these cases.
Correct the subtraction in CVaRMeasurement.eval_measurement() method, to avoid floating point error.
From the type hints of CVaRMeasurement.eval_variance, it can (apparently) return a complex - that seems incorrect for a variance, except the way the class is written appears to allow you to take the expectation of non-Hermitian operators.  Those quantities are complex, but either the variance calculations assume they're real, or they're calculating a sort of pseudo-variance, which isn't necessarily real non-negative - they don't take absolute values internally.  Either way, there's unsafe stuff happening in there (according to the typing).
If it is meant to allow returning a complex value, we can't put the handling inside CVaRMeasurement.eval_variance, unless we also detect if the expectation operator is Hermitian.  The caller can do it, though - VQE already throws out any imaginary part, so it can clip the real part to 0 as well.
@Cryoris @BryceFuller Can either of you take a look/commet etc - I think you were both involved with the CVAR expectation right,
Opflow, which includes the CVAR Expectation is now deprecated and soon to be removed. SamplingVQE now does CVaR and as a such replaces that opflow based logic. Since this is pretty old now and is around logic soon to be removed I am going to close this.
