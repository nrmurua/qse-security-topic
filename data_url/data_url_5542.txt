If you sample a matrix product state, you get not only the value (bin, hex or int) of the measurement but also the exact probability of the measurement. If only counts are returned (as it is in the AerSimulator), the relative sampling error for a large number of qubits with small probabilities $p$ is $\varepsilon_{rel} \simeq 1/\sqrt{p \cdot shots}$ and thus very large. A dictionary of exact probabilities, on the other hand, contains much more information. So there should be a method to get probabilities of a matrix product state measurent. For example, you can get count = 1 for a value, but the probability may be only $10^{-10}$ or less, which otherwise can be obtained only by an enormous amount of shots.
Please check the probabilities snapshot.
It changed its name to SaveProbabilities: https://qiskit.org/ecosystem/aer/stubs/qiskit_aer.library.SaveProbabilities.html#qiskit_aer.library.SaveProbabilities
I don't think that's what I meant. Let's say we generated an MPS for 500 qubits. You can't store all probabilities here! You can only sample the MPS or measure it for certain qubits. That is, for the second case it may work with this method, but not for the first!
Let me give you an example. We sample a matrix product state of a random circuit for 500 qubits with 1024 shots. Then the result will contain a dictionary of 1024 different states with counts = 1! But the states all have only a probability in the order of $10^{- 100}$ (I would say the probabilities are lognormally distributed). And for every experiment you will never get the same state!
I checked QuantumCircuit.save_probabilities() with AerSimulator(method='matrix_product_state') and the behavior is as expected. If placed before QuantumCircuit.measure_all() it works like a statevector simulator, if placed after it it takes the quasi-probability of the counts. In both cases, the result is returned for $2^N$ states, leading to exponentially growing execution times and a died kernel for num_qubits = 50.
