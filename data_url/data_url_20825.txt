Valgrind seems to take exceptionally long for ledakemlt52. I've ran this test on my machine several times and it takes around 20-25 minutes to complete. The running time of functest seems to be around what we expect, but also long. For reference, the LEDAcrypt document states around 4.2s, 0.8s, 2.3s for keygen, encaps, decaps on an Intel Skylake i5-6600 @ 3.6 GHz. The changes for pqclean (schoolbook mult of big polynomials and serialization) have made things slower. I think it's expected behavior considering  functest.c does 15 tests in total. Any ideas?
Valgrind makes stuff take a lot longer. It is expected to do a 10x-20x slowdown in execution. By itself, this is expected behaviour...
I think the best solution would be to set up CI differently, having lots and lots of build runners that will run the stuffs for us. However, it's kind of complicated to set that up with MacOS as well. I'll need to investigate how to do that â€“ and we'd probably need some funds to provision AWS or whatever boxes.
If schoolbook multiplication is the problem, a solution may be to replace it with more efficient algorithms: I have implemented mul1, Karatsuba and Toom-Cook-3 (word aligned) as described by the authors of [gf2x].
https://github.com/sebastianv89/PQClean/blob/hqc/crypto_kem/hqc-128-1-cca2/leaktime/gf2x.c
[gf2x]: https://hal.inria.fr/inria-00188261v4/document
Hi Sebastian, thanks for replying. This looks highly reusable for a more optimized implementation of LEDA. The reference implementation had Toom-Cook and Karatsuba, but with variable length arrays. Since pqclean does not allow this, an option would be to make them al constant and big or precompute all sizes for the specific parameters beforehand.
Since I wanted the implementation to serve as a starting point for optimization for a microcontroller, I chose the least memory consuming option. Also, a lot of time is spent on inversion in key generation, so I think it will still exceed the time limit.
