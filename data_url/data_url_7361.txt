The structures Ket and Bra are type-unstable. The field basis is not strictly typed. This:
is ambiguous, since any Basis can be part of a Ket, meaning that its fields are not type-stable.
The parametrisation must happen on the basis level, e.g.
In general this may have from very big to very miniscule impact on performance (it has to be measured), However, it hinders multiple dispatch greatly, as one cannot specialize methods on the type of basis (which is required for other changes) and has to use if branches with typeof() checks.
This will be the first change I will do, since it will allow everything else to be done. It is a pretty huge change though so it will take time to be done properly...
Unfortunately the story with CompositeBasis which has bases::Vector{Basis} is quite different. The container is abstractly typed which forbids inference, but fixing this problem is quite hard. I had the same issue here: JuliaDynamics/DynamicalBilliards.jl#30 and some answers are here: https://discourse.julialang.org/t/is-there-a-way-to-forward-getindex-for-tuples-in-a-type-stable-way/2889/22
This will be a much later fix though. First type-parametrization is in order.
Everything is integrated internally on vectors of complex numbers which is why this won't have much of an effect on performance. However, the save containers which are returned to users are not strictly typed, so the resulting data analysis afterwards is effected and not benchmarked.
I also do not think that the difference in performance will not be massive, however it will allow multiple dispatch on the basis type, which I think is super great for Julian programming.
I'm just sort of an interested observer here and have not dug into this package much, but I'm curious, is there some reason this effort was abandoned?  It does seem that at the very least the ability to dispatch on bases or at least the dimensionality of the Hilbert space as @Datseris suggested would be highly desirable.
It's true that I left this issue lying around for quite some time. It also took me some time to become familiar with the parametric type system. When I started addressing this in #234 I made the mistake of changing multiple things at once. After a while I noticed that I introduced some speed regressions, which were very difficult to backtrack due to the amount of changes. I started again in another branch https://github.com/qojulia/QuantumOptics.jl/tree/parametric-types2 where I will try to make smaller incremental changes.
So the bottom line is: it's not abandoned I'm just really, really slow in doing this.
Something else that made me curious: you mention that it would be useful to dispatch on the dimensionality of the Hilbert space. This is already implicitly included in the size of the .data fields of the different types. Combining wrong dimensions results in a dimension mismatch (even when dispatch on the bases makes sure they are of the same type) simply because you try to e.g. multiple two vectors of different size. Including the dimensionality would be similar to what StaticArrays do. I am not sure if it wouldn't be better to introduce types like e.g. StaticKet which has a static .data field additionally to the normal ones. Do you see any advantage in directly implementing this as a parametric field of the Basis type?
I haven't looked into this thoroughly enough to know whether it would really make much sense to dispatch on the dimensionality of the Hilbert space.  My main motivation for saying that is that I am slightly dubious about whether baking in a basis dependence all the way down to the level of type parameters is a good idea.  I mean, from what I've seen so far, it probably is a good idea since we are talking about things like Fock or momentum bases such that any basis rotation you are likely to implement will rotate into a basis of the same "type"; it just chafes slightly against my physics instincts (which comes from being a HEP theorist who sometimes had to consider things like basis independence, and not someone who has done any actual research-level work on actual applications of this package).
It's not obvious to me that you'd ever have to worry too much about static arrays here.  Again, I'm fairly ignorant about real world use cases for this package, but I have to imagine you'd be dealing with sparse arrays quite a lot.  It's also worth keeping in mind that StaticArrays have some rather painfully long compile times right now.  So, I'd say if you can think of a really good use case where static arrays are likely to help you a lot, by all means go ahead and implement them, but I suspect it won't be a priority for you.  You'll probably mostly be dealing with high enough dimensionality that they won't help you.
I think the case for introducing type parameters here is more "programming nicenesss" than it is performance.  Once you introduce basis parameters for the bras and kets I suspect you'll find that a lot of your code will "magically clean itself up" because you can then dispatch on the basis types.  I suspect this will come in very handy considering how different much of the code for handling e.g. Fock and momentum bases might be in some cases.  Multiple dispatch can be quite a thing of beauty once you really get going with it.  It took me probably about 18 months (coming from primarly C++) before I was at the point where I was writing "really good" multiple dispatch code, it takes some getting used to.
Another thing that might help with performance is making more of the structs immutable, but I suppose this is a completely separate topic.
I was just specifically asking about parametrizing the dimension since I hadn't considered that. Of course, dispatching on the type of the dimension is useless (it will always be integers). However, one can use non-type parameters here.
Namely, simply by defining the abstract basis type with a parameter
you can define subtypes like for example
Then we can really carry out all bases checks via dispatch, e.g.
The only "ugly" part here, is the @assert in the constructor of GenericBasis. However, there is no support for type constraints on non-type parameters (AFAIK). Please let me know if you have a better suggestion for doing this.
Also, I'm not sure in how far this is "abusing multiple dispatch" which is explicitly warned against in the Julia docs. I ran benchmarks, though, and could not find any negative effect when this is compared to the current master. So at the very least, we can clean up large parts of the source code by dispatch without affecting performance.
What I had in line was more along the lines of whether or not the Hilbert space is infinite dimensional, for example if you wanted to do an algebraic implementation of a harmonic oscillator.  I don't see any obvious benefit to using the specific dimensionality of finite dimensional Hilbert spaces as a type parameter unless you wanted to make use of StaticArrays.  That package is likely to be of limited usefulness in computational quantum mechanics as the most interesting problems are in high-dimensional Hilbert spaces (I would think? again my training is in QFT).
I probably shouldn't have mentioned the dimensionality, it was an offhand comment mostly motivated by my finding dispatch on the basis a bit awkward since bases are members of a continuously parametrized family ($SU(N)$ in this case).  Dispatch seems inherently discrete, and it would seem to imply a deeper distinction between bases than really exists.  That's probably not the best instinct here, however; these are the eigenbases of important observables and, seeing how the examples work, from a programming perspective dispatching on the bases would probably make a lot of sense!  Again, it's more "programming niceness" than anything else, you really feel the full advantages of Julia once you have lots of stuff to dispatch on.  Again, there are also potential performance issues to be resolved.
I don't think you are running the risk of abusing multiple dispatch in any case.  You can push it pretty far, what one should not do is, for example, use it as a Dict with hundreds of elements.  In the case of the Hilbert space dimensionality, in most cases you'd have a whole bunch of objects with a single Int parameter, it would be much the same as it is for AbstractArray and would not present any problem.
I have been going back and forth with this way too long already. I now settled for dispatching on the Basis type and leaving dimension checks to Julia. However, I added non-type fields to basis types that can be different while having the same dimension. This is done in #238 and I will merge as soon as the tests pass, so I am closing this. Also as a side note: benchmarks indicate a marginal gain in performance in some areas and no performance losses.
