After the recent release, it is a good time to revisit some foundational aspects of this effort so that we can continue to evolve and improve the design of the platform.
Here is a recap of a recent team discussion around the roles of ahead-of-time (AOT) and just-in-time (JIT) compilation, and how library-mode fits in on simulation platforms:
One thing I wanted to touch on was the role of library mode going forward. To recap, library mode is the mode of compilation that nvq++ provides that skips all generation of MLIR and lowering to QIR. Since we have the CUDA Quantum runtime (and this is critical, as it let's us build up a valid Clang AST so that we can generate the MLIR), we can enable a mode of compilation that simply falls back on Clang and produces a binary that links to the existing runtime shared library. Execution of kernels in this binary do not go through any QIR generated functions but instead directly queue up instructions in the library via the ExecutionManager abstraction / extension. These queued instructions are then applied to a user-specified backend simulator. This mode of compilation / execution is extremely useful, as the programmer can leverage the full extent of C++ within the bounds of the CUDA Quantum language specification. On simulated architectures, it may be that this is preferable to the AST Bridge / MLIR mode of compilation, in that it is a frictionless approach to quantum programming and should work well regardless due to the runtime nature of quantum circuit synthesis. The drawback is that programmers will need the foreknowledge that compilation and execution under this mode may lead to quantum kernel expressions that are not executable on physical architectures. We covered this extensively in our discussion and noted that as hardware improves, our implementations in the AST Bridge can also continue to improve, enabling more expressiveness in CUDA Quantum kernels that ultimately target physical QPUs.
Another related concept here is differentiation of AOT and JIT compilation in the context of quantum kernel programming. We discussed the likely requirement that some quantum kernels cannot be fully compiled / optimized ahead of time due to qubit counts potentially not being known until runtime. CUDA Quantum is unique in this respect, in that the kernel expressions really represent quantum circuit templates, and these templates (just like in C++ with template types), must ultimately be specialized / synthesized with runtime-known constants. The CUDA Quantum runtime will need some mechanism for online just-in-time compilation that incorporates runtime constants currently known and synthesizes optimal code at runtime that can be executed on the target architecture. There will likely also be opportunities for AOT compilation and we should keep the platform open for these opportunities.
Action items going forward: pull back on the strict requirement for AST Bridge MLIR generation for simulation platforms, defaulting to library mode in this context. This will enable frictionless quantum programming in C++, with the caveat that some programs may not be executable on physical architectures. We will work to provide an AST Bridge - related preprocessing step that can report warnings / errors to the programmer in this regard. Next, we will continue on with our compiler work (decompositions, optimizations, etc.) that are usable from the JIT compilation context. We will validate that output QIR targeting physical architectures is fully specification compliant (Base, Adaptive, etc).
We will move away from the -qpu flag and instead start using -target which will better encapsulate the target processor architecture as well as the required runtime quantum_platform subtype.
