One might wonder why carry-in is measured before arithmetic gates. This is due to shoehorning the design of the MOS-6502 for VM6502Q, as is the general proliferation of arithmetic variants with flags. Ultimately, this works for VM6502Q. However, I could not think of a unitary way to satisfy the expected behavior for that architecture's carry flag, in arithmetic. (Not measuring the carry-in would double-up certain inputs to map to single outputs.)
However, the MOS-6502 is not the only possible architecture, obviously. If carry-in and carry-out bits were separate in arithmetic operations, there would be no such problem preserving unitarity. The base case would be basically a cheap full-adder simulation. However, by increasing the intermediary length, we can "snake" our full-adders into cheap-to-simulate chunks, for maximum optimization in QUnit. I anticipate 3 cases in QUnit for each arithmetic gate: fully bit-wise separated, fully entangled, and optimized with these separated carry-in/out variants I'm talking about.
This is another to-do item, for me, unless someone wants to jump on it. See https://github.com/vm6502q/qrack/tree/qunit_arith_optimize for work I've started doing optimizing QUnit arithmetic, and I will be adding these separated carry-in/out "INCCIO" and "DECCIO" methods over the weekend in this branch, as well.
The combination of QUnit arithmetic optimizations and Draper addition in QInterface serve the role this intended. See #209.
