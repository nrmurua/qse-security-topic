The following should not raise an exception. It should produce a circuit which, when sampled, samples a=0 and b=1.
Failing to measure the empty pauli string is sort of like failing to search for matches to the empty string. It's a corner case but it should still work.
Since cirq.PauliMeasurementGate currently decomposes into a cirq.MeasurementGate, this would require us to also extend support for empty qubits to cirq.MeasurementGate so that cirq.MeasurementGate(key="a") samples a=0 and cirq.MeasurementGate(key="b", invert_mask=1) measures b=1. Although, for now invert_mask expects a tuple with 1 entry per qubit. In this case, the number of qubits are 0 so that breaks down.
Another approach would be to not change the interface of cirq.MeasurementGate and instead have a special decomposition / override the _act_on_ protocol on PauliMeasurementGate here to achieve the desired effect, but from a quick glance it looks like SimulationState.measure also expects a non-zero qubits parameter to be measured.
We can also consider leveraging the newly added capabilities of allocating a new ancilla qubit within _decompose_with_context_  to perform the measurement using a clean ancilla and that would allow us to reuse all the existing infrastructure of making measurements on non-zero qubits; at the cost of a performance penalty.
Further investigation is needed to decide what's the best way to achieve this without breaking backwards compatibility and hopefully with minimal API changes.
