When executing a circuit with a CSWAP gate that was transpiled at optimization level 3 and then converted to and from QASM, the following error is produced:
All three elements (CSWAP in circuit, transpilation at optimization level 3, QASM conversion) are required to cause the error, otherwise it seems to work fine (or at least run without producing an error).
Run the following code:
The circuit should execute normally without error.
No response
Following is a  temporary fix for your code. Please use quantumcomputing stackexchange or qiskit slack for more support.
@ljkitt: thanks for the report.
The problem here is that saving Qiskit's circuits to OpenQASM 2 is a bit of a lossy process, and one place we lose information is in saving "unitary" gates.  Qiskit wants to have the matrix as part of the gate (a param, in Qiskit land), but we can't represent that in OpenQASM 2, so we elide it and just define the gate in terms of its decomposition.  When we reload it, we produce a gate that's called unitary again, but is a "custom" gate rather than our built-in one.  Aer, being a simulator, can interpret far more of Qiskit's built-in gates directly that OpenQASM 2 was designed to represent, so after round-tripping through OpenQASM 2, some information gets lost, and Aer's trying to load unitary as if it's the gate Aer knows about.
I suspect that the "neatest" course of action here might be for us to ensure that the OpenQASM 2 dump of the unitary instruction renames it as well, so reloading from the file will not cause a gate-name mismatch .  You still wouldn't be able to load the circuit with Aer, but that's somewhat expected; OpenQASM 2 is not a lossless serialisation or storage format for Qiskit circuits.  If you're looking for a method for storing Qiskit circuits longer term, you might want to look at the qiskit.qpy module.
As a potential workaround, however, you might want to consider transpiling for a real machine, and then passing the result to Aer, rather than trying to transpile for Aer directly.  Aer is a simulator, so when we transpile for it as a backend, the transpiler is allowed to skip large parts of its synthesis; at optimization_level=3, it mostly just collapses things into unitary matrices, then since the "backend" supports them, it doesn't need to bother turn them into actual gates.  If you have a real backend, you can do:
and that will work provided that Aer supports all the instructions of the real backend.  For most hardware, that will be the case.
@Raghav-Bell: thank you for trying to help.  When you're responding to somebody's bug report, remember that the script they give us is a minimal reproducer, not necessarily every part of their workflow - they've likely stripped out all the unimportant steps in the middle, just enough to show us something breaking.  That doesn't mean their code is wrong, just because it looks a bit surprising.  It's fine for people who are getting a surprising error message to file it as a bug here (though our Slack channels are also a good place for getting help - thanks for giving the link).
In your answer: CSwapGate is a Gate, which is a subclass of Instruction so it's completely fine to pass this to QuantumCircuit.append. Calling execute after transpile is unnecessary and will typically undo the transpilation; execute(qc, backend) is equivalent to backend.run(transpile(qc, backend)), but offers far less control over the inner transpile call because it's just a thin wrapper to help people get started faster.
