The OpenQASM3 paper arXiv:2104.14722v1 defines the content of the file stdgates.inc in the section 4.1.1 Standard gate library p13, similarly to qelib1.inc, the OpenQASM2 equivalent, in the paper arXiv:1707.03429, section 3.1 Quantum Experience standard header p10.
The OpenQASM2 experience tells me that the lack of detail about its formal meaning and stability of the standard library content can be problematic. For example, several components assumed that the qelib1.inc will always preserve backward compatibility (new gates can be added, but they cannot be removed). You can see the discussion here:  Qiskit/qiskit#6125
Similarly some components (like qiskit-terra itself) only use the file to extend the gate namespace but ignores the body (a la opaque gate). A change in a definition have no effect at all.
In order to avoid similar issues, I suggest to be more explicit on the assumptions around stdgates.inc and its potential formal semantic of including the file. Consider that extending the default global scope (like in the IBM Quantum Experience) will be a needed use case in the mid-term future.
In OpenQASM3 there is only one built-in gate at the language level: U. We have written stdgates.inc in the paper so that including that file will provide backward compatibility for many OpenQASM2 programs.
You seem to be poking at two issues: (1) formal meaning and (2) stability. I'm not sure I follow what is missing on (1). The formal meaning of include "stdgates.inc;" is equivalent to #include in C, i.e. it is as if one copy-pasted those lines of code from another file into the current source file. On (2), I concur that changing the meaning of symbols in standard libraries is disruptive and should be avoided. However, it is going to be up to OpenQASM3 implementers to provide their own libraries. The version in this repository can serve as a reference to implementers, but I don't see what we can do to enforce constraints on that.
Thanks, this unfolding is useful!
(1) I probably used the term formal wrongly. If we take strictly that include works like the directive in C, that means that the compiler needs a preprocesor to do the inlining and then parse the result. This seems inefficient. Moreover, it makes "standard" gates indistinguishable of the custom gates. For OpenQASM2, Qiskit made the unilateral assumption that the gates in qelib1.inc were "standard". That means that they are not being parsed and namespace is extended with Qiskit standard gate objects that are mapped to the gate names in that file. The underling assumption is that standard gate definitions (their decomposition in other gates) are just a way to referred to their unitary matrices. In other words, the standard gate swap refers to the object SwapGate and how is defined in qelib1.inc turned irrelevant, because the convention was that we were referring to the same meaning. However, a swap gate declaration out of qelib1.inc means that that decomposition have to be used, and no other. These mechanism were never explicit and is what I referred as "assumptions".
(2) Does it means that stdgates.inc is no different that any other library? That would mean that no assumptions can be made about it and it should be parsed and analysed always?
If there is no shortcuts about meaning of a declared gate that means that is not easy to "match" the those gates with other representations. In other words, the only way to know that gate swap a,b { cx a,b; cx b,a; cx a,b; } and SwapGate (the Qiskit object) is the same is by calculating the unitary of both and check for equivalence? Would it be okey to "precompute" the matrix for some gate declarations based on... the name? the hash of its declaration body?
In other words, the standard gate swap refers to the object SwapGate and how is defined in qelib1.inc turned irrelevant, because the convention was that we were referring to the same meaning. However, a swap gate declaration out of qelib1.inc means that that decomposition have to be used, and no other. These mechanism were never explicit and is what I referred as "assumptions".
I can personally confirm that this tacit assumption is quite surprising when one starts to explore the Qasm2 implementation in Qiskit!
In other words, the only way to know that gate swap a,b { cx a,b; cx b,a; cx a,b; } and SwapGate (the Qiskit object) is the same is by calculating the unitary of both and check for equivalence? Would it be okey to "precompute" the matrix for some gate declarations based on... the name? the hash of its declaration body?
In view of the intent of OpenQASM 3 to move ahead with the technology, it is unacceptable to take the position that these gates are effectively part of the language. It's also unacceptable to demand that conforming implementations actually interpret the standard source for these well-known operators as part of every compilation.
So maybe the answer is to relax (or interpret) the role of stdgates.inc so as to allow a #pragma predefined to appear textually in stdgates.inc, i.e., allow an implementation to declare #pragma predefined h before the definition of h in stdgates.inc if, in fact, the Hadamard gate is predefined in the implementation's translator.
In this case, any definition in any user file of  gate h ... would be valid and would indeed be the prevailing definition immediately upon being encountered were the #pragma predefined not to appear in that translation unit (or perhaps #pragma predefined can be described as only in scope for the next immediate appearance of a gate definition and raise an error if the next gate definition encountered is not the name called out by the #pragma predefined immediately above).
So maybe the answer is to relax (or interpret) the role of stdgates.inc so as to allow a #pragma predefined to appear textually in stdgates.inc
There does not appear to be anything to preclude this mechanism in any of:
Certainly the latter point could lead to confusion if a user believed that altering the definition in stdgates.inc would alter the compilation unit, but equally certainly the presence of a #pragma predefined would alert the user to the danger.
