In https://github.com/ProjectQ-Framework/ProjectQ/blob/develop/projectq/ops/_command.py on line 242, "add_control_qubits()" sorts the list of control bits by "id" on every Command instance, as far I can tell. However, "uniformly controlled rotations" appear to depend on an arbitrary control bit order, (not strictly ordered by "id,") in order to vary the permutation counting order of their control bits. I suppose it's possible to rearrange uniformly controlled rotation angle order to achieve the same end, but I don't think this is intended, for the behavior of uniformly controlled rotations.
Additionally, I've tested that unit tests fail if the ordering on line 242 in the definition of Command is removed, including for operations like logical "or."
Is this intended behavior? If I'm trying to work with ProjectQ, should I assume that uniformly controlled rotations should always count permutations from lowest to highest "id," or is this a bug?
How are you using the uniformly controlled rotation gates? Could you send a piece of code that fails?
I agree that uniformly controlled rotations (such as UniformlyControlledRy) depend on the ordering of the control qubits. When you execute
both the controls and target qubits are saved in the variable qubits in a Command object, which does not reorder qubits (because that would be wrong). UniformlyControlledRy are derived from BasicGate whose __or__ operator doesn't use add_control_qubits(). Only ControlledGate or with Control add qubits to the control_qubits variable of a Command.
Alternatively, one can check the decomposition of controlled gates which indeed shows that the "control qubits" of a uniformly controlled rotation are saved in cmd.qubits[0] and not cmd.control_qubits.
If you remove qubit reorder for control_qubits in a Command, that can certainly lead to unit tests fail. Comparing commands relies on the fact that control_qubitsare ordered in a unique way. That can lead to assertions in unit tests fail. Also a LocalOptimizer will not cancel certain gates which it otherwise could.
Please let me know if you have further questions or an example code that fails.
Thank for the quick and useful response. The problem I ran into is with the unit tests for the uniformly controlled rotation decompositions. The problem seems to be with the use of with Control to reimplement a reliable (slow) implementation of the uniformly controlled gates to compare the decomposition results against.
In the branch I'm on, for integration with the Qrack simulator, I see this in https://github.com/ProjectQ-Framework/ProjectQ/blob/df699088a0c9c621a109bdfd316a1a1fcfe8c066/projectq/setups/decompositions/uniformlycontrolledr2cnot_test.py:
The Qrack simulator has direct support for uniformly controlled gates, now, which pass your unit tests and Qrack's unit tests. Direct support in Qrack matches your decomposition result, as well. However, if this slow_implementation() of uniformly controlled rotations is compared against the results of decomposition on top of the Qrack simulator, specifically, the test fails, and I notice that the above implementation uses with Control, which will reorder the bits.
Maybe the issue isn't with the uniformly controlled gates, then, but just the use of with Control to implement an alternative uniformly controlled rotation operation in the unit tests. I believe this is in the head of your development branch, as well.
This slow implementation is also correct. Note that control_qubits are also not reordered.
It applies each angle individually for index. The with Compute sections sets all bits to 1 for that particular index. with Control(eng, control_qubits) just needs to check that all qubits are in state 1, hence reordering is allowed.
In the abstract, that makes sense, but I'm not sure that there aren't unanticipated side-effects. What I know is, if I call the direct Qrack support for uniformly controlled gates, and compare the results to your decompositions on top of the Qrack simulator, the two match. However, the same result does not match your slow_implementation(), here, when Qrack is used as the simulator in general. The Qrack unit tests for uniformly controlled rotation also pass.
I have spent significant time analyzing whether the issue is within Qrack, but we have a very general set of unit tests, and I'm not sure why the Qrack simulator's direct support matches your decompositions on top of the same simulator, but not the slow implementation on top of it. Hence, I opened this issue. Perhaps you can advise, please?
(The Qrack integration passes almost all of your unit tests for operations it intends to support, at this point, and SimulaQron unit tests, and the library's own unit tests, with the exceptions of basically this and state preparation, as far I can I tell. Hence, I've added direct support in the simulator for uniformly controlled rotations and state preparation, which lead to a full pass on SimulaQron's unit tests and yours, but I want to understand what's going wrong.)
I'd advise you to find a small example code where things differ.
Using e.g. a CommandPrinter allows you to output the gate sequence for both the slow decomposition and the standard decomposition rule. So you can test these equivalent gate sequences in addition to your direct implementation.
I would also check if Qrack fails because of small precision differences.
Thank you, again. I was not aware of CommandPrinter.
I won't have an opportunity to work on the code until tonight, but I already know it's not a small precision difference, in this case. Qrack does lead to differences in any operation in about the 11th decimal place for probability, out of 1.0, compiled for single float precision, but the difference here is the slow_implementation returning a 1.0 amplitude for a permutation basis eigenstate, whereas all the other mentioned cases tested apply a significant rotation.
Off the top of my head, I'll check the application of multiple control bits in the Qrack wrapper, but this hasn't been an issue anywhere else, if that case comes up in the other tests. I'll have more information within the next 12 hours.
Now that I can look at the code again, the example code that led me to open the issue is in the same blob I posted before: https://github.com/ProjectQ-Framework/ProjectQ/blob/df699088a0c9c621a109bdfd316a1a1fcfe8c066/projectq/setups/decompositions/uniformlycontrolledr2cnot_test.py
Line 142:
(My white space might not be identical in the comment, but this is not the issue.) The top branch is the direct implementation of the uniformly controlled rotation in Qrack, which works fine, and matches the ProjectQ decomposition result in the same unit test. The problem is that, with the Qrack simulator as back end, the second branch returns an unrotated permutation amplitude, exactly 1.0 for an amplitude.
I am attempting to debug this, right now, and I'm sure I'll ultimately figure it out. If the problem is in the Qrack wrapper, I don't expect you to be able to speak it, but the problem would be specifically in slow_implementation() running on top of Qrack, and not in the decomposition running on top of Qrack, nor in the direct implementation of the gate in Qrack.
When I use CommandPrinter, no matter if I specifically reorder the control bits by accessing them one at a time by index, it gives me shorthand like this:
(...the Qrack OpenCL device list prints, and then...)
(...and I have truncated the rest of the long output.)
For CCCRy(0.5) | ( Qureg[1-3], Qureg[0] ), is that simply a quirk of the printer shorthand, if I l specifically rearrange the control bits manually, or is it telling me that it's really sorting the list of control qubits, by the Qureg[1-3] part? It seems to print that way no matter how many qubits I give as controls and in what order I specify them.
So you can reproduce, to be totally explicit, I changed the slow_implementation() definition to this:
Then, running the unit test function on the command line, with a fixed number of control qubits, I rearranged the controlled gate application line several ways with several qubit counts, similar to this:
It always prints the ordered shorthand, however. Is that just shorthand, or is it true to the actual input bit order?
I stripped down your original unit test to produce an example that can be run directly from the Python interpreter, if the head of your master branch is installed. (You don't need the Qrack branch, for this.)
https://gist.github.com/WrathfulSpatula/6cbde1a428b0fa554f4af6f26e8b97a8
I just realized that if I change the basis_state_index value to 2, though, it does fail, which is the result it should give. I think the controls are both zero, in the original test, such that swapping them might make no difference. So, this might not be the issue. Please take a look and confirm that, though, if you can.
The same script makes it apparent that the Qrack integration, solely, suffers from the issue on this point. Thank you for your attention and advice, because it has actually helped me immensely. I think I can close this issue.
No problem, you are welcome.
