I've noticed I can append 1 element to the excitations array before decoding it and the call to decode runs without throwing. Appending two elements fails. Removing one element fails. But appending one element runs.
This is probably because you have one boundary node, and I leave it as optional as to whether you supply the value (1 or 0) of a boundary node. As a result I don't throw an exception if self.num_stabilisers <= z.shape[0] <= self.num_stabilisers+len(self.boundary)). If the parity of a syndrome is odd, PyMatching flips a boundary node anyway. Since I just extract indices of nonzero elements of the syndrome, if you provide a syndrome of length self.stabilisers, the last len(self.boundary)) elements are essentially zero-padded initially. I can make this clearer in the documentation.
If I were you I'd be strict about the number being exactly right, since off by one errors indicate potential mistakes, but I'll close since it's working as intended.
