From what I understand of organising C libraries (correct me if I'm wrong), if we want to provide .a or .so files, we need to also export some include/ directory where the api.h files that expose the API of the specific schemes are available.
It should probably look as follows, from what I learnt from other project:
Although this seems like a lot of overhead, we may be able to just generate it in the Makefile; just copy over all the api.h files.
Doing this would then also allow clang-tidy to verify that the #ifdef header guards are correctly namespaced. The llvm-header-guard linter gets slightly tripped up by us doing local includes everywhere but also specifying the include path via -I.
But we're not really providing a library.  We're providing a collection of source code that people can pull into their libraries.  We do build individual components for testing purposes, but we're not delivering a library per se.
I agree with Douglas and Peter that the api.h files should live in the implementation subdirectories; this makes it much easier for people downstream to integrate one implementation (i.e. one subdirectory) by itself.
I also agree that, as we're not creating a library, an include directory seems unnecessary. I'm not convinced we need to actually build .a files at all (but that is perhaps a separate discussion).
Shall we close this issue and leave the api.h files where they are? Perhaps we can fix the llvm-header-guard by changing the way we specify the include path - simply throwing everything in using -I was a quick fix to get basic functionality tests running; I didn't put much thought into that.
I also agree that, as we're not creating a library, an include directory seems unnecessary. I'm not convinced we need to actually build .a files at all (but that is perhaps a separate discussion).
Yeah, if we're not doing that, then I would agree that there is no need. If we do want to build .a or .so files, I think having something like include/pqcrypto/crypto_kem/kyber768/clean/api.h is required. Meanwhile I also recognise the need to keep things as simple and flat as possible.
But I am quite happy to close this issue in favour of not worrying about building library artefacts for now.
Oh, and on llvm-header-guard: it does not seem configurable whatsoever. I've tried to use -iquote instead of -I, but that did not solve the problem. It seems LLVM's static analysis tools were designed around CMake, specifically its compilation database.
I did find some awk script in a Google project somewhere that seemed to do the same thing for the most part. We could just use that.
