It's known from AdS/CFT that the out-of-time-ordered correlators (OTOC) is considered as a measure of
quantum chaos. In SYK model the OTOC gives the Lyapunov boundary (boundary of quantum Lyapunov exponent), recently it's pointed out that the second RÃ©nyi entropy is related to OTOC (see ref. 1). It is interesting that if an OTOC generating by the order parameters of the model, then this OTOC can represent the dynamical phase transition in the model (a non-equilibrium process), and even give the quantum critical points (see ref. 2). So it's interesting to implement OTOC in quimb.
Consider we have a spin chain, one can see that the OTOC generating by a pauli operator or spin operator is an important case, in this issues i will push my option to calculate the OTOC which is generated by a local pauli 'z' notation.
In fact, the OTOC on Transverse-field Ising chain is a very good example, and the results can be compared with the results in ref. 2. Let's begin with the repeating the results in this paper.
First, we need to crate a up-state (with PBC) like in this paper, for this purpose, we need to do a little modification (add the PBC case) to the following two functions: MPS_product_state(arrays, **mps_opts) and MPS_computational_state(binary, dtype=float, **mps_opts).
Now, the up-state with PBC can be given as following
up_chain = '0' * L
psi0 = MPS_computational_state(up_chain, cyclic=True)
then we generate a MPO of local pauli 'z' notation as following
Here the reason why we add a 'phase' option to 'MPO_local_pauli_z' is that in OTOC calculation we need to apply the i \sigma^z_n operation (which with a phase shift i \pi/2) to the MPS.
Then we can calculate the OTOC
Then we just need to calculate OTOC for up transverse-field Ising chain as following
H = qtn.NNI_ham_ising(L, j=4, bx=1, cyclic=True)
H_back = qtn.NNI_ham_ising(L, j=-4, bx=-1, cyclic=True)
F = pauli_z_OTOC(L, i, t, psi0, H, H_back, dt=1e-2)
&
H = qtn.NNI_ham_ising(L, j=4, bx=3, cyclic=True)
H_back = qtn.NNI_ham_ising(L, j=-4, bx=-3, cyclic=True)
F = pauli_z_OTOC(L, i, t, psi0, H, H_back, dt=1e-2)
and check the result by comparing with the result in paper
Notice: first thing we need to check is the translation invariance, just calculate OTOC on all sites like
F_n = [] for n in range(1,L+1): F_n += pauli_z_OTOC(L, i=n, t, psi0, H, H_back, dt=1e-2)
and the values of OTOC on different sites should be the same.
@TanTsiChen thanks for the contribution. In order for me to review this and (possibly merge it) you will have to create a pull request - then I can checkout and test the code properly.
If you haven't done this before, that roughly involves:
There is a very good guide here. It's for the xarray project but all the information translates pretty well (to almost all open-source projects including this one).
@TanTsiChen it look's like you were on the right lines. I haven't studied OTOCs but from inspecting your code does this function work for you?:
It's a little different from your code, phased is not a option. The calculation procedure is as the following:
Ah OK I have updated the function.
Ah OK I have updated the function.
so, you decide to put this function into which module?
I consider that it's best to put into TEBD, as an application of TEBD
Closed by #10
