Currently liboqs uses OpenSSL as the default backend for low-level support algorithms, such as AES and SHA3 if the OQS_USE_OPENSSL build flag is ON; otherwise it will use the bundled implementation of those algorithms. While integrating liboqs in GnuTLS, we found neither of them optimal: it is not desirable to bring in OpenSSL as a dependency[1], while we also don't want to have the same algorithms implemented in multiple places. Therefore I would suggest providing a way to make those algorithm implementation pluggable at either compile time or runtime.
More concretely, what I have in mind is something along the following lines:
This is similar to the approach taken by tpm2-tss[2].
Thanks for this proposal. Eliminating this OpenSSL dependency definitely makes sense for liboqs integrations to other crypto libs.
I wonder though, to which level of algorithm detail this needs to go: Is a distinction AES/SHA2/SHA3/RAND sufficient? Or should there be "redirection stubs" for all detail APIs e.g., as currently documented here for AES -- and equivalent for the other common crypto elements? Would you want to make a strawman proposal based on how you could envision a mapping onto GnuTLS APIs?
In my personal opinion, it would be beneficial if this could be a compile-time switch (maybe macros based on the current common APIs, such as OQS_AES256_ECB_enc_sch?) as otherwise the currently single, standalone library liboqs would be split into different pieces/shared libs. This could be inconvenient for (or even be mis-handled by) users of the common case where OpenSSL is providing the "production quality" common code for standalone liboqs applications; oqsprovider surely could be adapted to any sensible configuration -- although rather clearly none other than an OpenSSL config makes sense for an OpenSSL provider.
XMLSEc project https://github.com/lsh123/xmlsec uses multibackend scheme with compile-time choice, and I can't say it's easily maintained by a person foreign to the project but it's definitely not the only possible architecture
Thanks for the prompt response!
I wonder though, to which level of algorithm detail this needs to go: Is a distinction AES/SHA2/SHA3/RAND sufficient? Or should there be "redirection stubs" for all detail APIs e.g., as currently documented here for AES -- and equivalent for the other common crypto elements? Would you want to make a strawman proposal based on how you could envision a mapping onto GnuTLS APIs?
Yes; I think that'd be sufficient. Let me try to create a PoC.
In my personal opinion, it would be beneficial if this could be a compile-time switch (maybe macros based on the current common APIs, such as OQS_AES256_ECB_enc_sch?) as otherwise the currently single, standalone library liboqs would be split into different pieces/shared libs.
One idea to make this transition easier might be to delay the loading of libcrypto.so.* with dlopen, so the application can swap the implementation before OpenSSL is actually being used. I guess that wouldn't be too hard, as I see only 18 functions from libcrypto.so.* are used.
One idea to make this transition easier might be to delay the loading of libcrypto.so.* with dlopen, so the application can swap the implementation before OpenSSL is actually being used. I guess that wouldn't be too hard, as I see only 18 functions from libcrypto.so.* are used.
Agreed, there's not so many entry points. Would a dlopen-based solution work equally well for static and shared builds of the lib? On all platforms? Looking forward to the PoC/PR!
