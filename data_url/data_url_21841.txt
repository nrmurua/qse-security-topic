https://drive.google.com/open?id=1ZyI_0S0IJ-oKc15RgisTW4FABeBQvuub
Or a legitimate bug in the stack. Could you addr2line it?
This is hexdump(pc) crashing on the first println().
@whitequark
also: https://hastebin.com/xabopifuwu.go
I also had one occasion where Sayma crashed after loading HMC7043...done
No, this is definitely memory corruption. Look at this line:
It started printing a memory dump for a hardware exception in this function:
and crashed. The UART write function looks like:
so it crashed somewhere between the space after @ and the leading 0 of the pointer 0x. The fmt/mod.rs:1096 line looks like:
so the arg.position is wrong, and arg.position is generated by rustc. The specific value stored in it, 0x4006af98, would never be written there even if rustc or linker had a bug, since there is no relocation pointing at that word and no way for rustc to put a pointer there.
The only place where 0x4006af98 is loaded is:
and located at that address is a " ...locked":
Here's the annotated assembly for hexdump:
As can be seen, there is only a 3-instruction window where r3 is 0x4006af98. Assuming no CPU bugs this implies that the store that happens right after hmc830 locks (there are no other RAM stores in the loop that polls the lock) misfires and it's written somewhere in rodata instead of stack.
Hope this helps to pinpoint the issue.
@whitequark is there anything useful in the second crash I posted?
@whitequark @sbourdeauducq How do we go about debugging this?
Can we hook up gdb to Sayma? Or, do you have a better/different idea for tracking this down?
If it's memory corruption, gdb cannot help.
@whitequark is there anything useful in the second crash I posted?
Hmm. What's at PC definitely doesn't look like code:
It doesn't look like data either:
What it does look like is line noise with an average of ~1 bit per nibble set.
Can we hook up gdb to Sayma?
I have the code for doing this but I do not believe it will be useful in any way here.
Remnants from the memory test at boot? Maybe clear all sdram or set it to some known value after testing it.
But either way. Probably just noise. 0x440249cc is also pretty high.
So....what do we do about this?
we can run more advanced memory test that scans all memory.
I've noticed that on one of our boards the memory test does not pass anymore. And on another board it simply hangs without warning. We didn't debug it yet.
I've noticed that on one of our boards the memory test does not pass anymore
That's interesting. Does unplugging the RTM make a difference? It would be great to try to reproduce this in the simplest possible configuration.
NB I get the impression that there are some build-build variations (vivado issues?) so if you find a build that reproduces this reliably, please post it!
@hartytp We'll check without RTM tommorow. We used the same build on several boards and only two showed such issues so it's more likely to be some kind of hardware failure.
üëç
@marmeladapk we should load some old version of the gateware. Both boards used to work. It's hard to believe they got broken by themself.
Here is my thinking on this:
How does that sound?
hmmm...it seems there is definitely a memory corruption issue that's not caused by the HMC7043 #1068 (comment)
Running this as a startup kernel crashes Sayma in 100% of the cases:
I have not found yet what exactly crashes; making minor changes tends to make the crashes disappear.
Symptoms of the crash vary between reboot, freeze, and garbage printed on the UART.
According to Joe the crash also occurs when this is run over Ethernet.
While leaving Sayma idling, I see panic at runtime/main.rs:321:13: exception Alignment at PC 0x4002ee84, EA 0x4015a184
https://hastebin.com/efofewifey.go
Startup kernel is: https://hastebin.com/ilawajuqog.py
Running this as a startup kernel crashes Sayma in 100% of the cases:
The same kernel does not crash the KC705, so it's not a compiler or runtime problem.
Another data point.
Making a reboot loop by jumping to the bootloader right after HMC830 and HMC7043 initialization does not crash; the board went on for over an hour and behaved normally.
Moving the jump after the DAC initialization:
causes insane behavior in parts not related to the DAC after a few reboots, e.g.:
(the errors are varied; sometimes it's "Memory test failed" as above, sometimes it's "illegal instruction" during serwb initialization, etc.)
@hartytp @gkasprow @jbqubit @jordens Can you reproduce those "reboot loop" results?
First, before any modification of VCCINT, please remove two big 0R resistors on the board bottom. This will disconnect the FPGA core from SMPS.
Xilinx does not seem to recommend powering the FPGA without VCCINT (and the power sequencing will still enable the other supplies when those resistors are removed). Are you sure this is OK?
Yep, short pins 1 and 4 of the Exar programmer. This will disable the Exar Enable pin.
However wrong sequence won't break the FPGA, the leakage current may be higher.
After making sure that VCCINT is 0.96V
The 120k resistor will either give 1.03V (3.3k+3.3k) or 0.94V (3.3k+2k), or am I doing the computation wrong?
Anyway I already removed R243 and R244 on one of my boards to measure them and try to understand what is going on with the power supply. I intend to replace them with 3.3K and 2.7K, and keep R251 at 10K. Is that OK?
I do not understand what the 10R resistor is about. The schematics in Github also do not have R508. Can you update them?
Also, can you confirm the position of R243 and R244 on the board? I'd like to doublecheck.
"VDRINT is data retention VCCINT voltage (below which configuration data might be lost) 0.82 V"
The resistors on your boards were modified to produce 0.91V supply. The sum of them gives roughly 5.1k.
So with current configuration addding 120k does the job.
You can of course leave the 10k and modify R243 and 244 to get 6k and achieve slightly more than 0.95V but within the limit.

@gkasprow Can you do the test on your board as well (confirm that the crash-kernel crashes it, fix VCCINT, then confirm that it no longer crashes)?
When running idle kernel (artiq 8118829):
after crash I get <0,89 V on VCCINT - measured both by XADC and using multimeter. After restart VCCINT is normal during bootup and when Sayma hangs it drops.
I recreated this on another Sayma AMC.
@jordens Running this idle kernel:
VCCINT is also below 0,9 V.
Let me explain why there is such strange feedback loop in the VCCINT design.

R508 can be mounted to compensate DC drop on the traces.
I did simulation of the power delivery to make sure it does not exceed 50mV at 10A and to not exceed current density of 50A/mm2.
In current setup with  local feedback we measure 0.89V at the FPGA decoupling capacitors with FPGA running SAWG. This is far too little to keep FPGA functioning.
So you'd ask why I did not mount the R508? And why there is R507 used?
R507 is safety feature, to make sure the loop is closed when for some reason R508 was removed. Why would somebody remove R508 - to test if the converter works correctly. To test it one removes R315 and R316.
I also wanted to make sure that such remote sensing works correctly and use it when needed.
The buck converter has DCAP magic which does not need compensation so we can use this remote sensing feature.
I installed R508 (short circuit) and it looks like it helps. The voltage at the FPGA is 0.925, the VMON show 0.91. So suggest to increase the output voltage by 25mV.
On two AMC boards memory errors disappeared.
And crashes. Idle kernel I posted earlier is running over 10 minutes now without any hiccups.
Even with DCAP, isn't there enough compensation (i.e. AC feedback) happening through C293+C430 anyway?
yes, it has local compensationAC  loop and DC feedback loop.
Here is R508, on bottom side under the DC/DC converter, close to these two big 0R resistors

@gkasprow note that the silk screen for R315 is in the wrong place then.
@gkasprow can you confirm that the rework required to get the proper 0.95Vccint is:
@gkasprow can you confirm that's all correct, and I'll modify my board...
The sum of them gives roughly 5.1k.
I had measured 3.3k and 2k, which gives 5.3k.
No more crash after:
Also note that measuring R243 and R244 requires desoldering them.
Eventually, it's a risky rework...
Whoo!
This has run for quite a while without issue, when it used to crash 100% of the time almost immediately.
Great catch on this one @sbourdeauducq
Shorting R508 does not affect testing with R315 and R316 open. R507 takes care of that.
Well, in the worst case when the feedback loop is open, you get VCCINT connected to 12V through 10R - doesn't sound very safe to me.
The worst case would be with the feedback loop open and R315/R316 placed. But if they are not placed, the resistor protects the FPGA just fine. It fails open after limiting the VCCINT current to <1.2A during its short but fulfilled life. You won't be seeing 12V there.
VCCINT current can be as low as 998mA (see "Quiescent VCCINT supply current" in the datasheet). Then the FPGA could get 2V - probably less than that, since likely the current increases with VCCINT, but that still exceeds the absolute maximum of 1.1V by a large margin.
If you are worried the resistor might survive  longer than the FPGA does in tests where you can't ensure feedback loop closure, then you should definitely depopulate R507 together with R315 and R316.
