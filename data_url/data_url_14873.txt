The rz gate seems to have the wrong matrix representation when imported from an OpenQASM 2 file. In OpenQASM 2, the rz gate is defined to be rz(phi) = u1(phi) = diag(1, exp(i*phi). Specifically, it is defined in the "qelib1.inc" header file as: gate rz(phi) a { u1(phi) a; }, which suggests it should have the same matrix representation as u1.
However, it seems to have the matrix representation rz(phi) = diag(exp(-i*phi/2), exp(i*phi/2)) instead, differing by a (global) phase of -phi/2. I'm aware that the original paper says rz is equivalent to u1 "up to a global phase", but the code in the header file suggests that they should actually be identical.
Note that the definition which differs from u1 by a global phase of -i*phi/2 is used in OpenQASM 3. In particular, in the "stdgates.inc" header file, rz is defined as: gate rz(lambda) a { gphase(-lambda/2); U(0, 0, lambda) a; }. The presence of the gphase(-lambda/2) here seems to suggest that the matrix representation of OpenQASM 2's version of rz should not have this global phase.
(The u1 gate is defined as gate u1(lambda) q { U(0,0,lambda) q; } in both header files.)
The code below outputs the matrices for rz, controlled-rz, u1, and controlled-u1, respectively.
My expected output is:
The actual output is:
What's strange is that the controlled-u1 gate's matrix doesn't even appear consistent with the u1 gate's matrix.
No response
OpenQASM 2 doesn't have any way of representing a global phase (unlike OpenQASM 3), so there's no possibility of the operations being defined any other way.  It's not really valid as a serialisation language for the exact matrix form of operations, only complete programs with measurements (i.e. it's not really suitable to use OQ2 to represent just one operator that should later be controlled in a larger circuit).  Under that description, I think what we do is a valid interpretation of the spec, filling in some undefined behaviour (the global phase of the matrix representation of a circuit) by using our defined RZ phase convention if the user specified that, and the U1/P phase convention if that was specified.
With your last circuit - that circuit doesn't appear to faithfully implement a controlled U1 gate to me, but the matrix that comes out from the input circuit does look correct.  From the circuit you've written, I'd expect to see something that looks the same as your c2 circuit, because we can make the substitution $U_1(\theta) = a R_z(\theta)$ for whatever unit-magnitude scalar $a$ that conjugates under the action of the adjoint, then you can bring the scalar terms to the front of the multiplication and see that they immediately cancel.
Thanks for your detailed explanation. Everything's clear now.
It's not really valid as a serialisation language for the exact matrix form of operations, only complete programs with measurements (i.e. it's not really suitable to use OQ2 to represent just one operator that should later be controlled in a larger circuit).
This doesn't seem to be documented clearly in any obvious place, or at least it seems to be widely misunderstood. I stumbled upon this because I was debugging some attempts at making a pyzx optimisation pass for circuits produced in qiskit. pyzx currently treats the OpenQASM 2 rz gate the same as a u1/p gate, which as you say is fine for complete programs. But users are treating the circuits as subcircuits which can be composed, and so the round-trip back to qiskit after optimisation is broken.
that circuit doesn't appear to faithfully implement a controlled U1 gate to me
Oops, you're right. I was experimenting with different circuits to figure out how qiskit handles rz and u1 and I'd mixed things up when I combined the programs and cleaned them up to paste in the bug report. With your explanation, things make sense now. Thanks very much.
It's not really valid as a serialisation language for the exact matrix form of operations
I should be clear that this is purely my interpretation of OpenQASM 2, not an official position of the language: I didn't have any part of writing its spec.  I got to that opinion mostly on the basis of there not being a way to define a global phase in the language, and from my understanding of discussions during the design of OpenQASM 3 (which I was more involved in).
Thinking about workarounds somebody might try in order to have this work more like pyZX wants: Qiskit's OpenQASM 2 parser actually allows for a lot of customisation over how exactly gates are interpreted and built on the Qiskit side.  A user could specify that they want rz gates to be brought into Qiskit actually using the PhaseGate class (as opposed to RZGate).  You do that like this:
which I think is what you wanted (you can also inspect qc to see it used a PhaseGate instead of an RZGate).
QuantumCircuit.from_qasm_str is actually a now-legacy wrapper around the main importer logic that lives in qiskit.qasm2.  The full documentation on the parsing infrastructure for OpenQASM 2 is here: https://qiskit.org/documentation/apidoc/qasm2.html#parsing-api.
I've just opened PR #10801 to add some more documentation around how Qiskit interprets these phase conventions, and how they can be overridden.
Thanks very much, Jake!
It's not really about "what pyZX wants", but what its users expect. Based on existing filed issues, it seems there's a mismatch. I think it would be clearer if pyzx was changed to internally use u1 explicitly. In any case, you've given me the info I need to work on a fix in pyzx itself.
No worries, let us know if we can help more / you find anything else.  Qiskit and OpenQASM 2 were developed in quite an intertwined manner at the time, so it's quite likely there's other places where Qiskit has some behaviour that was also the "spirit" of OpenQASM 2 even if not the specification.
On "what pyZX wants" - sorry if it wasn't clear, I mostly just meant that the OQ2 file pyZX wrote out was assuming it'd be read with a different phase convention for the gates than what Qiskit does by default.  I think both Qiskit's and pyZX's readings of the spec are totally valid here, and now we're aware there's an ambiguity that different libraries are resolving in different ways, we can be sure to document our conventions and how to override them better.
