Find out if the bottleneck is the handshaking or the throughput of USB 1.0.
It seems that every call to the USB bus incurs a ~10ms overhead. By reducing the number of independent calls, Colm and I were able to get loadWaveform down to about 60ms, and LoadLinkList down to about 30ms. For time-critical applications, we, should make a 4-channel version of loadLinkList in order to minimized the number of independent USB writes.
I guess the question is whether the overhead is so big that it isn't worth rewriting the USB interface into a binblock style.
Fair point. I guess my only thought is that we already need to rewrite the USB interface to support 32-bit addressing in order to use the rest of the block RAM available on the FPGA. This will double the amount of data we stream over USB if we keep the current addr -> data -> addr -> data format. This may push us over the break-even point where the streaming takes a considerable fraction of the total time.
What may be more worthwhile in the short-term is to re-write things on the driver side to queue commands, waiting to stream them out until a flush() is called. This would minimize the number of times we open the interface. Unfortunately, that would get rather ugly unless we moved to C++.
I don't think we need to jump all the way to 32 bit since block RAM is a bit tight on these FPGA's we need to balance the extra memory the LL's would take.  However, I really like the queuing idea.  As you know, I'd like to move to C++ for a whole bunch of other reasons too as we move to push more functionality into the driver.
The addition of buffered writing and FT_SetTimeout have cut link list loading time down to 15ms per channel. This is getting us within a factor of 2 of the theoretical bandwidth; consequently, I am calling this issue solved.
