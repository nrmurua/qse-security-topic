We've implemented plugin-specific Python wrappers at least twice, now, respectively for Qiskit and Cirq. We also have a shared library layer, for Q#. However, the shared library layer has been extended for a simple, useful API wrapped in C# for Unity3D. I intend to maintain all of the above, for now, but I really like what the shared library has become.
It's trivial to use Cython to wrap the shared library directly for Python, with the same API we've exposed to C#/.NET. A canonical "pure Qrack" Python wrapping is probably long overdue.
Perhaps to some disappointment, we won't distribute this as a package via pypi, at least for now, immediately. However, it will take just a two-step process to install, first building/installing Qrack, then doing the same for "PyQrack." I can complete a vm6502q/pyqrack implementation in a night or two, and this would be exceptionally useful for direct interface with the rest of the FOSS quantum computing ecosystem.
A foreword: at first, like with Unity, (and with Q#, under the hood,) the real simulator class lives in a vector of simulator instances in the shared library itself, operated on with an integer ID key, for the instance. Like with the Unity wrapper, there will be a QrackSystem (AKA QuantumManager) singleton, which takes the respective simulator instance ID key with all operations. However, also like what we've done with Unity, we'll wrap at least one layer over that wrapping, with a QrackSimulator (AKA QuantumSystem) instance that caches its simulator ID key and passes it into all QrackSystem calls. So, this will be familiar, and you can instantiate multiple instances, of a system of a coherent length of qubits, each as a separate QrackSimulator instance. You can instantiate QrackSystem and manage your simulator IDs directly, though, I suspect at this point.
