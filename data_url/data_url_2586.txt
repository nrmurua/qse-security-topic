Example where it doesn't:
This is a consequence of our attempt to preserve the identity
The identity is true for real numbers. It fails when we move on to complex numbers. From then on it continues to fail for unitary operators.
I understand the desire for intuitive behavior, but I fear that an attempt to preserve a false identity will just lead to a surprising behavior elsewhere: since the identity is false, something has to give. In this case, we are giving up a very fundamental and intuitive property of equality: if two gates are equal then transforming each in a given way yields another pair of equal gates.
If we must surprise some users, perhaps it is best to do so in a context that is at least consistent with the rest of the world, which recognizes the failure of identity (1).
Filed from review of #1155.
I personally think that, given how I imagine users using the objects affected by this, they will rely on (G**a)**b == G**(a*b) more often than they rely on a==b implies f(a) == f(b). Specifically, I think the case (Z**-1)**0.5 (but a bit more obfuscated) is the most likely to occur.
I agree that a == b implies f(a) == f(b) is more fundamental, I just think it will come up less often.
@dabacon @babbush @kevinsung what do you think?
The identity is true for real numbers.
Correction. Identity (1) doesn't even hold for all real numbers:
So (1) is only valid when G is a positive real number. It fails when G is a negative real number, a complex number or a unitary operator.
Given how shaky (1) is, I think we should favor the preservation of the more fundamental and intuitive property of equality:
@Strilanc are you saying that (Z**-1)**0.5 should return S**-1 rather than S? (Below I assume yes, please disregard otherwise.)
Taking roots is a multi-valued function, i.e. for any a and n there is generally many x such that
This is true for integers, reals, complex numbers and operators. For example, both 2 and -2 satisfy x^2 = 4, both i and -i satisfy x^2 = -1 and both S and its inverse satisfy x^2 = Z.
The prevailing convention for resolving this ambiguity is to choose the principal value. This convention is followed in maths, physics, electrical engineering, python (math, cmath, numpy) and most other programming languages and libraries.
It's easily seen that S and not its inverse is the PV of (Z**-1)**0.5. Under the PV convention we should return S as the value of that expression.
IIUC, the competing new convention proposed in cirq is to encode the branch choice in the sign of the exponent. This may work in the above case, but only because there are exactly two roots to choose from. The new convention is not extensible in an intuitive and consistent way to other situations. Consider (Z**-1)**0.25. There are four candidates for the value of this expression: T, T^3, T^-3 and T^-1. Endowing the sign of the exponent with additional meaning isn't going to help us here, given that we're choosing one of four branches and there are only two signs :-)
Following the established mathematical definitions and conventions minimizes the risk of surprising and inconsistent behavior.
Yes, (Z**-1)**0.5 should return S**-1. (Z**3)**0.5 should also return something equivalent to S**-1.
An example of existing functionality standard to many languages that violates a == b implies f(a) == f(b) is how signed zeros interact with floating point division. 0==-0 but inf = 1/0 != 1/-0 = -inf. Python will raise an error if you do this, numpy will print a warning, C will just do it, etc.
Yes, (Z**-1)**0.5 should return S**-1.
Intriguing. For diagonalizable operator A with eigenvalues 位1..位n and analytic function f, f(A) is the operator with eigenvalues f(位1)..f(位n) (and same eigenvectors). In this case we're taking square root of an operator with eigenvalues 1 and -1, so one would expect that the square root has eigenvalues 1 and i (since sqrt(-1) is generally accepted to be i and not -i by the PV convention above). Instead, you're saying it should be the one with eigenvalues 1 and -i.
Could you explain why?
Also, do you know the behavior of other QC libraries?
Python will raise an error if you do this, numpy will print a warning,
More evidence that violating the identity in the issue title is widely considered abnormal and surprising.
Could you explain why?
Because (g**a)**b should equal g**(a*b) whenever possible.
The gates have an internal winding number, and raising to a power scales the winding number. Winding twice is equivalent to winding once in terms of its final effects, but it's possible for mathematical invariants to be phrased in terms of the winding number and then the multiplicity matters. The same unitary can be generated by two different Hamiltonians applied for the same amount of time.
Because (g**a)**b should equal g**(a*b) whenever possible.
So, the failure of expressions such as (Z**-1)**0.5 to evaluate to their principal value (here S) is another consequence of the desire to force unitaries to obey (g**a)**b == g**(a*b). Like the inequality weirdness above, this leads to surprising behavior.
Here's what the user will most likely expect:

Here's what they'll get some of the time instead:

I think this is very likely to surprise and confuse users as it would surprise and confuse if numpy.sqrt(-1) returned -1j instead of 1j.
To make matters worse, in any given context it may be unclear which of the two square roots is chosen by cirq since the choice is dependent on the details of how the Z was constructed (which as Craig indicated above, may be obfuscated).
it's possible for mathematical invariants to be phrased in terms of the winding number
This is a cool argument! :-) What are some examples of the mathematical invariants involving the winding number?
Off the top of my head, I remember that sphere eversion is possible because of conservation of a 3d analogue to the 2d winding number https://www.youtube.com/watch?v=sKqt6e7EcCs
This discussion is the reason that most people in quantum computing do not talk about raising a gate to a fractional power.  A cursory look shows that no one else does this.
My inclination would be to follow what is done in complex analysis and use the principal value.  Two reasons
What are the main drawbacks of using the principal value?
The same unitary can be generated by two different Hamiltonians applied for the same amount of time.
Just a side note that there are way more than two different Hamiltonians applied for the same amount of time that can generate a unitary.  Every eigenvalue of a unitary is ambiguous up to a phase of 2 \pi.
The behavior advocated by @viathor is less surprising to me, and I'm willing to give up identity (1).
Had a quick look at what implementation of this might look like. AFAICT, we should be able to store only canonicalized exponent. For EigenGate, this should give us nice code simplification by removing the need for having two different exponents for different purposes (equality tests vs other computations) and by removing the need for caching canonicalization result.
@Strilanc Unless you object, I'll go ahead and implement this in near future. Let me know what you think.
Yeah, go ahead and implement it.
I think the main obstacle you will run into is that the canonicalization differs when ignoring global phase and when not ignoring global phase, and this distinction has to be resolved. I think the solution is to bias much more heavily towards not ignoring global phase, e.g. show it in diagrams.
I think the plan of record is documented in #1731.  I'm going to close this, though we need to get #1731 back on track as it is a better solution.  There is a comment on #1731 about this issue so should that not work out we should revisit this.
@viathor @MichaelBroughton @tanujkhattar  Given we've chosen not to address #1731 should this be reopened?
Another salient example, it seems controlled gates are considered equal even if the control qubit order is swapped. However this seems very not equal, as they create different operations when applied to qubits. If the dimensions are different, this even throws an exception when trying to apply.
A better example of a common place this doesn't hold. Dictionaries in Python are ordered (now), so:
