Hi,
I've come up with a solution alternative to the one suggested in the reference, which - if it worked - would probably be conceptually simpler. The idea is that, given the qubit register and two boolean registers from the outside (in this case, from the test), I attach one additional qubit, in a way extending my quantum register by one. I then apply Hadamard gate to that qubit, essentially obtaining the following superposition:
where I assume that the first qubit is my additional one. I then iterate through the first classical register and whenever its item is true I apply a CNOT between the 0th and ith qubits, thus setting one half of the superposition. I then negate the first qubit with X and repeat the procedure for the second classical register. I finally discard my additional qubit and I'm left with my resultant qubit register.
Below is my take on implementing an operation according to the description above:
The thing that puzzles me is that the test suite in QuantumKatas fails to pass. But I moved ahead and tried to simulate a simplified scenario, in which I specify the desired parameters of the superposition and then measure multiple repetitions. If I do it that way, the mechanism seems to work. Below is a test operator, which calls the one above in a for loop and gathers statistics:
It gives me sensible output, differing according to how I specify the boolean registers. I'm having trouble debugging the provided tests, so I'd like to ask you for help either making it work, or pointing out how my approach is wrong. Thanks!
Your solution doesn't actually prepare the superposition of the two given bit strings, it prepares one of the bit strings at random with 50-50 chance.
Consider the simplest example possible: prepare superposition of |0⟩ and |1⟩ basis states (bits1 = [true], bits2 = [false]). After the two loops, right before Reset, the state of the qubits is |00⟩ + |11⟩ (with appropriate normalization). Reset measures the qubit q and applies X if necessary to convert it to |0⟩ state. If you measure one of the qubits in the superposition |00⟩ + |11⟩, the second one will be left either in |0⟩ state or in |1⟩ state, depending on the measurement result, but not in a superposition.
It is possible to make this approach work, but you'll need to convert the additional qubit to |0⟩ state by uncomputing it, not by measuring it - for example, you can find a position in which the bitstrings differ and do a CNOT with the corresponding qubit the as control and the additional qubit as the target - but then it stops being conceptually simpler :-)
Thanks for the great explanation! So my means of zeroing the additional qubit (i.e. Reset) simply collapses the superposition I've built and by the time I was measuring my qubits proper, there was no more superposition to collapse, is that right?
I also want to clear one detail about your suggestion of 'uncomputing'. So, the configuration of superpositions between the additional qubit and the one corresponding to the first mismatch in bitstrings can be either 'straight' or 'diagonal' (meaning (q0 = |0⟩+|1⟩, qi = |0⟩+|1⟩) or (q0 = |0⟩+|1⟩, qi = |1⟩+|0⟩), respectively), and so the CNOT results in q0 becoming |0⟩ or |1⟩, respectively, after which measuring it no longer collapses our desired superposition. So the crux here is going with a unitary transformation (CNOT) instead of a measurement. Do I get this right?
I've implemented your suggestion and it worked fine. Perhaps it did in fact lose some conceptual clarity, but somehow it feels more natural to me :). Here's the code:
Thanks for a very enlightening discussion and keep up the great work :).
