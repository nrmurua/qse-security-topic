There has been a fair amount of discussion about how to make separate noise models and optimizers play nice when we want to use more than one of them on the same circuit. For the case of noise models, composing noise models that act on every operation is an issue if we don't want noise inserted by one model to cause the next noise model to insert more than its fair share of noise. For optimizers, there are a number of cleanup routines like removing empty moments that we would prefer to do once after the optimizers are all finished.
Suppose instead we take the approach that protocols have moved towards. What we currently call optimizers are re-branded as optimization strategies that an actual overhead optimizer receives a list of. Likewise, what we currently call noise models can be re-branded as noise instructions that one noise applier receives a list of.
The overhead object would be a circuit_mutator which can take in a pre-processing task, list of replacement routines, and post-processing task. A built in Optimizer could be a mutator that has a default post-processing task of implementing the garbage cleanup routines once. A built in Noise_Inserter could have a default pre-processing task that adds meta-data tags like "original operation" that noise strategies would look for before instructing the Noise_Inserter to replace the operation with a new Op_tree.
It seems like some of the headaches we run into could be addressed by switching to a model similar to this, but the idea could also use a lot of work. What do people think about this?
