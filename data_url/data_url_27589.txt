Hi,
I would like to get the Hamiltonian in the second quantization after HF calculation, i.e. the coefficient matrix of the Hamiltonian in the Fock space given the basis set calculated by HF method. This is the first step of post-HF method, including FCI and quantum computing algorithms(such as VQE) I'm working on.
I did a little bit of review of the Quiqbox.jl code, and found that maybe I can do it using functions provided by src/Integrals/OneBody.jl and src/Integrals/TwoBody.jl, following the Slater's rules.
Do you have any suggestions for this, and what is the easiest way to achieve this in Quiqbox.jl ?
Hi @overshiki! Quiqbox does not provide the function to directly realize that, which I assume is getting h_ij and h_ijkl on the basis of the molecular orbitals, right? I do plan to implement features to connect better to second quantization and post-HF method calculations in the future.
As for now, it's fairly simple to achieve your goal with functions already existing in Quiqbox.
First, you need the coefficient matrix C for the molecular orbitals on the basis of your initial basis functions. You can get it from the field .C of the returned object (of type HFfinalVars) from runHF. Next, you can use coreH and eeInteractions to generate the 1-body Hamiltonian part and 2-body Hamiltonian part based on the initial basis set. Then, use the C to transform them onto the basis of the molecular orbitals.
A slightly alternative solution would be:
First, construct the molecular orbital set from C and the initial basis set. This can be achieved in Quiqbox through simple linear operations like:
Then input the molecular basis set into coreH and eeInteractions to get your results. Depending on the size and structure of your basis set, the efficiency of those two solutions might be quite different.
I hope this helps!
Hi @overshiki! Do you have more questions regarding this issue? If not, I'll close the issue.
Hold on please, I'm testing the idea and may have some issues in the coming days.
Hi @frankwswang
I just tried to implement the second method in your suggestion. However, I found one weird thing: for LiH system, the number of orbitals generated by genBasisFunc is 4, while the C matrix after HF calculation is 6 by 6. I believe the number of orbitals should be 6, but don't know why genBasisFunc behaved this way. Below is the code to reproduce the result:
the result is
Do you have any idea about what happened here?
Hi @overshiki!
If you use typeof to inspect the type of each element in bs:
You can see that the first 3 elements are BasisFunc, each corresponding to a spatial basis function. However, the 4th element is a BasisFuncs, a collection of all the orbitals (spatial basis functions) within the subshell p (l=1).
Both BasisFunc and BasisFuncs are a subtype of FloatingGTBasisFuncs. Specifically,
where ùëô is the orbital angular momentum quantum number, GN is the number of GTO used to construct each orbital, and ON is the number of orbitals.
You can decompose a BasisFuncs into a Vector of the basis functions it represents by
Hi @frankwswang
Thanks for your explanation! It is really helpful and I now successfully got the one-body and two-body integral for the Hamiltonian.
However, I do meet one performance issue: the calculation of the integral is much slower than that of openfermion:
For LiH calculation, with 6 * 6 one-body integral and 6 * 6 * 6 * 6 two-body integral, openfermion only takes 0.14s, while Quiqbox.jl takes 44.7s, around 300x slower...
To reproduce the result, please refer to this gist
I'm just wondering what happened here, and is there any way to solve this problem?
Hi @overshiki! If you want to benchmark the performance of a Julia package, I'd suggest you use a more appropriate package BenchmarkTools.jl to get a more accurate evaluation.
As for the slow performance of Quiqbox, it's somewhat expected for using the second method as I mentioned here:
Depending on the size and structure of your basis set, the efficiency of those two solutions might be quite different.
Since Quiqbox hasn't provided functions to natively realize the feature you asked for, even though the work-around syntax might be simple, the performance is not optimized. Specifically, calculating the h_pqrs with respect to the molecular orbitals is a heavy tensor contraction process that can take up a lot of computing resources without specialized optimization.
If efficiency is your priority, you can use another Julia package TensorOperations.jl to directly rotate the one-body integrals and two-body integrals with the C matrix. Here is a small adaptation for your code that will dramatically speed up the process:
I think if you use this method, the speed of the code should be at least comparable to the OpenFermion, if not faster. Although, one thing to mention is that Quiqbox does not officially support multi-threading so far and I'm not sure if OpenFermion has such a feature so that could also lead to performance differences related to your machine's specs.
Hi @frankwswang
Thanks a lot for the help! Yes, this new implementation is much faster! It only takes 0.11s for the LiH example above and is now faster than(or at least comparable to) the OpenFermion. I can see that this is actually the first option you mentioned before, i.e using C to transform the one-body and two-body parts of Hamiltonian onto molecular orbitals.
Regarding the performance difference, ideally, the two options should point to the same tensor contract operation, for example, for one-body integral, using einsum, we have:
where r is the index that stands for the grid in real space, which is much larger than any other indices.
The difference between the two options is the order of the contraction, while the first one is
and the second option is
I can now see in most cases, the first option will always be the cheapest one, am I right about this?
Another problem I met is that the sign of some Hamiltonian coefficients is different from that of OpenFermion, this is really weird and I guess maybe it is because of the difference in the definition of atomic orbitals? (I'm not sure).
More specifically, for LiH example, the OpenFermion gives the one-body integral as below:
while the Quiqbox.jl gives the one-body integral as below(using both options you mentioned):
as you can see:
for OpenFermion, H13=H31=-0.023; for Quiqbox.jl, H13=H31=0.023
also
for OpenFermion, H63=H36=0.223; for Quiqbox.jl, H63=H36=-0.223
To reproduce, please refer to this gist
So what happened here?
Another problem I met is that the sign of some Hamiltonian coefficients is different from that of OpenFermion, this is really weird and I guess maybe it is because of the difference in the definition of atomic orbitals? (I'm not sure).
More specifically, for LiH example, the OpenFermion gives the one-body integral as below:
while the Quiqbox.jl gives the one-body integral as below(using both options you mentioned):
as you can see: for OpenFermion, H13=H31=-0.023; for Quiqbox.jl, H13=H31=0.023 also for OpenFermion, H63=H36=0.223; for Quiqbox.jl, H63=H36=-0.223
To reproduce, please refer to this gist
So what happened here?
This is due to the phase differences (i.e. a minus sign) of C's columns between Quiqbox and OpenFermion. Consider the following example:
Assuming C1 is the MO coefficient matrix generated from Quiqbox, and C2 is the MO coefficient matrix generated from OpenFerion, then they have the same elements except for the 2nd columns having a ratio of 1:-1. This however doesn't affect the validity of both matrices since each column of a MO coefficient matrix represents one MO (expanded on the basis functions) that's the eigenvector corresponding to an eigenvalue (MO energy). Changing the sign doesn't change the eigenvalue.
Now if you try to perform basis transformations on a cH (one-body Hamiltonian) using both matrices :
You can then see:
which essentially recreates the scenario in your reply where there are additional minus signs on the 3rd row as well as the 3rd column when we compare the one-body integral solutions from two packages.
A little to add on: When I first tried to implement Hartree-Fock in Quiqbox, I also noticed this "issue" when comparing it with other packages. And the reasons why sometimes the calculated results from different software/platforms might have a different overall sign of each column in C is related to the underlying Linear Algebra library/functions they use, such as BLAS, OpenBLAS, MKL... Quiqbox in default is set to stabilize the sign of each column so that no matter the user uses what system or library, the C generated by Quiqbox will always have consistent signs.
Thanks a lot for your explanation, this clarified the thing clearly!
Assuming C1 is the MO coefficient matrix generated from Quiqbox, and C2 is the MO coefficient matrix generated from OpenFerion, then they have the same elements except for the 2nd columns having a ratio of 1:-1. This however doesn't affect the validity of both matrices since each column of a MO coefficient matrix represents one MO (expanded on the basis functions) that's the eigenvector corresponding to an eigenvalue (MO energy). Changing the sign doesn't change the eigenvalue.
I could add that if one MO is shifted by a phase difference(with norm 1), then all the slater determinants involving it did so, which means it forms a new basis that some of the Fock states are shifted by a phase difference. It turns out that this basis is isomorphic to the original one(The normalization holds, the orthogonal relationship holds, and the eigenvalue, as well as expectation value with respect to any observables, does not change). This is quite interesting.
Quiqbox in default is set to stabilize the sign of each column so that no matter the user uses what system or library, the C generated by Quiqbox will always have consistent signs.
This is really cool!
I have successfully implemented a VQE system based on the Hamiltonian I obtained using Quiqbox.jl, thank you for your wonderful work!
I would like to suggest that maybe you could add a function like calc_Hamiltonian_coeff in Quiqbox.jl so that when you are doing some modifications to Quiqbox.jl, you will remember to also maintain it. What do you think?
Hi @overshiki!
I'm glad it finally worked out! I have put the feature request of including a function like calc_Hamiltonian_coeff in my dev note. Thanks!
If things go smoothly, I'll implement it in the next major release (v0.4.0) because I think it's a very useful feature as you suggested! Do you have more questions regarding this issue thread? If not, I'll close it soon.
Hi @frankwswang
If things go smoothly, I'll implement it in the next major release (v0.4.0) because I think it's a very useful feature as you suggested!
That's cool! Thanks!
Do you have more questions regarding this issue thread? If not, I'll close it soon.
sure, it's OK for me to have it closed.
