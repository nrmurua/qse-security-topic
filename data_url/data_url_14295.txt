Given a specific value of the angle $\theta$, the Qiskit transpile function (with basis_gates=[ $R_{\alpha}$ ]) does not resolve the equivalence $I = R_{\alpha}(-\theta) R_{\alpha}(\theta)$ for $\alpha = y$, while the same works fine for $\alpha = x, z$.

I would expect the transpiler to resolve the equivalence correctly, returning a circuit with no gates as a result. This works as expected for the $R_x$ (and $R_z$) gate, as shown in the following:

We have a lot of baked in re-synthesis routines, but accounting for every possible combination (or lack of combination) of basis gates is quite hard, so there's lots of little blind spots like this one.  There's a few places in Terra that could have optimised this, but in special-cased peephole optimisations, we tend to handle $X$ and $Z$ rotations over $Y$, since each one of those we add comes with a maintenance cost, and $Y$ is less commonly used as the basis gate.
In general, you'd expect that this sort of optimisation would be done in our 1q complete block resynthesis step.  That doesn't happen here because you've specified an incomplete set of basis_gates; you can't cover the entire space of $\mathbb C^2 \to \mathbb C^2$ operators with just $R_y$, so we don't match any of our available resynthesisers and we just have to leave it in place.  Terra's transpiler (in general) does exact synthesis, so we're not too concerned about adding support for partial operator bases, because it would need new special-case pipelines for something that we don't really support.  You'd be able to see Terra make the full optimisation if you specify (for example) basis_gates=["rx", "ry"] - we have an Euler-angle decomposer for that.  You can see the set of complete 1q bases we can decompose to here: https://github.com/Qiskit/qiskit-terra/blob/a3b359b899d5d963272a7b424c8a283bc6bd4c0d/qiskit/quantum_info/synthesis/one_qubit_decompose.py#L43-L56
As long as your basis_gates contains all the items from any of those sets, we'll be able to do the optimisation.
In this case, the $R_x$ case works because of a special-case peephole optimisation in CommutativeCancellation. It has rules for $X$ and $Z$ rotations but not $Y$.  That's actually a surprise to me that it does it at all, but there you go.  We could consider adding support for $Y$ rotations in there, although it does make me wonder if it would be possible to try and work in the full 1q-resynthesis routines as drivers for that pass rather than it maintaining its own list.
FWIW, there is also a pass CommutativeInverseCancellation that is able to cancel out pairs of inverse gates, but does not merge rotations.
