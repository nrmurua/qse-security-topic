(just a note to myself for an idea that I might want to explore at some point)
In the absence of a Cython implementation of the Chebychev or Newton propagatos, tapping into qutip.mesolve would still be great  for having a propagator with sufficient performance to run an optimization beyond toy models. The problem is that mesolve propagates over the entire time grid, and has no way to propagate a single time step in an efficient way. Instead of a major refactoring of the mesolve code into something that would be useful for krotov, it might be very straightforward to copy the qutip.mesolve and qutip.sesolve modules and to plug in yield statements where QuTiP stores the propagated states into the result objects.
There is one complication beyond just iterating over the states: I have to be able to modify the controls in every time step.
I'm not sure if mesolve internally keeps a simple reference to H which would allow me to change H in-place. If yes, and if mesolve were to yield the propagated states, then the following snippet should do the job:
It's sufficient to assume that the time-dependency ctrl_array is a numpy array.
