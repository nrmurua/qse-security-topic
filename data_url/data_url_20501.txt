When logging in from OpenSSH_7.9p1 client to OQS-OpenSSH_7.9-2020-08_p1 server there is a connection error:
When logging in from OQS-OpenSSH_7.9-2020-08_p1 client to the same server there is no error.
This is logical as some OQS algorithms are blowing the packet size limit of a "stock" openssh: See this: 
@baentsch Thanks for the answer! But isn't this is major incompatibility with common openssh (making it impossible to connect to/from oqs-openssh)? [I don't use some OQS algorithms in the connection example.]
Maybe this situation could be improved so that when OQS algorithms are used packet size is increased, but when they aren't packet size is normal? Otherwise only oqs-openssh <-> oqs-openssh connections are possible even for non-oqs algorithms.
To add context — I was willing to create an experimental oqs-openssh package for ALT Linux, but if openssh cannot be replaced with oqs-openssh people cannot use it in practice as they will not be able to ssh to non OQS hosts anymore.
Unless I misunderstand, having a larger PACKET_MAX_SIZE should allow the an oqs-openssh client and server to send and receive larger packets than plain openssh, but they would only do so if a (large) PQ algorithm is being used. When an oqs-openssh client proposes a non-PQ suite to a plain openssh server, that packet would be just as small as it originally was, and the plain openssh server should have no problems handling it.  Or am I missing something?
When an oqs-openssh client proposes a non-PQ suite to a plain openssh server, that packet would be just as small as it originally was, and the plain openssh server should have no problems handling it.
This is also my understanding. However @vt-alt you have a point in that your example was not actively using PQ; thus, your example should have worked/connected. Now understanding the ultimate goal of your test (ensuring PQ/non-PQ ssh interop), let me re-open the issue with a different title.
@vt-alt I now finally found time to re-do what you tried and everything worked perfectly: stock client -> OQS-sshd and also OQS-ssh -> stock sshd(s). Admittedly, I tried only the OQS-v8 branch which is (quickly becoming) our new main branch with ED25519.
Now, some questions: Are you absolutely certain that no PQ-signature algorithms got (inadvertently) sent (causing a buffer problem as per the above)? How did you start the sshd? I tried this: sudo /opt/openssh/sbin/sshd -p 2222 -d -o AuthorizedKeysFile=/home/mib/ssh_server/authorized_keys -o HostKeyAlgorithms=ssh-ed25519 -o PubkeyAcceptedKeyTypes=ssh-ed25519 -h /home/mib/ssh_server/id_ed25519 and on client side: ssh -p 2222 mib@localhost -i ~/ssh_client/id_ed25519 -o PasswordAuthentication=no. My local user ID obviously is "mib". You can see the full server-side trace below.
Full server log as per the above:
Of course, sshd is started with OQS algorithms enabled. Do you suggest disabling them? If so there is still no interop with generic OpenSSH as users cannot run OQS OpenSSH server and connect to the host from generic OpenSSH client.
This is the log of faulty connection on the server side.
For the completeness I just tested with /usr/sbin/sshd -d -h /etc/openssh/ssh_host_ed25519_key and this does not cause connection errors. So, problem only if OQS algorithms are enabled on the server side.
Admittedly, I tried only the OQS-v8 branch which is (quickly becoming) our new main branch with ED25519.
[Btw, if it will support ED25519 as a hybrid algorithm with OQS algorithms that would be really nice, because of the popularity of ED25519.]
I think the choice should be given to the end-users — the server should run with OQS enabled, but client users should be able to choose to connect with OQS (if they enable it) or using generic algorithms and generic OpenSSH clients. That way generic OpenSSH server may be replaced with OQS OpenSSH transparently. If we only enable generic and hybrid algorithms on the server side the security should not decrease in comparison to generic OpenSSH.
Please correct me if I'm wrong.
So, problem only if OQS algorithms are enabled on the server side.
Thanks for that confirmation -- that then might explain things: As soon as one of the "crazy big" algorithms is enabled, the larger --and incompatible-- buffer size might be triggered. I need to read up on the SSH protocol to understand if/when this occurs (maybe the server proposes them all to the client and in so doing the problem hits? Maybe @dstebila or @xvzcf you already know?). Might disabling/removing Sphincs and Rainbow host keys already suffice (?) to achieve your stated goal:
client users should be able to choose to connect with OQS (if they enable it) or using generic algorithms and generic OpenSSH clients
to which I fully agree.
Now, after having built also the old (7.9) OQS-openssh locally I still fail to reproduce the error you are reporting, though: I still can connect OK (albeit very slowly) with a stock ssh to an OQS-sshd... So, could I ask you which exact platform you are using? Do you possibly have a docker image with which to reproduce things exactly? Or could you share all steps/the script that led to the behaviour reported? Thanks in advance.
Thanks for that confirmation -- that then might explain things: As soon as one of the "crazy big" algorithms is enabled, the larger --and incompatible-- buffer size might be triggered. I need to read up on the SSH protocol to understand if/when this occurs (maybe the server proposes them all to the client and in so doing the problem hits? Maybe @dstebila or @xvzcf you already know?). Might disabling/removing Sphincs and Rainbow host keys already suffice (?) to achieve your stated goal
If memory serves, we only increased PACKET_MAX_SIZE, which is an OpenSSH buffer size, but not the size of any length fields in the protocol because the SSHv2 protocol itself had 32-bit length fields which are sufficient.  See the discussion in sections 3.3 and 4.2 of https://eprint.iacr.org/2019/858.
Perhaps Michael's last sentence quoted above is on to something: if the OQS-OpenSSH installation is configured with Sphincs/Rainbow host keys, perhaps those are being sent even if the client doesn't ask for them, which would then be larger than the buffer size that the plain OpenSSH client can handle...
Further experiments show that when I disable any one of the following keys Bad packet length error disappears and I can ssh successfully: ssh_host_p256_rainbowiclassic_key, ssh_host_rsa3072_rainbowiclassic_key.
Disabling *sphincs* keys does not affect the connection. So, "bad" keys are rainbow.
Also, my sshd build has disabled in oqs-template/generate.yml — RAINBOW_III_CLASSIC and RAINBOW_V_CLASSIC, because these keys are very slow to keygen (many minutes) making sshd start unacceptably long.
We build using rpmbuild system. There is my repo: http://git.altlinux.org/people/vt/packages/?p=openssh.git;a=shortlog;h=refs/heads/openquantumsafe
Perhaps like this, it could be reproduced manually:
It will execute commands from %prep and %build sections of the .spec with sources untarred in /home/builder/RPM/BUILD and build artifacts in /home/builder/RPM/BUILD/openquantumsafe-openssh-7.9p1.202008.
I'm no particular fan of Rainbow and wouldn't mind you drop it completely from your packaging... But then again, we (want to) try to support all QSC algs wherever possible... So I wonder:
I'm OK and we can close the issue. I will disable Rainbow as it significantly reduce overall user experience of sshd (in compare to other algos), because of its slowness and big packet issue. But, of course, to support it on client-only would be better (if user wants to connect to a 3rd party sshd). I will enable it if this option is available. Thanks!
