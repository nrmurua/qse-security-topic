Most tasks in this kata take inputs in an arbitrary superposition state and require implementing the right unitary transformation on them; to verify the solutions, the tests compare the learner's solution to the reference one as unitaries using AssertOperationsEqualReferenced. (Sometimes one or several inputs are in |0⟩ state, but this does not affect the expected solution, so we still can use the assert.)
In task 1.7, however, one of the inputs is guaranteed to be in |0...0⟩ state, and the "challenge" solution relies on that fact to reuse these qubits instead of allocating new ones. This means that the main solution and the reference ones perform different transformations, even though they are the same on the basis vectors. The test harness for this task uses only AssertOperationImplementsBinaryFunction to verify the solution instead of both it and AssertOperationsEqualReferenced.
We need to figure out a way to add verification of the solution as a unitary in this task. I think it should be possible to implement a wrapper operation which is a unitary on inputs a and b and allocates qubits in |0...0⟩ state for target qubits before calling the adder. Both solutions, when wrapped in such an adder, should implement the same unitary, and can be compared using AssertOperationsEqualReferenced.
I'm looking at this one
