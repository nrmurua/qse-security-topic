When using Aer's implementation of Estimator and setting approximation=True, the primitive job for computing the commutator expectation values for the gradients in AdaptVQE fails. This estimator seems to work fine for regular VQE and also for AdaptVQE when approximation=True is omitted, which tells me that the issue is specifically related to the AdaptVQE implementation of the gradient calculation.
The following program for calculating the ground state of diatomic hydrogen:
results in the following traceback:
The algorithm completes without primitive job failure. Aer seems to be flagging these commutator operators as non-Hermitian, which is a bit odd considering that using Aer's Estimator implementation without setting approximation=True works just fine. The hermiticity should be independent of this argument.
No response
This may be more an issue for Qiskit Aer repo rather than Terra - @ikkoham may be able to ascertain better.
I see, thank you. Should I close this and re-open it in Aer?
If it is an Aer issue it can be transferred over there. Maybe let @ikkoham make a determination since he is working with the Aer primitives too and we can go from there.
I think I have tracked down where the error occurs and it looks to be an Aer issue, so I can close this and re-open the issue in Aer if you would like.
This error only occurs for Aer's Estimator when approximation is True and shots is None. Setting Approximation=True, but setting shots to be some finite integer works just fine. In the code, there is a clear fork in the road that determines whether or not this error pops up in the _compute_with_approximation function in the file /qiskit_aer/primitives/estimator.py. On line 292, there is the conditional statement:
Running circuit.save_expectation_value involves creating an instance of SaveExpectationValue in the file qiskit_aer/library/save_instructions/save_expectation_value.py, which involves checking that the operator is Hermitian. In this case, the gradient operators required by AdaptVQE is a SparsePauliOp where some of the Pauli coefficients are complex. Instantiating SaveExpectationValue involves checking that all of the Pauli coefficients are close to real. If they are not, it throws an error that not all of the Paulis in SparsePauliOp are Hermitian.
Now in the case shots is not None, instead of saving the expectation value of the SparsePauliOp as a whole, the code iterates over the individual Pauli terms and saves the expectation values of the individual terms, which neglects the coefficients which are added in later.
I guess one quick fix would be to just save all expectation values as per the second method, regardless of whether or not shots is None, but I am guessing that given that this conditional statement exists, there are good reasons for not doing it that way. (e.g. performance if `save_expectation_value incurs a computation overhead every time it is called- might not be desirable to do if not absolutely necessary.)
I guess for now, if you wanted to run noiseless AdaptVQE simulations using Aer, the thing to do would be to set approximation=True, but make the number of shots really large to make the variance effectively zero since it is just sampling from a gaussian and not actually running the circuit shots individually as when Approximation=False. The performance does not seem to get much worse if for instance I set shots=10**30
I think as far as algorithms go this was resolved so I am going to close this. If there is still some aspect with Aer Estimator feel free to open an issue on Aer for that.
