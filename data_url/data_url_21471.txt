Unwinding finally block is very slow because we used the unwinding library incorrectly.
According to unwind library interface documentation, _Unwind_Resume should be used to
Resume propagation of an existing exception e.g. after executing cleanup code in a partially unwound stack. A call to this routine is inserted at the end of a landing pad that performed cleanup, but did not resume normal execution. It causes unwinding to proceed further.
_Unwind_Resume should not be used to implement rethrowing. To the unwinding runtime, the catch code that rethrows was a handler, and the previous unwinding session was terminated before entering it. Rethrowing is implemented by calling _Unwind_RaiseException again with the same exception object.
When we raise an exception, the unwinding process will go through two phases. During the first (search) phase, the unwinder tries to find the appropriate handler for the exception and returns an error if it cannot find the handler that can handle this exception. The search phase will ignore finally blocks and only find except blocks with matching exception type. If the unwinding finds the handler for this exception, it will enter phase 2 (cleanup) which executes all the finally blocks and the except block for this exception. If it cannot find the handler for this exception, we will force unwind the stack, which will obtain the stack trace and run the finally blocks, then we will terminate the kernel and send the exception back to the host.
In our implementation, we run the reraise function for exception rethrowing and at the end of the finally block, which actually runs the raise function. The raise function will cancel the inflight exception and start the unwinding process again, i.e. the two phases. Hence, if we have many finally blocks, what we will do is:
So this becomes quadratic. To fix this, the compiler should place a resume call at the end of the finally block, instead of reraise. Reraise should call raise because the previous unwinding was completed (as it enters the except block, which is a handler for the exception).
Also, I start to wonder if we really need two-phase exception handling because what we do can be achieved with a single phase: just store the backtrace as we unwind the stack, although this is no longer conforming to the standard...
ðŸŽ†
