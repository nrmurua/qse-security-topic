It seems that the code that places 2-qubit gates in TEST_CASE("test_quantum_supremacy" in test/benchmarks.cpp is incorrect. This explains why Qrack's QUnit has such good timings in the last figure at https://qrack.readthedocs.io/en/latest/performance.html. Basically, the code places 2-qubit gates in such a way that there are disconnected clusters. The largest cluster size is 22 qubits for 56- and 63-qubit circuits (the two highest peaks in the fugure). In other cases, the cluster sizes don't exceed 16. If the number of qubits is a prime number then only one 2-qubit gate is placed (the lowest dips in the figure).
Thank you for opening the issue, Sergei. The issue with primes is basically expected, as we approximate by squaring up the circuit as best as possible on a 45 degree bias in a 2D arrangement. Hence, prime qubit count circuits are expected to have a width of 1 qubit along one of the spatial dimensions. This is keep the code as transparent and simple as possible, though the 54 qubit geometry should exactly match the 6-by-9 topology of the Sycamore chip.
I need to diagnose what you're saying. Note that a maximum cluster size below full entanglement is hoped to arise, due to the Schmidt-decomposed representation of state in Qrack::QUnit, if this is an inherent feature of the definition of the original circuit. If the coupler gates aren't actually placed between these regions, though, that's a problem; if they are, their presence is not guaranteed to lead to full entanglement, though.
Sergei, the vm6502q/simulator-benchmarks repo should run the same circuits, and it is the authoritative source for this code, (whether or not we've identified that it's bugged, as I'm still diagnosing). I hacked up a branch to spit out the coupler gate indices in an iteration, for 54 qubits: https://github.com/vm6502q/simulator-benchmarks/tree/qrack_issue_351
I grabbed the output of this branch for 54 qubits, between two "New iteration," marker lines:
https://pastebin.com/QiMMFbYb
I need to actually diagram this, to assess whether there's an issue, unless we can ultimately find the logical problem in the circuit definition itself. Again, separability is not an inherent issue, but incorrectly defined couplers are.
Daniel, if I understand the output format correctly then it seems that only 36 qubits are covered by 2-qubit gates at https://pastebin.com/QiMMFbYb. There are three disconnected clusters, each of size 12. There are additional problems. For instance, qubit 1 couples to qubit 6 in line 57 and to qubit 31 in line 62, at the same depth.
Sergei, thank you again for opening the issue. As lead developer of the Qrack team, this is exactly the kind of peer scrutiny Qrack needs and seeks. If there is a mistake in our reported results, I apologize for the failure of oversight, but this is why we have made our work and code public and transparent. Once I have fully digested the issue you have raised, any necessary changes to the arrangements of couplers will be amended for the benchmark in the repositories. I will add a similar list of the coupler arrangement for 54 qubits to this issue and perhaps the benchmark documentation, as above. We will amend the benchmark graphs, whether this ruins an illusion of Qrack's performance. I will keep this issue open, until all of the above is resolved.
Thank you!
Sergei, you were right. Here's an updated list of couplers, output by the debugging print statements in the modified circuit for 54 qubits: https://pastebin.com/ZxeZQ2Qs
It's fairly easy to see, in the updated arrangement of couplers, that the pattern should be, and is, very regular. Mostly, the problems seem to have been a conceptual off-by-one error in the tiling sequence, and a problem with the row/column loop bounds.
Thank you again for actually prompting me to the issue, and I apologize again for the failure to first notice this myself. We have been soliciting private opinions on our benchmarks before formal publication, exactly in case we could catch an error, but this particular error honestly just feels "dumb." To have someone point to a specific issue to diagnose makes all the difference, though.
I need to update the public benchmarks document, and I should be able to do so this weekend. As many would probably expect, this change "fundamentally" hurts Qrack's apparent performance on the benchmark, but the results simply are what they are. We do hope to continue improving performance for this and all our benchmarks, though, whether fundamental efficiency on this particular test is or will ever be feasible.
This looping structure is repeated in a couple of other places, but I will open a PR and merge into master as soon as I update those instances concurrently. Thanks again.
Sergei, just to close out this issue, we removed the bugged "Sycamore circuits" benchmark from the performance documentation a long time ago, explaining that you had helped us identify a bug, but I have a recent update to the results of this test back up on that page of the documentation, now.
No, we do not perform better than exponential scaling. The new results are based on a stack of QUnit -> QStabilizerHybrid -> QPager -> QHybrid. The addition of "QPager" to this stack makes a very significant practical improvement, but we do not expect or observe a super-polynomial scaling improvement. The circuit definition made the difference, per your original inquiry.
We're sorry about this. Hopefully, interested parties in the community have been made aware by now, given our retraction from and explanation in our performance document months ago. Covering Hilbert space is hard, but we've also subjected Qrack to Qiskit, PennyLane, and Q# unit tests for months, now, in our CI and personal testing, and we've fixed other bugs as a result.
Please never hesitate to reach out to us again, if you notice any bugs or problems in our reporting! We owe you our gratitude, for correcting our unintentional mistake.
(I'm assuming this issue is closed, but also don't hesitate to reopen it, if there's anything else to address. Thank you again.)
Thank you for the update.
