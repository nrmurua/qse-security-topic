GAPW (all-electron) OT CG runs for open-shell systems do not converge using the CP2K-internal TPSS implementation. On the other hand, the same runs converge with the corresponding libxc-TPSS routines. The following input should reproduce the issue. Setting @SET LIBXC     1 selects the TPSS implementation from the libxc instead of the CP2k internal one.
The CP2K-internal TPSS LSD routine is numerically unreliable for large density (rho) values. For instance, the output values for e_rhoa and e_rhob become divergent for rho values greater than 1.5 for an N atom. Such large rho values appear for the one-center densities in GAPW runs.
The code itself was created by some maple script. Due to the git history, the python script is ca. 15 years old (by fawzi). The Fortran codes for the PBE and TPSS functionals were created by some python script (see tools/maple2f90/). To me, it is not clear how the actual code was written to prevent numerical instabilities. From time to time this machinery might be interesting to implement other functionals if necessary.
It would take some more time to find the problematic lines for TPSS and how to circumvent them.
Do you know whether its due to the exchange or the correlation part?
Rewriting everything numerically stable can be rather tedious. I tried something in that direction using Sympy for an LDA-based and a PBE-based functional and even there it's already quite difficult to implement it numerically stable. It might be due to Sympy because it tends to demultiply terms or missing cancelation of factors etc.
Or maybe we should just dump our own XC implementations and rely entirely on libxc?
As @fstein93 pointed out we have lost the ability to re-generate those files and they got poor test coverage. Furthermore, the XC functional is a natural next target for GPU acceleration.
I would not dump our own XC implementations and completely rely on LibXC. It might be better to add a unittest comparing our implementations with LibXC implementations as proposed somewhere else. I am also not sure about testers using valgrind or similar tools.
Still, it does not solve the issues with our TPSS implementation. And we cannot support GPUs that way, for LibXC we had to rethink the interface anyway because LibXC expects pointers to GPU memory then.
Thanks @fstein93 and @oschuett, that's the discussion I wanted to trigger. The TPSS functional is algebraically complicated and our internal version is not built like the libxc implementation in a modular manner. As far as I can tell, the exchange and the correlation part are lumped together. Either somebody is able to resolve the issue with the current internal TPSS implementation or I would also suggest to remove the CP2K internal TPSS version as suggested by @oschuett. There is no benefit in maintaining an unreliable functional implementation. Sure, this will further increase the dependency on libxc, but we depend on libxc anyway for all newer xc functionals, since we have stopped our own functional implementation since many years by now. Libxc has also a larger user base which decreases the probability of bugs. Who will check and maintain our own functional implementations in CP2K? The results from mGGA functionals (with TPSS as its first test candidate) have been fishy for a long time and now it turns out that the weird (TPSS) results might have been caused by a combination of several bugs.
Rewriting everything numerically stable can be rather tedious. I tried something in that direction using Sympy for an LDA-based and a PBE-based functional and even there it's already quite difficult to implement it numerically stable. It might be due to Sympy because it tends to demultiply terms or missing cancelation of factors etc.
@fstein93 Maybe, it would be better then to contribute to the libxc project?
I never wanted planned to contribute my code to LibXC. It was justed interested in two functionals: A short-ranged LDA and a short-ranged PBE functional. For the LDA functional I was using an implementation by P. Gori-Giorgi which does not allow 2nd derivatives. That's why I tried to reimplement it but fortunately was implemented in LibXC recently. The short-ranged PBE functional will be implemented soon in LibXC. But Sympy has carried out strange things with the LDA functional and first tests of the PBE functional showed lots of numerical issues.
@mkrack Or what are you interested in? Basically, I agree with your idea.
@fstein93 There is no special interest on my part
Since the libxc is serving us well, I don't think we should invest in writing our own.
I agree with @mkrack that we should instead try to contribute when necessary.
@fstein93, if you are looking for an opportunity to leverage SymPy have a look at libint. It is very slow to compile, which calls for a JIT, and we currently don't have a good path for GPU accelerating those integrates.
I will then remove the CP2K internal TPSS LSD implementation, if there are no further objections.
