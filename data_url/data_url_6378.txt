As far as I can tell, now that the bug in Swap was identified and fixed, and with the subsequent commutation rule expansion in #341, the single bit phase gates (like Z) commute with all buffers in QUnit. Single bit "inversion" gates (like X) are close, but they're missing one critical piece.
Notice the buffer restriction in FlipPhaseAnti(), for commuting inversion gates with buffers:
The target bit currently cannot remain a buffer control bit, though it can remain a target bit. Inversion gates could commute with control bits if buffers could exist in an "anti-controlled" state as well as a "controlled" state, (per the conventions of Qrack). That is, commuting X with a control bit where |1> signals gate activation could just turn the control into one where |0> signals gate activation, instead.
Given that { CCNOT, H} is a universal gate set, and therefore so is { CCZ, H }, since the former can be composed with just the latter, to have this general commutation of single qubit phase gates and "inversion" (X-like) gates, with buffered H, controlled phase, and controlled inversion gates, as QUnit as is already largely designed, takes us a long way toward more efficient universal gates sets. (Extension of phase buffers to more than one control is a natural next step, but this issue is a small digestible chunk of work, along the way.)
(Note that H gate buffer commutation rules are extensive, but also not perfect. We have room for improvement, still.)
The real challenge of this issue is not just putting in the boolean to indicate anti-control; it's developing and implementing the ramifications of this new degree of freedom all throughout the commutation rules of QUnit.
Upon looking at the organization of the existing buffer code and thinking about how to implement this, I take back what I said about generalizing to buffers with a target bit and 2 or more control bits. The problem is scaling.
If we want to implement "anti-controlled" buffers, a boolean to indicate "anti-" or not on the buffer doesn't work, because we want to buffer both "anti-" and "conventional" control gates at the same time, and we use a map between controls and targets. Another obvious approach is turn each gate buffer into a "uniformly controlled" gate buffer, but the overhead for this approach scales exponentially over the number of control bits. Assuming we limit to singly-controlled gates, I think the "uniformly-controlled" variant over only two control states is easiest to implement, but this is with the understanding that we don't intend to carry this approach to any more than 1 control qubit, due to the exponential scaling over controls. If we want to buffer a CCNOT or a CCZ, though, we can decompose it with H, singly-controlled buffers, and phase gates like T and its inverse. Since T is a phase gate, and phase gates have commutation rules with every one of our types of buffers, T and general phase gates would optimally end up represented "buffered" in the state of single separable qubit "shards," so this approach might scale.
Per #344, "anti-controlled" buffers have been added. Subsequent pull requests will flesh out the optimization ramifications.
