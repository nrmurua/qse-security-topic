Part of #9417.  Related to #9419.
As an overview, the SabreLayout algorithm is a relatively small wrapper around some externally defined routing pass.  Qiskit generally uses SabreSwap as this driver by default.  The layout-specific part of the algorithm is approximately:
Our implementation of SabreLayout has two paths:
For initial support through SabreLayout, it is acceptable to only upgrade path 1.  Upgrading path 2 implies the more difficult, long-term direction of #9419 is taken, which can be done later once we understand more about how to route dynamic circuits.
Technically, SabreLayout should already execute on a dynamic circuit if a StochasticSwap instance is passed in to path 1 as the router.  However, this is logically not entirely correct; the "reverse circuit" operation will not recurse into the control-flow operations to reverse them, so the algorithm will likely produce very inefficient layouts, because part of its algorithm is stymied.
For the control-flow and classical operations currently implemented by Qiskit and supported by the other transpiler passes, implementing the reverse operation largely should just be a case of reversing the operations inside each control-flow block.  This is assuming that break and continue remain unsupported; these might have different properties.  Bear in mind that the "reverse" of the circuit doesn't have any real meaning in terms of circuit behaviour, it's just a tool we use as part of the algorithm; anything that logically lets us run the routing pass over the operations in the circuit in reverse topological order is fine.
