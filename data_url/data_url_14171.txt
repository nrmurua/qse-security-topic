The qc.qasm() step in the "how can we reproduce the issue?" section of this issue is very slow.
Upon profiling, 99.9% of the time is spent at https://github.com/Qiskit/qiskit-terra/blob/2062246191eb6c042c52aca6ef6de1d0233db314/qiskit/circuit/quantumcircuit.py#L5091 of  _qasm2_define_custom_operation. Where 99.9% of the equality check elapsed happens in the instruction definition comparison.
I was able to speed up the code from ~17s to 0.0096s by replacing that line with if previous_definition_source is not None:, but this probably requires examination to make sure it is fine for all cases.
With the following code
I found the elapsed to be ~17s.
It's only 100 gates, 5 qubits, and so should have been much faster.
No response
Thanks for the report here.  I totally agree that this situation sucks right now - perhaps the real culprit is our incredibly heavy definition of Instruction.__eq__, or even more generally, it's that our custom-instruction data model isn't super well defined around determining what an abstract operation truly represents, and when it could be equal to something else.
I've toyed with a design for OpenQASM exporting that is based around us "transpiling" the circuit to a Target representing something like an "OpenQASM 2 abstract machine" based on the header files we're targetting, but I'm not dead certain it would solve the reason the exporter is slow here, which is it attempting to deduplicate output gate definitions.
I will definitely have this issue in mind, but I can't promise much by way of timescales for when any of my more general fixes would come down the pipeline.  If anybody has sensible near-term suggestions for how we could improve performance quickly, I'd be interested to hear / implement them.
The slowest part of Instruction.__eq__ is 
The definition comparison was added in this commit. Since gate name collision is nownot allowed, this definition comparison seems to be overkill.
The definition was added in that commit because that PR was a major overhaul of the data model of internal objects, and made it such that instructions always carry a definition with them (or are opaque if they don't).  It's a totally valid, and very commonly used across Qiskit and its ecosystem to instatiate a base Gate and give it some circuit as a .definition, and that defines a building block.  That's what QuantumCircuit.to_gate() does, for example.  There are (unfortunately) lots of places that have naming collisions which do not represent the same operation, so the definition comparison is absolutely necessary there.  The docstring is just out of date during the PR you mentioned - it first gets added in 58437aa when it's accurate, then some time later Ali realised that the definition is a necessary part of the comparison in general, added it in 1cc4d6c but forgot to update the docstring.
This isn't to say it's a good situation - it's something that's developed over time and without a clear single direction, we've got into this place where there's several conflicting bits of data, none of which completely uniquely define a gate.  That's a situation we're trying to resolve now, but it's part of why I say it's not so easy to fix in the short term - there's a lot of extant code we're trying not to break with the comparison.
All that said, perhaps something that's fiddly but palatable in the near term is to override __eq__ on all Qiskit standard gates including MCXGate to skip the definition check.  That should hopefully solve your problem in this case (though it would leave the general problems caused by arbitrary custom instructions and the unclear data model).
All that said, perhaps something that's fiddly but palatable in the near term is to override eq on all Qiskit standard gates including MCXGate to skip the definition check. That should hopefully solve your problem in this case (though it would leave the general problems caused by arbitrary custom instructions and the unclear data model).
My current workaround is indeed to do a sed:
It works for my case, but I suppose it's going to be a small change in the code to be included in upstream, so that it helps others.
