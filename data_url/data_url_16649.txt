Can we generate QASM String from QASMQObj instead of generating from QuantumCircuit Object? (Reference: https://arxiv.org/pdf/1809.03452.pdf)
Hi @chahatagarwal , at the moment there is no direct Qobj -> QASM conversion without first creating a QuantumCircuit instance, but the path through QuantumCircuit should work in most cases. Is there an issue with the Qobj->Circuit->QASM path?
Is there a path from QASMQObj to QuantumCircuit Instance ? I think maybe through disassemble we can achieve. Anyways, I am trying to figure it out. But, yes from QuantumCircuit Instance, we can retrieve QASM String through QuantumCircuit.qasm()
File` "/home/usr/anaconda3/lib/python3.7/site-packages/qiskit/assembler/disassemble.py", line 141, in disassemble
circuits = _experiments_to_circuits(qobj)
File "/home/usr/anaconda3/lib/python3.7/site-packages/qiskit/assembler/disassemble.py", line 83, in _experiments_to_circuits
_inst = instr_method(*params, *qubits, *clbits)
TypeError: h() missing 1 required positional argument: 'q'
QASMQobj is passed to Disassemble function (Below JSON structure is converted to QASMQObj Schema using QASMObj.to_dict() method):(https://qiskit.org/documentation/stubs/qiskit.assembler.disassemble.html#qiskit.assembler.disassemble)
#experiment data
bell_state = {
"header": {"description": "|11>+|00> Bell", "name":"","qreg_sizes":"","creg_sizes":""},
"config": {"shots": 1024, "memory_slots": 2},
"instructions": [
{"name": "h",
"qubits": [0],
"params": []},
{"name": "cx",
"qubits": [0,1]},
{"name": "measure",
"qubits": [0,1],
"memory": [0,1]}]
}
#QASMQobj format for BELL STATE
qobj_data = {
"qobj_id": "bell_Qobj_07272018",
"type": "QASM",
"schema_version": "1.0",
"experiments": [bell_state],
"header": {"description": "Bell states"},
"config": {"shots": 1024, "memory_slots": 2}
}
Once, I get QuantumCircuit from disassemble function then we can generate QASM code using QuantumCircuit.qasm() function.
Inspite of passing the positional value for each gate, it is not able to proceed!
@kdk any suggestions ?
The disassemble function was written assuming a qobj generated by qiskit's assemble function. The problem here is that your input dict format differs from how terra generates the qobj. It's not structurally invalid per the qobj schema (or at least I don't think it is, I haven't checked) but it doesn't provide the hints the disassembler needs to reconstruct a QuantumCircuit object from the payload.
For example, if you were to build a bell state circuit using QuantumCircuit  and then run qiskit.compiler.assemble() on it and convert that QasmQobj object to a dictionary (with the to_dict() method) it would return:
Where this differs from your example is the experiment's header contents. Terra uses that to populate a list of registers qreg_sizes and creg_sizes (which are list of registers represented by pairs of names and sizes) as well as labels per bit qubit_labels and clbit_labels (which are just the register name and the bit index in a list for each bit). The disassembler requires these fields to be set like terra does so that it can reconstruct the registers exactly as they were in original circuit object and also so that that the qubits are used in the same order from each register. For example, on the h gate in the instructions list 0 in the qubits field is an index for the disassembler to do register_name, index = header.qubit_labels[0] when adding an x gate to the circuit object it's making.
While the disassembler could probably be altered to accept a general qobj that conforms only to the schema and not how it's used in practice by terra, I'm not sure if there is much value in that because the only user of qobj is the ibm quantum experience api.
The disassemble function was written assuming a qobj generated by qiskit's assemble function. The problem here is that your input dict format differs from how terra generates the qobj. It's not structurally invalid per the qobj schema (or at least I don't think it is, I haven't checked) but it doesn't provide the hints the disassembler needs to reconstruct a QuantumCircuit object from the payload.
For example, if you were to build a bell state circuit using QuantumCircuit and then run qiskit.compiler.assemble() on it and convert that QasmQobj object to a dictionary (with the to_dict() method) it would return:
Where this differs from your example is the experiment's header contents. Terra uses that to populate a list of registers qreg_sizes and creg_sizes (which are list of registers represented by pairs of names and sizes) as well as labels per bit qubit_labels and clbit_labels (which are just the register name and the bit index in a list for each bit). The disassembler requires these fields to be set like terra does so that it can reconstruct the registers exactly as they were in original circuit object and also so that that the qubits are used in the same order from each register. For example, on the h gate in the instructions list 0 in the qubits field is an index for the disassembler to do register_name, index = header.qubit_labels[0] when adding an x gate to the circuit object it's making.
While the disassembler could probably be altered to accept a general qobj that conforms only to the schema and not how it's used in practice by terra, I'm not sure if there is much value in that because the only user of qobj is the ibm quantum experience api.
Thanks for Suggesting an alternate way. I got the logic of Disassembler and thus it follows a strict schema structure! If it accepts a generic and basic form of QObj then it would be much better. (like .run() for Simulation)
