QUnit is already most of the way toward (and in other ways beyond) "stabilizer" engine optimizations. Basically, if we add special handling for Hadamard gates in the style of the rest of QUnit, and if we expand phase gate support a bit, QUnit will also serve as a stabilizer engine, (and a relatively inexpensive one, at that).
I'm going to add support for QUnit-style Hadamard gates that keep bits "clean" under Z, S, and T gates. It shouldn't be hard, and then QUnit will be a super set of the stabilizer engine concept. We already optimize controlled gates in a stabilizer-like way, but I'll extend the handling for these particular cases.
See #201, but work is ongoing.
A friend gave me reason to think about this again, and I'm experimenting over on the gottesman-knill branch.
I think I was trying to avoid an ad hoc handling for CNOT, to generalize anything I did to an arbitrary number of controls, or not do it. However, as long as an "ad hoc" correction were to give universally correct results, (up to phase factors that can't be physically measured, as usual,) there's no particular problem with it. If a user wants to use Qrack::QUnit as like an extended stabilizer simulator, it might be common enough that they'd expect to build multiply-controlled NOT gates out of other Clifford group gates, in which case they can at least have CNOT.
I'm not sure if the work in that branch is "universally correct," yet, but I'm not in a hurry to merge it in. I'll satisfy myself that the results are generally correct before I merge, so long as I actually can. Barring that, I'll leave my tinkering in the branch.
I'm thinking aloud, but this might be useful for reference:
If both control and target are "not dirty" and cached as plus/minus basis, we're filtering so the only possible initial states should be |++>,|+->,|-+>, and |-->, is the intent, to start. (Ultimately, we want to include phase gates, but this might or might not get us there, already, such as if this is up to overall phase. I'm not sure whether phase gates will break caching, here.) The outputs of a CNOT are then, respectively, |++>, |+->, |-->, and |-+>. For an "AntiCNOT," we add a couple of phase factors, and we have |++>, |+->, -|-->, and -|-+>. (Note the scalar multiplicative minus signs, outside the kets.)
Still thinking about it, and I should come up with more unit tests that target exactly this reasoning.
(This doesn't speak to the other handled case, of just the control bit cached in |+>/|-> basis, and not the target,)
For the other case, think of the possible inputs as |0+>, |0->, |1+>, and |1->. In both cases, right bit is the originally intended control, and left bit is the originally intended target. The truth tables look right to me, from a code trace. I think they're also both maximally commuting bases.
(The point is that we use equivalent circuits, under the constraints, but specifically ones which will maintain separated representation.)
To achieve the equivalent of an X gate, given the preconditions, we're free to directly swap the cached amplitudes. This also avoids any reaction the X gate in the QUnit API has to isPlusMinus. However, we're out of sync with the underlying QEngine, and we need to set isEmulated to true.
I'm done futzing for a while, but I'm thinking about it.
(It's actually only the equivalent of the X gate only if we reinterpret |+>/|-> as the permutation or "natural" basis, but maybe this needs to go in documentation rather than spamming the issue, apologies.)
I added some unit tests, including cases where just H and S gates are used that should hit input superpositions of the cases I exposited above, given the CNOT optimization preconditions. I think this is approaching readiness for merge, but I'll wait to go over it again tomorrow.
We might be able to close this issue, i.e. "efficient" gates and circuits available in QUnit might now fully encompass (and exceed) a definition of a stabilizer simulator as at least a Clifford group of CNOT, H, and phase gates. It seems likely, from my standpoint and memory with hands in the code, that we also have an efficient Pauli group, but my experience with group theory is honestly lacking and incidental for someone working in exactly this and related topics. (Further study of group theory would probably be a good route for me to try further extend the "efficient" circuit set, though, so I have something to look forward to.)
Putting fresh eyes to the code of QUnit, I think I caught an edge case where caching should have been invalidated but was not. I added a fix for this in the gottesman-knill branch. However, the fix caused test_qft_superposition_round_trip in the benchmarks in particular to regress by very roughly a factor of twice the log normal average time, at least at larger qubit numbers. Judging by the regression and the behavior I saw when writing the edge case fix, it seems QFT was hitting this case, and accuracy might have been affected. (The presence of bugs is virtually a law of software development, but I try to self-scrutinize to squash bugs proactively, and please always feel free to open an issue or pull request, anyone reading this.)
The performance regression is unfortunate, but we've seen this back-and-forth by one or a couple factors of 2 before. I'm trying to compensate with further general optimization, as I've done in the past, hence I've branched again to general_optimization.
This is leaving the scope of this particular issue, though, for Gottesman-Knill. The CNOT optimizations are in both branches. If anything of importance actually comes up, I'll track the optimization work in another issue, unless it's actually related to Gottesman-Knill.
See #233.
On the one hand, extension to a larger Clifford group set of gates could be tracked in this issue. On the other, with any complete Clifford group, work in this direction begins to fall under the heading of "general optimization," for QUnit. Hence, when #233 is finished being tested and merged, I think I'll consider this issue closed.
I think there's a bug, somewhere in the truth tables I was talking about above. "TrySeparate()" might not agree between QUnit and QEngine types, but "TryDecompose()" should. I'm reopening the issue to review.
With both bits in |+>/|-> basis, the method describe above and in the code works. When the basis is mixed, I can't seem to get it to work generally. I'm questioning whether this last "trick" of switching the control and target in that case is actually a pseudo-tensorial transformation of the truth table. Maybe the truth table looks that way, but the transformation is not actually via a valid Jacobian. Or, maybe I just can't find the bug, yet.
I think the bug is that, as I've described it, I'm flipping amplitudes first, then controls second, which should put me back where I started. Seems like there's a phase flip on | - 1 > / | 1 - >, which I can't immediately figure out, but it's moot. It's either a mistake in my math, a phase flip inconsequential to Hermitian operator expectation values, or some feature of the statistical ensemble exchange rules that really doesn't bother me, right now. I think I just leave the last case out, for now, and regroup.
We had a bug, and I don't immediately have a way to recover maximal optimization, so the sub-optimal but correct fix will go in, for now. We're not yet fully covering a Clifford algebra, this way, so this issue will stay open. We do optimize a case we didn't handle optimally before, though.
If we consider the mixed |+>/|-> with |0>/|1> case we particularly want to handle now, compared to the fully |+>/|-> case we already optimized, it's clear this case we don't handle is the only one of these in CNOT where the eigenstates of our basis have any conditional dependence. It's also clear that QUnit just can't handle this as-is, in terms of single bits in |+>/|-> or |0>/|1> basis, because of that conditional dependence, because we get states like 1/sqrt(2) * (|00> + |11>). It seems like its a straightforward extension of this same kind of QUnit basis Boolean tracking to two or more conditionally dependent bits, though. (Maybe this is a better route forward than phase gates, per #241 and that whole run-around I've been on.)
I've continued to think about this, and I realize that, if I flesh out the whole of what I originally hoped for the sparse state vector optimizations, for QEngineCPU, then QUnit -> QEngineCPU will effectively cover the last needed case of CNOT, for a full Clifford algebra. The "sparse" constructor option already effectively makes this RAM efficient. However, I also wrote an internal API on sparse state vectors that will hopefully let us limit to iteration over just nonzero amplitudes. This will effectively give us efficient execution over Bell states, and similarly entangled states.
See PR #255. Sparse state vector optimizations, in concert with QUnit, now realize this optimization goal. I would like to make it more general in the future, but I will open a new issue or issues at that point.
Per commentary in #255, we took a general step forward, there, but it might turn out that the only practical way to truly reach a super set of stabilizer simulators is to implement an actual stabilizer layer, probably "sandwiched" as QUnit->QFusion->QStablizer->QEngine. The stabilizer "layer" might actually be a hybrid QEngine type directly, if it can't be separated as an independent layer. The point would be that a stabilizer simulation is carried out until a gate that can't be handled as such reaches the stabilizer layer, at which point we convert to state vector representation and proceed as "Schr√∂dinger method." Under the QUnit layer, it seems we could get two major advantages:
Immediately, we have other priorities, for continuing work. However, I'd like to experiment with this, after those other priorities are tended.
Recent work appears to give linear performance on a selected universal set of gates. In particular, the last case of CNOT I was talking about above has been handled, to at least an additional order, though there might be higher order inefficiencies. Given that, up to what might be fundamental limits of our approach, I'm actually going to consider this issue finally closed!
