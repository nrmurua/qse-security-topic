The Qobj data that represents the state or operator is stored as a sparse (csr) array. In most cases this makes sense, as the memory requirements for many solvers would be excessive. There are many cases though for small systems where memory would not be an issue, and significant performance improvements could be gained. This has been demonstrated in the optimal control modules. Many matrix operations are much faster in the dense representation.
Originally suggested in #26. This is now more urgent. In answer to #370 I submitted #397. However, it was found that significant performance degradation occurred in the control evolution calculation for small systems, and as such a retrofit of ndarray option for internal operator type was made. This leads to pretty untidy code, and means that subclasses for propagator and gradient calculations, fidelity, and evolution calculations all need to implement conditional methods.
Implementation of a dense Qobj would resolve these problems, and as mentioned above, could lead to performance improvements in many of the other solvers.
Many of the solvers assume sparsity, and so they too may need changes to support dense states and operators.
In general, great care would need to be undertaken in implementing the dense Qobj. Those methods that did not support it would need to check the Qobj type when called
Closed in dev.major by #1351 (and the gajillion other PRs that came before it). ðŸŽ‰
