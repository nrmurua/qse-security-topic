Hi,
This is not a feature request, I'm just trying to wrap my head around the infrastructure - if this is not the right place to ask, please let me know where I can ask learning questions as a total newbie to quantum computing and the Rigetti stack.
I was wondering what is the reason behind that I can create a quantum gate based on a non-unitary matrix? Is this something I'd have to be careful about in the future as well, or Forest is planned to have a feature to validate against non-unitary operators? Also, it's one thing that it can run on the QVM - but how would this operate on a real quantum processor?
Thanks @balopat that's a great question that brings up a few interesting points.  We would definitely like to have unitary gate validation added for defgates and on an actual processor a gate like your example would throw an invalid error.
We are planning to add server-side validation of unitarity.  Would you find it useful to have something check on the client-side as well?  It would be very easy to add an assertion into the DefGate abstraction in pyquil.  I'd be happy to help you add this if you have any questions!
In general operations on real quantum processors aren't always unitary.  Noisy in quantum systems can be non-unitary and the ability to simulate that noise is very useful.  Right now that is outside the exposed API for Forest and requires switching from wavefunction evolution by applying unitary matrices to density matrix evolution by applying process matrices.  Several people have asked for density matrix support and we're planning to add it in over the longer term.  This is more of an educational point with regard to your initial question, as it wouldn't work to implement non-unitary noise using Defgate in its current form.
Thank you for replying @willzeng! The client side is indeed easy, and fits well into your existing validations and saves you processing time on the server side;). I raised a PR for it, let me know if I need to improve it. I'll need to read more about density matrices and non-unitary evolution, thank you for bringing it up - from the perspective of my early studies this is surprising! But it seems to me - as you pointed out as well - that this is an alternative way of modeling state evolution in time. In the end what really decides the matter from a design perspective is that the concept of the gate itself makes the unitary matrix representation mandatory as far as I understand.
I thought I might note what the Quil spec says about this.
The gate is declared using the DEFGATE directive followed by  comma-separated  lists  of  matrix  entries  indented  by exactly four spaces. Matrices that are not unitary (up to noise or precision) have undefined [7] execution semantics.
[7] Software processing Quil is encouraged to warn or error on such matrices.
Accordingly, an implementer of Quil can define how he or she pleases what happens when someone defines a non-unitary gate.
@tarballs-are-good - very interesting! I will read the spec the next time. I guess it makes sense to leave it open to the implementer on the spec level but encourage it - as checking the unitary property is not for free (I wonder if this would actually ever become a burden on large matrices on client side generating complex quantum programs!) - hence the implementer can choose to just point it out in the documentation that the behavior's going to be undefined.
Closed by #21
