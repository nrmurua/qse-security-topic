Semantic versioning
MAJOR.MINOR.PATCH
Before MAJOR becomes 1, updates to MINOR can make changes to the public facing api.
After MAJOR becomes 1, updates that break the public facing api need to update MAJOR version, MINOR updates have to be backwards compatible (after MAJOR>=1)
PATCH is for bug fixes.
Then the question is how to fit this in with git and also what the version file has in the repo.  We use tags to mark versions.
Two methods I like
master branch acquires tags for major or minor version updates.  We develop on master, and push changes there as we are developing.  When we are ready to release a new major minor update, we simply add the tag.  The version file gets updated at the commit where the tag is.  In between adding this tag, we use pre release versioning with an "a" for alpha (https://www.python.org/dev/peps/pep-0440/).  The tricky part then is dealing with PATCH.  Here we need to have a separate branch because these bug fixes to stable releases can't develop off of master's head, where development work is happening.  So we need to create a branch for these and also apply the appropriate tags, since the branch can come off of a MAJOR.MINOR version the branch name should include that, so something like "patch1.0" and then the fixes can be applied to these branches.  They can then be appropriately tagged.  When following this patter then patches will likely also need to be cherry-picked back into master (unless the newly developed version no longer has the bug).
master and dev branches.  Here master only has branches corresponding to updates in the semantic versioning. all of the development occurs in dev.  When a version is being updated, it will be a merge from the dev back into master.  Patches occur on master and get the new PATCH tag applied.  Patches would also have to be merged in to dev.  Again we can use the pre release versioning for the name of the version in the version file.   (There is a variation on this that I've seen where there is master, dev, hotfix: patches got to hotfix and then are merge into master and into dev separately.)
I like 1 mostly because it is nice to be able to in most cases when developing only worry about master.  If we are not going to have a lot of PATCHes, then I think this is the way to go.  However if we have a lot more PATCHes, then I think 2) is a lot better since we don't have all these dangling odd patches.
Also I think we should clean out branches that aren't whatever we choose to have as our branches in the repo...I know it doesn't really matter, but sometimes people do go look at the branches to try understanding versioning and how development occurs.
I support option 2. master and develop is a standard for many people in the open-source community.
We now have a version file and I've tagged a v0.1 release.
Closing this now as we are following 1. for now.
