Following the discussion and investigation of #10049 and #10051 , it came up that there may be some room for improvement in the performance of the ConstrainedReschedule pass, but more investigation is needed. This issue is to track what's been looked at so far, and decide how best to resolve.
Loosely, ConstrainedReschedule loops over all the nodes in the input DAG to see if any are not aligned with the defined {acquire,pulse}_alignment constraints. If any are found, the pass calculates the offset needed to align that node with constraints, and iteratively (or recursively) propagates that shift to any subsequent nodes which depend on the shifted node (and need to have their start time delayed to avoid overlapping).
I ran a few random_circuit(width=100, depth=_) circuits through the PassManager from #10049 for increasing depths and got the following plot of (scheduling stage) runtime vs. instruction count:

It seems like there are a few worthwhile things to look at:
I added a quick change to count the number of times each node was included in nodes_with_overlap for the example in #10049 (~96k Instructions post-transpile) and got the following map examine counts vs how many nodes were examined that many times. i.e. 556 nodes were examined once, 101 nodes were examined 3M times each, 4 nodes were examined 16 times each, so on.
