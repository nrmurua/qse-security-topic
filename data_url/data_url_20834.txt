The SHA2 and the Haraka variants of SPHINCS+ are not thread-safe due to global state.
This is a significant problem for downstream consumers, including liboqs and rustpq.
What is unsafe about SHA2 in common? I recognize that it's unsafe in SPHINCS+, where the precomputed hash state (based on the public key) is stored globally for SHA2 and Haraka; I suppose this should be fixed by passing it around between functions.
Unsafe SHA2 in common doesn't affect liboqs, since we have a separate SHA2.  I think it's essential that our crypto_kem and crypto_sig implementations are thread-safe since that's we intend people to consume.  Thread-safe common would be nice, but not essential at this point.
I misunderstood that it's in the SHA2 function as well, I got the same problems with the SHA2 and Haraka and found it in haraka.c in the SPHINCS-haraka implementation; but discussion with Joost  clarified that indeed this is a SPHINCS problem.
Meanwhile I've hacked sphincs-sha256-192f-simple to eliminate the state (ha!) in 3cdb3e4. It does not immediately seem straightforward how to do this in a clean, nice way in Joosts' master version, that doesn't contaminate the SPHINCS-SHAKE256 variants that don't need this state.
I don't think there's a way around passing the state through every function, including the ones that are shared between hash functions; varying this would introduce an extreme amount of code duplication.
Somewhat related to what you brought up elsewhere (but I cannot quite find the comment anymore); of course all this SPHINCS code is automatically generated/namespaced based on a 'canonical' repository. I'm still trying to decide what a nice place for that is. I'm not sure if that should be sphincs/sphincsplus, since it does contain pqclean namespace placeholders. I suppose more schemes have this issue. Should we have a central place for that kind of code (+ code-generation-code) somewhere in pqclean?
Small nit: I'd prefer to pass it as (one of the) last argument(s), to somewhat counter the impact on readability.
Small nit: I'd prefer to pass it as (one of the) last argument(s), to somewhat counter the impact on readability.
Yeah, I was unsure whether to do it as the first argument (because it's always mutable) or as the last argument (because it's mostly unrelated to the other arguments and because then it won't take the place of a stack-passed parameter on amd64, especially where it isn't necessary). I'd suggest reimplementing this in the 'canonical' code in a way we like most.
of course all this SPHINCS code is automatically generated/namespaced based on a 'canonical' repository. I'm still trying to decide what a nice place for that is. I'm not sure if that should be sphincs/sphincsplus, since it does contain pqclean namespace placeholders. I suppose more schemes have this issue. Should we have a central place for that kind of code (+ code-generation-code) somewhere in pqclean?
I'm not sure it should go into something managed by us / under the PQClean umbrella. A canonical repo should probably be maintained by the submitter/maintainer of the scheme. They will probably want to do some maintenance and/or changes upon round 3 and then it's probably most convenient if they can just play with their code in their own repo. Is there not a way to slightly generalise the generating code so it can also work for your NIST versions and still go into sphincs/sphincsplus? (maybe just allow the script to accept any namespace, including ''? Could also be convenient for other people needing SPHINCS+ who don't want  to adopt from PQClean for some reason.
