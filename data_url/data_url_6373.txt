It seems we were overcautious in implementing MUL/DIV variants: I think, (besides multiplication by 0, which is not expected to have an inverse,) in-place multiplication without a carry register actually is unitary, so long as we consider the classical multiplicand to be constant. That is, since we are left multiplying by a classical value, (call an instance of this value "x,") our truth tables need only preserve input vector norm and reversibility for any particular given x, (only respectively for all possible x,) which is as "trivial" as unitary addition and subtraction. That is, (truncated) integer output possibilities are one-to-one with input permutation basis eigenstates, for any particular x.
We should go ahead and implement these multiplication/division variants. I'm already at work on them.
I think I might be wrong, above. That's kind of the more fundamental issue, though. I have a branch open, but I'll think about what to do with it.
There's not much more to say about this, for now. Despite some of the commonly offered simulator implementations of integer multiplication, modulo 2^n multiplication on an n qubit register is simply not generally unitary. (Unitary variants we have implemented include n qubit + n carry qubit variant and an out-of-place modulo N multiplication.)
