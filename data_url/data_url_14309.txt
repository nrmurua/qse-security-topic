The transpiler is not remapping virtual register to physical registers correctly in the transpiler.
Yields
I would expect the physical qubits to be used (which are used in the top-level nodes)
Propagate the register updates to child blocks of control flow operations.
Copying over some offline discussion on this topic:
The current model is that consumers of ControlFlowOp need to track and apply the qubit mappings themselves as they recurse in, so there is a workaround - for example, here in the VF2Layout passes: https://github.com/Qiskit/qiskit-terra/blob/396b06c8a1fbb37692dd9b12f7b7bb6c322f1e93/qiskit/transpiler/passes/layout/vf2_utils.py#L45-L52.
At the moment, the form is consistent with how gate definitions have to be handled within the transpiler (the definition uses its own qubits, and it’s up to the pass with context to apply the binding of circuit qubits to gate arguments).  Control flow is very shoe-horned into the existing “instruction” structure, so by default it’s just subject to the same rules.
Within the current structure, if we do normalise the qubits inside the control-flow ops, there’s a data redundancy between the qubits and clbits arguments of the CircuitInstruction context object, and the qubits and clbits fields of the internal structure, which increases the possibility of way more subtle bugs where some passes use one source and some use the other (and they’re out-of-sync in the ordering).  A minor positive of the current state of affairs is that things fail noisily if a pass doesn’t done the binding correctly.
That said, I fully agree that the current form sucks for actual use in the transpiler.
Kevin and I have played around with alternate data structures for the transpiler a couple of times late last year, because there’s a need to empower DAGCircuit with something more now that there’s control flow present as well, but it’s hard to match the data-flow requirements we want for efficient qubit routing with the control-flow requirements we need for the classical components.
If we apply the split into a control-flow basic-block structure too early, we potentially make it near-impossible to perform a good qubit layout+routing (which is a massive chunk of getting good performance at a high level), but the later we leave it, the more components need to be explicitly aware of all the complexities of the implementation of the classical control flow (which is the current situation).
