Suppose you want to simulate VQE for a large-ish number of qubits for a system like, say, diatomic nitrogen (which is 20 qubits in a minimal basis.) The only way I have found to make this calculation tractable is by running it on a GPU and also passing the arguments expectation = AerPauliExpectation() and include_custom=True to the VQE instance when using the backend AerSimulator(method=statevector, device='GPU').  When using the UCCSD ansatz and passing a HartreeFock initial state, initializing all the ansatz parameters to zero, the objective function evaluated is always -0.0 when using qiskit-aer-gpu > 0.8.2. Not only is this a physically unreasonable result, but it is inconsistent with running the exact same program with qiskit-aer-gpu = 0.8.2, which returns an initial evaluation of ~ -132 Hartree. However, using version 0.8.2 seems to result in a different bug related to the transpilation of the ansatz, so using this version isn't an option either. For 0.8.2, for some function evaluations, it will fail to transpile the circuit, resulting in the error:
terminate called after throwing an instance of 'std::invalid_argument' what():  QubitUnitary::State::invalid instruction 'rz'.
Here is an example of a piece of code that results in the bugs mentioned above:
For qiskit-aer-gpu >= 0.9.0, the callback will always print out a value of -0.0. For qiskit-aer-gpu = 0.8.2, it will occasionally fail to transpile the UCCSD ansatz.
For all versions of qiskit-aer-gpu, first function evaluation energies are closer to the Hartree Fock energy. It should also not fail to transpile for older versions. (This issue may be present in the current version as well, but I can't explore that without first having this other bug removed.)
I have tried this with various versions of Qiskit-terra and Qiskit-nature, since those modules are involved here as well. I have not yet observed changing the versions of these packages to make a difference. Running it on the CPU with qiskit-aer-gpu also causes this problem. Running it on the CPU with regular qiskit-aer = 0.10.2 causes this issue to go away. The common denominator in all of this is the qiskit-aer-gpu package specifically and how it calculates expectation values of observables for systems larger than 14 qubits. (14 qubits and smaller seems fine). Something changed from version 0.8.2 to 0.9.0 that introduced this bug. I would start by looking here.
Another thing I note, which may just be a coincidence, is that -0.0 corresponds to what the expectation value of the spin magnetization operator should be in this instance. It's almost like the GPU simulator is calculating the expectation value of the wrong observable.
EDIT: I think some of my previous observations as to when this happens and when it doesn't are at least partly wrong or there's more to it. It's difficult for me to pin down exactly what causes this to happen. It seems to sometimes happen with regular qiskit-aer (without GPU) as well as sometimes with systems with fewer numbers of qubits (such as H2O in a minimal basis, which has 14 qubits). It also seems to happen sometimes in qiskit-aer 0.8.2.
I'm closing this for now because this issue seems to have something more to do with Qiskit-terra's Opflow, so this is really a terra issue.
