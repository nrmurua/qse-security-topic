I have tried implementing quantum generative adversarial networks using tensorflow-quantum and cirq. For this, I have built a quantum-based model of generator and discriminator.
Notebook link: link
The outputs aren't converging as per the norms of GAN value function. Can you suggest the error that I might have incurred in the code. Also, as the dataset that I considered in this is a 2D gaussian distribution, is it possible to construct the output of generator (which is quantum) aside the 2D gaussian distribution to check whether the output is converging or not (because the real distribution is in Euclidean space and the quantum states operate in Hilbert space). Please let me know where am I making an error.
I think you will be a little hard pressed to find someone willing to debug hundreds of lines of code for you (I already dislike debugging my own code)! The best I can do is refer you to existing TFQ works and discussions of GANs: https://github.com/tensorflow/quantum/tree/research/eq_gan, #325, #339. I will also note that GANs are notoriously difficult to train in classical ML, and quantum GANs only add to the training challenges. So it is possible there is no bug, just not an optimal training setup (see: https://github.com/soumith/ganhacks, https://wangyi111.github.io/posts/2020/10/gan-tricks/, https://chloes-dl.com/2019/11/19/tricks-and-tips-for-training-a-gan/).
Thanks for the links!
Although, I have got a very basic doubt regarding Q-GAN. I have got a classical gaussian distribution data in 2D space (using numpy.multivariate_normal()). And in my QGAN, I am using the generator and discriminator both quantum based models. But the model never converges to the dataset. Here's how I am doing it (taking 2 qubits in both discriminator and generator):
Generator: 2 qubits -> Data Encoding -> Ansatz -> Observable (on both qubits, say O1 and O2) -> project [O1, O2] on 2D space
Discriminator: 2 qubits -> Data Encoding -> Ansatz -> Observable (on first qubit only)
What I believe is that, according to me, the actual error comes out to be in the output of generator, because I don't think observable as output data points can be considered to be projected on 2D space as it is just measurement.
Can you help me out with this?
Although there are different kinds of QGANs, it sounds like you are going for the loading distribution one (https://www.nature.com/articles/s41534-019-0223-2). In that case, what is happening is you are trying to get this generator to learn to be in a certain state (e.g. a Gaussian). First, in your generator you don't really encode anything. You can start off with just Hadamard gates (or do more advanced things like normal or random, see table 1). Second (and to answer your actual question), the measurements of the generator are sufficient because they are an approximation of the distribution. We are trying to prepare something like 0.1 |00> + 0.3 |01> + 0.8 |10> + 0.3 |11> (something Gaussian-ish) for 2 qubits. That means we can approximate the probabilities of each of these states just by measuring them and looking at how often we get samples. Of course, analytically computing the statevector is super expensive and requires a ton of shots, this is why a neural network (or QVC) is used as a discriminator: to approximate this (i.e. to learn from examples, what we would expect from Gaussian distributions).
But isn't the case in GAN, where we input the noise (in its latent dimension) and try to extrapolate/vectorize/manipulate it in such a way that it somehow mimics that noise to actual/real distribution. If you mean that we don't need any encoding, this means that we don't have to inject any sort of noise (of a latent dimension) , or say noise state, which then gets manipulated to a real distribution.
That is certainly true in classical GANs (and probably some QGANs, not super up to date), I'm just going off the data loading GAN paper: "The generatorâ€™s input state is prepared according to a discrete uniform distribution ... Preparing a uniform distribution on 3 qubits requires the application of 3 Hadamard gates, i.e., one per qubit." Maybe there is room for improvement on the latent space (bam that's a paper idea right there), but it doesn't seem necessary to achieve their results.
Thanks for the reply! It was really helpful.
