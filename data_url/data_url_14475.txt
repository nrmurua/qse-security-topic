One feature that is missing from the full transpiler right now is support for working with tuned fixed angle gates in the target. By default most passes work exclusively with the gate name, and for most gates this is fine. But for gates that take parameters we may need to distinguish between parameterized implementations of the gate and those with fixed angles. In the target this is handled by using a unique name for the tuned variants and then setting the operation instance to be set with a fixed angle, for example:
target.add_instruction(RZXGate(pi/4), name='rzx_45'). A concrete example of this is starting in #7795 the UnitarySynthesis pass can support selecting a tuned rzx and synthesizing a unitary into that basis. However, if this is used later passes will fail because there is no matching rzx name in the basis (assuming the above example as the gate.name != target name). In such case we need to look at the instruction instance to determine the tune variant is available. For the transpiler to support working with tuned variants (and potentially still also supported the parameterized form too) we'll need to update any basis aware pass to not only look at the gate.name attribute but also the Instruction object and compare it to the one present in the target. The other option is to somehow set a unique name for fixed angle gates in the circuit (so they match what the target is using). However that will be difficult in practice because there are no guarantees on what name the target is using.
The other longer term issue is how does this work in the model #7624 which is looking to move us towards a model where numeric parameters are defined outside of the Instruction object. This breaks the assumptions made by the target around fixed angle parameterized gates and how they're represented.
Talking with @jakelishman about this briefly yesterday the path forward here with #7624 in mind is probably to store the parameters for each instruction in the target directly instead of relying on the params attribute. Probably either in an internal dict mapping gate_name -> parameters or  as a new named field on the InstructionProperties (it really depends on whether we want to supported different parameter values on different qubits or not I guess). The tricky piece (as with most thing on #7624 imo) is how we maintain compatibility with what exists now.
