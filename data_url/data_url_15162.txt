Transitively part of #9417.
Transpiler optimisation level 3 adds in extra passes to resynthesise all runs of 2q blocks.  Doing this involves finding the runs of blocks, which is the pass Collect2qRuns, which mostly just delegates to DAGCircuit.collect_runs (via DAGCircuit.collect_2q_runs).  This whole chain needs upgrading to be able to handle control-flow.
In particular: DAGCircuit.collect_runs needs an upgrade to its output format to allow the specification runs that are nested within control flow.  Control-flow operations that act on two qubits should not themselves be considered part of a run, although their contained block may be a run of itself.
For the new data format, there is likely some overlap here with #9423.  The new data format should be backwards compatible with the old one. That is, a circuit without control flow should produce the same output in the old and new forms of this function, since it is a user-facing method.
Fixing this should automatically upgrade the analysis transpiler passes Collect2qBlocks and Collect1qRuns (and this should be part of the test suite). This alone will not enable the transformation pass ConsolidateBlocks to read this information - for that, see #9426.
I'm finding the details of the relevant structures are slightly different than they appear in the comment above. On today's main branch, as well as that on Jan 23, 2023. The main ideas are the same. To try to get the details straight:
A few questions:
It seems clear that we need to recognize control flow nodes in rustworkx.collect_bicolor_runs. I don't immediately see a way to do this without changing the API of this function. This is not a problem for qiskit because collect_bicolor_runs is called in only one place and it is not exposed. But it would change the API of rustworkx. And it would do it in a way that begins to look tailored to the needs of the problem at hand. An alternative is to rename a copy of  collect_bicolor_runs and modify it.
Do we need to do something similar for  rustworkx.collect_runs which is callled by DAGCircuit.collect_runs ? The code for these is currently independent of that in the previous paragraph. (The opening comment seems to imply a call chain collect_2q_runs $\rightarrow$ collect_runs. But this is not the case in the code today.)
We could simply include the control-flow nodes in the output of the rustworkx routines and then postprocess it in Python. But I guess this is unacceptably inefficient. It is better to do this work on the rust side. Even if it's possible to analyze the PyObjects on the rust side, I don't see this done in the code at present. Also, it would be qiskit-specific and would not belong in rustworkx. Instead this is always done by passing python functions to the rust side. Two options are: 1) Modify our new copy of rustworkx.collect_bicolor_runs to take three functions rather than two as arguments. Pass a boolean function that returns true on a control flow node. 2) Use only two Python callbacks, but instead of a boolean function, use a function that returns an integer. This would indicate whether the node is a gate or a control flow node or something else.
How do we indicate that a run is in a block in a control flow node? We could  wrap the run in a class. This could be created by yet another Python callback on the rust side. It would be nice to find a better way.
How will these blocks be used? That would inform the design of the data structure. For example suppose we are resynthesizing 2q gates. Is the idea to descend into blocks in control-flow and do the same. In this case, I just a wrapper as described above is sufficient. But we might want to use this data structure for other purposes as well.
If I read the OP correctly there shouldn't be any rustworkx api changes needed. I see it more of a division of work that's needed here. First we need to update the filter function argument to the rustworkx calls used in the dagcircuit api to set it to not include control flow ops. Then we need to update the pass to recurse into control flow blocks and run the dagcircuit collection methods again inside each of those and store that nested run/block info in the property set. Finally we'll then need to update the consolidate blocks pass to read whatever data format is put on the property set and consolidate the internal runs/blocks into unitaries identified inside the control flow blocks.
About collect_2q_runs delegating to collect_runs: I probably misread the functions, or I just looked at them at thought "those look very similar" then screwed up when writing the post.  The point is that the all upgrade in the same way, at least.
About Collect2qRuns: I probably typoed and meant Collect2qBlocks, or whichever way round it's meant to be.  There's like 4 passes that are Collect<X><Y>, where Y appears to be pseudorandomly selected from "blocks" and "runs".
For the rest, what Matthew said is what I meant.  I didn't spell out what the data structures should look like, because I was just trying to provide a sketch for someone else to implement from - if I'd looked into it deeply enough to already know the exact data structures, I'd probably have been deep enough to just write it myself in an hour or two.
thought "those look very similar"
I think the "moral" of story in the OP was clear enough.  Good that you cleared this up. I was not 100 sure of the details because occasionally strings I don't find with grep are in another repo.
Ok. So the new logic is all on the Python side.
It's likely that we finish at least a few of these issues for supporting control flow in optimization before releasing. Maybe we can do a release note for all of them (or a group of them) rather than a release note per PR.
In particular, it's time to make a release note for #10260. Or, we can make separate release notes, and consolidate them a single note looks better.
Thoughts?
For posterity and my own understanding, is it important that we preserve the mapping of from which block consolidated runs come from?
From your comment @jlapeyre on #10260,
In particular, information on which control flow op and which block within it the runs come from is lost.
it sounds like we don't mind losing this information, but I'm curious why.
@kevinhartman I think my comment is mistaken. Considering control flow ops on the DAG, the blocks of ops inside are QuantumCircuits not DAGCircuits. In particular, they are not indexed in the top-level DAG.
So in order to work with ConsolidateBlocks I have to add more structure. Furthermore, it would be nice to avoid converting repeatedly from DAG to Circuit (more than we already do)
If we merge
then this issue (#9425) is obsolete, unless I'm mistaken. It might become relevant again if we redesign in the future.
This issue is obsolete. We don't have any near term need to complete this task.
