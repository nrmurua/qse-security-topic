A new unit test has been added in https://github.com/vm6502q/qrack/tree/v3.1_prep. When the QFusion bit threshold is set to a reasonable amount, like 3 qubits, it becomes apparent in this test that a large numerical error is introduced somewhere around the transition point of buffering.
I do not know what is responsible for this, yet, after a large amount of time isolating and attempting to diagnose the issue. I suspect that it's related to out-of-order asynchronous execution around the gate fusion threshold. I suspect this because the unit test can correctly match the result of an operation that is always not buffered, to both cases of entirely buffered execution and to entirely non-buffered execution, as the case may be, but something goes wrong around the threshold where there is some but not complete buffering. The entirely unbuffered operation should be a reasonable control case, though, because QFusion does not directly affect its execution.
Acknowledged.  Consider recording the sequence of async exec steps, or instrumenting the capability to execute them in an explicit order rather than through an implied async mechanism.
That tooks days to isolate. However, it's fixed by bbe6ff6
The primary issue seems to have been that control bits were not flushed, because of a couple of out-of-order lines before a return that interrupted the method before buffering.
Additionally, I made the decision to force a flush on any call to UpdateRunningNorm(), for general safety. I had previously assumed that the lagging norm usually wouldn't be a significant issue for numerical accuracy, but it's less safe. However, in the course of normal execution, this method is not called on single bit gates that need normalization; the norm is calculated in the gate application itself and applied on the next step.
I'm testing and deliberating over the UpdateRunningNorm() flush, right now.
I've undone the UpdateRunningNorm() change in 1ff8eaa
If the total norm ever differs by more than about 10^(-11) scale for float accuracy, something else has gone wrong that needs to be corrected. It's not worth the performance hit. The user can call Finish() immediately before UpdateRunningNorm() if such a level of precision is required.
