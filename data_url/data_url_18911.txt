In OpenQASM2 the entry and exit points of a quantum program followed a Pythonesque top-to-bottom model. Instructions begin executing from the top of the file, down. Unlike Python, OpenQASM2 provided no external libraries for system IO, meaning that there was no IO in OpenQASM2 programs. Consequently, once written OpenQASM2 programs cannot depend on runtime input arguments. A "hack" of returning all declared classical registers to the user was required to return outputs in Qiskit via the Result object.
OpenQASM3 has been explicitly designed for the goal of real and near-time classical compute. From the perspective of near-time compute it is desirable to be able to reuse the same compiled program and link it against new classical input arguments so as to enable low-latency round-trip execution between the host computer and the QPU coprocessor. In the near-term devices will not be capable of executing quantum machine code, rather compiled programs will be executed by a system runtime for which a host-level API is provided. This accelerator model is very similar to that of other classical accelerator systems such as OpenCL and Cuda. These systems declare to the compiler that certain functions should be made available as entry points from the host using function qualifiers like __global__ and _kernel.
To support real-time compute OpenQASM3 provides a richer classical type system and subroutines with input/output specified within their signatures. For example,
declares a reusable subroutine that accepts a single angle parameter bar and may be applied to a qubit, q, qubit q; bit output = foo(pi) q;. At first glance, subroutines provide an excellent foundation for host-level entry points Ã  la Cuda/OpenCL. However, we quickly run into a problem with qubits.
In OpenQASM3 qubits may not be passed as runtime arguments for a precompiled program in the near-term as swapping qubit's will dramatically change the compiled program on devices. If qubits were capable of being declared within subroutines one could just enforce that entry point subroutines must have no qubits as arguments. However, qubits are also not capable of being declared within a subroutine in OpenQASM3 in an effort to declare all quantum resources at the global scope and avoid the complexities of dynamically allocating a qubit (should we consider relaxing this requirement?).
One way to define an entry point using subroutines is to allow using qubit's declared at the top-level from within a subroutine, along with the requirement that such entry points must not accept qubits as arguments. An example is below:
This subroutine would then be exposed as an entry point to be linked against new input parameters at runtime. The benefit of relying on subroutines is that the entry point IO is well specified by the Qiskit type system (in theory ðŸ˜„ ), we can accept/return structured types from/to the host runtime. From the perspective of the host, this would look something like (dropping a lot of boilerplate that would likely be required)
Unfortunately, the approach above introduces the problem of being able to use global variables within a program and is potentially concerning.
An interesting side-note is that this is a step forward to resolving the "ancilla" problem in a hacky way, as ancillas could be global qubits declared at the top-level and managed as ancillas by the programmer (this is assembly after all...).
If declaring qubits locally within a subroutine were allowed, the example would become
We could limit in the near term that qubits may only be declared in __global__ subroutines and that __global__ subroutines may not be called from other subroutines to recover the behavior of using qubits declared at the top-level scope, without the complexities of introducing arbitrary declaration of qubits or using global qubits. This requirement could then be relaxed down the road without affecting existing programs.
Other suggestions are very much appreciated @stevenheidel.
The other suggestion we discussed was to stay closer to OpenQASM2 here and always have the program entrypoint be the top-level file. Then unbound parameters could be declared as a special syntax at the variable level.
near-time classical compute
When the classical compute gets close to the quantum compute then the memory can basically be treated as shared memory. So really any classical register could be overwritten during program execution. The same applies to output registers.
Adding a special syntax to these variables is really more a hint to the compiler to treat as an opaque value.
Tagging @caryan on classical memory models.
So I think this is not an issue of code reuse or entry points*. It's basically the issue of I/O.
Examples of inputs we discussed are input angle \theta or loop trip count n. We want to signal to the compiler that, no matter how the program get rewritten, those input variables must be preserved (cannot be combined or eliminated).
Example outputs can be some subset of classical bits or some bits cast to integer.
Explicit entry point via main() is one way to solve it. It is more familiar, and we can specify that whatever is passed to main() is the classical input and whatever is returned is the classical output. However it has a pretty significant disadvantage IMO in that it loses backwards compatibility.
A special syntax for tagging input/output is another way to solve it. We declare classical variables in the normal way, and just tag some as input/output. This is slightly non-standard, but is fully backwards compatible. And I don't think there's anything that we can't do with this method.
So right now I'm leaning towards the 2nd method (as detailed in @stevenheidel's comment above).
*Entry point to me implied that you want to be able to start the circuit from multiple places/subroutines. This is not possible, as we do not allow qubit allocation in subroutines. I also would argue that if you have a program F->G and another one F->H (where F, G, H are subroutines), then these are 2 different OpenQASM circuits. I think you can still do compiler optimizations where you compile F once (including resolving it all the way down to pulses) and reuse it. But this does not imply that execution needs to be able to start at F, G, or H.
@taalexander - I owed you a syntax proposal from our last chat. Here's my favorite:
Unlike the pure % proposal it's easy to guess what is probably happening, even if you are not encountered the syntax before. And unlike the input() syntax it doesn't suggest that there is some function being called.
It also aligns nicely with the const + type syntax we previously discussed, const int = 5; which is essentially <modifer> <type> <equals> <value>
Some design goals from the meeting:
For OpenQASM2 compatibility we assume that all cregs are intended as output, ie. we pretend there was an output keyword in front of them.
@stevenheidel do we need both the % identifier and the input/output keywords, or is just the latter sufficient?
The latter is sufficient, the percent just makes the variables stand out a bit more. May not end up being that important.
% no longer refers to physical qubits, but it is used as the modulo operator so we'll likely want to avoid that--probably better to just leave out if we already have the input/output keywords.
@stevenheidel I think this is the best version I've seen yet. The one piece that still rubs me a little the wrong way is the mismatch in what can be returned in subroutines vs the top-level module since this enables multiple return values. I'm wondering if we should allow this within def somehow such as names return values in the signature?
This issue has been resolved via the input/output syntax described in https://arxiv.org/pdf/2104.14722.pdf. A new PR should be opened to address those changes.
