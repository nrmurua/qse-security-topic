Currently the measurement gate works by sampling the state vector and returning the sampled bit strings, however it does not have any effect on the state vector. This means that the final state of a circuit that contains measurements (which can be accessed as circuit.final_state after execution) is the same with the final state that we would get if the circuit contained no measurements.
The state collapse is not done for two reasons:
On the other hand collapsing the state when nshots = 1 is useful for some applications. I have an implementation of the collapse mechanism based on Tensorflow primitives that I will probably extend to custom operators for efficiency. The main question is what would be a good interface for this. I can think of the following possibilities:
The second approach is also slightly more complicated in terms of implementation, because currently when gates.M is called on a state vector it returns a measurement object (and not a new state vector). All other gates return a state. If we do the collapse we would need to modify gates.M so that it returns the collapsed state and access the actual measurement result in a different way.
I am open to any other suggestions regarding an interface of this that you think it would be useful for applications.
Thanks for summarizing the case in study and proposing the interfaces.
The first point sounds reasonable, in particular we could even consider the Collapse gate as a special measurement gate with nshots=1 and specific bit-string result. Now, thinking about priority, if the problems we are planning solve matches the requirements of point 1 then we should go for it.
