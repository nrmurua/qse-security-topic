Related to #111 and #162 it seems like there isn't a nice way to have a parameter which is already a set of  sweep values. Reading the docs didn't really clear up for me to what extent this is already supported and how I can use this sort of information in a 'qcodes' way both with data and loop.
My case is that one call to the vna returns values for magnitude and phase from a frequency sweep and I would like to be able to plot one sweep in a 1d plot (for magnitude or phase) but also do a 2d plot stepping another variable. Should I have one parameter for the sweep? Or make some dummy 'frequency' parameter?
I think this kind of thing should be done by making a single parameter called something like "frequency_sweep" - which would return three 1D arrays: frequency, magnitude, and phase. Then you should be able to make a 1D plot just by getting this parameter into a DataSet (this functionality doesn't exist yet) and a 2D plot by getting this parameter within a Loop (this functionality does exist, see for example AverageAndRaw and it usage in the main example notebook
There's one more subtle issue I'm realizing: In this case you'll want frequency to be marked as the setpoint array for both magnitude and phase, and no separate dummy setpoint array (just the indices) created for frequency. That way you don't generate any useless extra data, and when you plot magnitude or phase, it will automatically be vs. frequency if you don't alter it. I think this can work with the current framework on the parameter side, but Loop will need some work to detect it and not make extra copies of the setpoints. It would also be much more flexible if the size and setpoints could be provided by the measurement itself, rather than needing to be preset as attributes of the parameter. This goes along with QCoDeS/Qcodes_loop#14 where we're discussing dynamic sizing.
So the open items I see are:
I think there is also a broader (but connected) issue here. I think it should be possible in principle for a parameter to return an arbitrary python object, such as array, matrix, etc.
right now, this is not allowed, but having this option would make it possible automatically to save the resulting results from the VNA, but does so in a general way which I think would be very useful.
I have already encountered situations in which I wanted to store matrices (I gave up on that idea) and arrays (which I solved by a virtual loop as @alexcjohnson mentioned, but it doensn't make for very elegant code)
I think it should be possible in principle for a parameter to return an arbitrary python object, such as array, matrix, etc.
right now, this is not allowed
@damazter Maybe I'm missing something you have in mind, or maybe we just need better docs/examples... but as long as you know ahead of time what shape(s) of object(s) will be returned, this should work already. Similar to AverageAndRaw:
The most pressing limitation of this, seems to me, is the first one in my list above: the need to make a DataSet from a single get call so you don't have to increase the dimension with a Loop.
@alexcjohnson
Sorry, I forgot all about that. But it doesn't solve the underlying problem though. If I want a parameter to return an arbitrary python object (which is allowed by the parameter syntax), getting this parameter in a loop will not work for arbitrary objects (so while saving an array will indeed work, saving a sparse matrix is not possible (without converting it to dense and saving the entire thing))
I can imagine having a parameter which contains a picture of the measurement setup (we actually do this) and saving that image to the datafile as well.
So I think there needs to be some added syntax somewhere that does allow for arbitrary data-types. Similarly one could then define how these datastructures should be plotted upon getting them for the datafile/dataserver
Interesting - correct, we presently require anything that's called data to fit into a regular numpy float array. I can see your point though, it would be great if you could hold other random data types as the unit in the array. I suspect that wouldn't be very difficult - just need to
I would love an implementation like that, but it might be that @AdriaanRol wants to join in as well
@damazter , thanks for CCing me
but as long as you know ahead of time what shape(s) of object(s) will be returned, this should work already. Similar to AverageAndRaw:
@alexcjohnson  I disagree that this is already working, on two points.
I am of the opinion that the "array parameter" encompasses a very general class of parameters (basically any Loop where the hardware is in control of the loop) that it deserves to be part of the QCodes core and not a hacked in addition.
I think the example @nataliejpg provides is pretty clear but to just to make the point that this is a common class of experiments for which we want to support Loop compatibility I'll add some more. ATS measurements #66 , FPGA based measurements where the FPGA returns an array, basically anything that get's triggered.
I feel the solution to this problem lies not in changing the structure of the parameter (at best add an extra attribute to it to designate it as an array param), the get can already return arbitrary sized arrays. Rather I'd say we need to think about the Loop and how it interacts with parameters that take arrays as input (for set) and return arrays. I think this way of doing experiments will only get more common in the future.
@damazter I agree with your comment on supporting arbitrary datatypes, however I feel that this is a separate issue, as it has further reaching consequences and may be harder to implement.
@AdriaanRol you're absolutely right that this is going to be a very common situation that we need the right abstraction for. Just to be clear on where we are now:
QCoDeS/Qcodes_loop#14 is about the case where even when you start the loop you don't know how long it will run... or when you get a parameter you don't know how big the result will be. But the case where you know at the start of the Loop how big each parameter's return will be is certainly supported already: there's nothing to stop you from editing parameter.shape or .shapes when you change some other parameter. So if you have a network analyzer with a parameter read that returns magnitude and phase arrays, you can have your parameters start, stop, and npts all call self.read.set_sweep(start, stop, npts) which looks like:
I don't follow, can you elaborate? We do need a way to create a dataset from a single parameter.get() call, as discussed above, but conceptually that shouldn't go through a loop at all, it needs a different verb. If you are measuring this parameter as part of a loop, that works just fine already and creates and saves a higher-dimension DataArray, as in the main example notebook.
Anyway, I'd love to hear ideas about how to make an ArrayParameter or some such that would be easy to use and cover all these use cases; from my side I haven't come up with anything that seems better than just specifying these attributes, changing them when they change (If they're sufficiently dynamic they could use @property I suppose) and having a custom get method. I feel like the use cases are all so different that if we try to impose much more structure than that it will make things harder, not easier.
It is now working such that I can now loop over this parameter (but still not take a single measurement of it), thanks for your help @alexcjohnson. I think a big part of my problem was not knowing what was supported already which will hopefully be resolved as docs develop. I would propose closing this issue and opening a separate one for one shot measurement and then maybe @damazter could open one for data type and @alexcjohnson for dynamic sizing and set points applying to multiple arrays for the sake of clarity. Unless anyone else has further thoughts?
