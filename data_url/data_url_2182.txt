I got an email from a user confused about how to use cirq.Ry to produce an operation. They were trying to call cirq.Ry(angle, qubit) instead of cirq.Ry(angle).on(qubit). This raises the question of whether cirq.Ry(angle, qubit) should just work, since it is unambiguous.
Pros:
Cons:
Multiple ways to do the same thing.
In my opinion, this is a pro, but we can go on for hours about this ;)
I think the pro you listed is a big one since non-angle parameter gates work like that. It's intuitive to me and i bet it's intuitive to most.
Would this convention be spread to constructors of gates or be limited to gate factories like Rx, Ry, and Rz? If it is spread to constructors of gates, that adds quite a bit of additional work a user needs to do to make a user defined gate act like a library defined gate. If not, I think there will be confusion from users as to why the library define gate constructors don't also accept this syntax to produce an operation. I like the syntax and want to have the option to use it in my own code, but I'm wondering whether or not this will just open up confusion elsewhere.
I agree with @c-poole; as long as we have a distinction between Gate and Operation I think functions like cirq.Rx should just produce gates and you have to separately apply them to qubits to an operation. I've proposed unifying Gate and Operation in #252, but we decided against doing that, so I think this distinction is just something people need to learn (and we need to explain clearly in documentation).
For this particular problem, we could easily add Ry_operation, Rx_operation, and so on. That doubles the amount of work for us any time we add gate factory methods like this but feels minimally confusing to users. If we are going to have Gate and Operation be distinct concepts then we need to maintain that difference. Unifying the two would be a major breaking change at this point, but the cleanest way I can imagine to do it is to make Gate essentially an alias for an Operation with an empty qubit set. The code that Operation currently uses to verify that the qubit list it received is consistent with the Gate it received could be distributed between Operation and Circuit/Device to avoid issues with placing nonsensical operations inside of circuits. This would be a hefty breaking change that we would have to be careful about implementing and I'm not confident its the best option for merging Gate and Operation, but I do think we need to either put our foot down about keeping them distinct or find a way to make them different versions of the same object.
An efficient way to solve this particular problem without having to break the fundamental Gate Operation boundary is to throw a helpful error message showing the "correct" way when a Gate encounters qubits in the constructor.
To enable better readability/writability than MyGate(gate_args).on(qubits), we can have a protocol get_op(MyGate, gate_args, qubits) and encourage this usage when users don't care about reusing the Gate and just want the Operation.
Does anyone create an Operation directly? If not, we can stop exposing it and always use the protocol. It would give us more flexibility to change implementations under the hood later on (huge breaking change right now though).
I don't use Operation directly but I do call ParallelGateOperation directly.
ParallelGateOperation (or any other specialization of Operation) can just use the protocol in the init method without being a breaking change.
Of course, we'd also need to support get_op(My_Gate_Object, qubits) in addition to get_op(My_Gate_Class, gate_args, qubits) if we want this to replace Operation entirely.
I agree that allowing the qubits to be specified in these methods would push us towards allowing them to be specified in the gate constructors. That would basically be a gigantic typing disaster. That's a strong argument against doing this. IMO
