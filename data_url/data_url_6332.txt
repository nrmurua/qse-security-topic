#660 introduces defaults for layer stacking, such that the user only need specify QINTERFACE_OPTIMAL if they wish to construct the optimal stack, (or QINTERFACE_OPTIMAL_MULTI). To solve the problem of arbitrary depth of QInterface layer stacking, potentially forever, all constructors should take simply an arbitrary length vector of layer types, via the enum we currently have.
All layers are ignored after a "terminal" layer; a terminal layer is has a type without a stackable sub-type.
The primary work of this issue will be supporting all plugins in the framework through the coordinated change.
(This is a relatively straightforward software engineering improvement, for a Qrack issue.)
For the Unitary Fund Hack, this is probably the easiest issue to tackle.
qfactory.hpp has a CreateQuantumInterface() template method that takes a variable number of leading QInterface type arguments, from an enum in qinterface.hpp. This tells CreateQuantumInterface() how to assemble the simulation "layer" stack, from layers like QEngineCPU and QEngineOCL, which are simple "Schr√∂dinger method" simulations, with layers like QPager and QUnit operating on top in a stack, for optimization.
Qrack can theoretically specify an arbitrarily high number of layers to stack. Layers like QUnit and QPager take sub-type arguments, to know what they stack over. QEnginCPU, QEngineOCL, and QHybrid are "terminal" layers that must go at the bottom of the stack, but a vector or queue of QInterface sub-types can just safely ignore all specified layers deeper than one of these terminal layers. Reach out to me, "WrathfulSpatula" (Daniel Strano) if you'd like clarification on what layers exist and what they do.
To support third-party plugins, we simply leave the original CreateQuantumInterface() overloads in place as they are, at the moment, so you won't need to modify third-party plugins, after all. Additionally, though, CreateQuantumInterface() needs an interface which takes a vector or queue of QInterface sub-type enum values that can construct an arbitrary stack. The constructors of the various sub-classes will also need to be modified to accommodate this new stacking. (Eventually, we'll phase the old CreateQuantumInterface() overloads out.)
The point of this is issue is to add a new overload to CreateQuantumInterface(), with corresponding new constructors in QInterface sub-classes, such that a user can specify an arbitrary layer stack in an C++ STL "vector" or "queue," or a container you think is more appropriate. It is not necessary to add new support for "impossible" stacks to existing QInterface sub-classes, just to let user code construct an assumed-to-be valid stack with the new CreateQuantumInterface() overload.
