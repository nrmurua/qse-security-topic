When running some code to create the conjugate of a tensor network in order to contract them, I get the following error:
Not sure how to work around this, as the 'conj' function does not allow for passing of kwargs; any help would be appreciated. For context, I'm using a custom class which inherits from qtn.TensorNetwork.
I think you just need to add virtual to your custom class, hard to say how to do that without more details! Might just be a matter of passing it through to super().__init__ etc.?
Note virtual controls whether the TensorNetwork takes copies of the tensors passed to it or not.
Fair enough :) that is how I was initialising the class; however, I did manage to get around this earlier! I overrode the copy function within my custom class and simply called the original within this override as super().copy(virtual=virtual,deep=True), with virtual hard-coded. It was mainly a problem for the conj function, and it seems that this call is fine for conj to be able to use the methods - so it's enough for my use case, anyway. Appreciate the response!
Glad you got it working - subclassing TensorNetwork I guess is quite advanced usage if you did want to share a fuller example - up to you. deep=True might be quite slow!
It's something I'm doing for my work so I'll err on the side of caution and not share the code, but to summarise: I built a custom TN class that could exploit some more experimental structures, and I was working on calculating expectation values by first "closing" the custom TN with its own conjugate, then "opening" the required indices and attaching my operator. The bug only really showed up when I moved from using a Jupyter notebook to declaring it as inheriting from TensorNetwork - everything worked just fine when I was simply creating a TN by defining some custom arrays and calling qtn.TensorNetwork(data=my_data,.... Thank you for the tip about deep=True, will keep that in mind :)
