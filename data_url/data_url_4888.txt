Consider that a user is distributing an N-qubit density matrix between 2^k nodes, and wishes to apply a depolarising error to qubit with index q. QuEST's distributed mixDepolarising implementation assumes each node exchanges at most half of all its local amplitudes. This algorithmic condition is only true when q < 2 N - k.
There is an incredibly obscure but legal distribution pattern for which N < k. This is the scenario when each node contains a sub-column of the full density matrix. For example, when using 1 GiB on each of 8192 nodes. In this scenario, there are valid target qubits q (always including the most-significant qubit) for which q >= 2 N - k. Depolarising such a qubit will lead to a segmentation-fault, caused by an out-of-bounds array access, as a node attempts to access more pair amplitudes than were exchanged.
This scenario could be patched in-principle; a node can simply exchange its full state-partition, like in a single-qubit unitary. Furthermore, this scenario leads to only half of all nodes requiring any communication at all, so the total bandwidth of the serial communication is unchanged, by invoking this optimisation.
However, the necessary distribution pattern is so obscure that an implementation and further optimisation seems ridiculous. For example, a 5 qubit density matrix (only 16 KiB) needs to be distributed between at least 32 nodes before depolarising on the final q=4 qubit will invoke the error. Even our present unit tests which already cover a strange realm of deployment, use 5 qubit states distributed up to 16 nodes, and hence avoid this error. Indeed, this seg-fault has never been accidentally experienced - it was discovered through meticulous re-derivation of the depolarising algorithm! So, at least until the unit tests are automatically deployed to a greater number of nodes (potentially just for density matrix tests), a simple run-time validation that q < 2 N - k will suffice. Add this validation to develop as a bug-patch for next release.
Note this bug also exists in identically obscure circumstances for mixDamping. Note though that when addressing this, mixDamping should be bandwidth-optimised as per #323
