Carry arithmetic has a couple of edge cases. One is the all 0 input case. (This is an edge case because only one input state contributes to the output, where usually two different input states correspond with an output.) The other is where the in-and-out register takes a maximum or minimum value while the in-only register is 0 with the carry bit initially set, leading to a carry-in to carry-out case.
For carry addition, with 8 bit registers, with the first register for both input and output, the carry in/out case looks like this:
11111111 00000000 1 -> 00000000 00000000 1
For carry subtraction, the carry in/out case looks like this:
00000000 00000000 1 -> 11111111 00000000 1
Both these edge cases have recently been handled for CPU POSIX-type threading. However, it's not easy to efficiently implement carry arithmetic for kernel-type GPU parallelism while handling these edge cases. Kernel-type parallelism keeps all execution units in "lockstep," meaning that branches for edge cases are always essentially run in every loop iteration, even if their results are discarded. (POSIX threads should be able to effectively branch.)
It would be useful to have efficient (GPU) kernel parallelism for carry math. This might be handled by putting the edge cases aside to be handled separately. However, loop iteration in kernels should hopefully totally avoid these cases, without iterating over them. Further, the edge case loops should similarly only iterate over the relevant cases, or their probably is no advantage to also using kernel parallelism, with this redundancy.
(Note that if any coherent bits are not involved in the immediate carry bit operation, the carry math has 2 edge cases for every permutation of bits not involved in the operation. So, in a CoherentUnit of 25 bits, with two 8 bit carry arithmetic registers and a 1 bit carry, there are 2 edge cases per unused bit permutation, for (2^8)*2=512 edge cases.)
The carry edge cases are no longer relevant, after additional consideration of how to properly handle unitarity.
The carry bit as it's usually implemented on classical systems has to function as both an input bit and output bit in carry arithmetic. This cannot generally preserve unitarity. One way to get around this is to measure the carry input flag at the beginning of any carry arithmetic operation. Measurement breaks unitarity, but in a quantum mechanically correct and well-defined way. Once the carry is measured, it only adds exactly 0 or 1 to the operation, with no superposition entering via the carry-in. This makes this issue moot.
