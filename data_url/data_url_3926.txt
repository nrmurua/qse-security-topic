In order to better support experimental work undertaken with OpenQL, pulse-level features are required of the compilation toolchain. 
In its simplest form, that may mean additional layers aware of the subset of operations (from the set of operations defined to OpenQL) required to implement a specific quantum program, and capable of generating the necessary waveform tables (codeword, waveform pairs) for that particular experiment. I believe @wvlothuizen already put some thought into such features, which would be important to take into consideration.
An additional step might involve providing circuit visualization capabilities, as described in issue #271, at the pulse-level to OpenQL, allowing visualization of the final set of pulses that will implement a specific quantum program.
Note: these features could even be taken one step further, by providing scheduling capabilities at the pulse-level as well. This may involve thought into intermediate-representation languages (issue #255) capable of describing experiments at the pulse-level.
In its simplest form, that may mean additional layers aware of the subset of operations (from the set of operations defined to OpenQL) required to implement a specific quantum program, and capable of generating the necessary waveform tables (codeword, waveform pairs) for that particular experiment. I believe @wvlothuizen already put some thought into such features, which would be important to take into consideration.
To discuss efficiently about this issue, it would be very helpful if there would be also a design document that defines these features explicitly along with, e.g., missing features in OpenQL/cQASM, missing features in the platform configuration file, desired operations, etc.. Finally, examples illustrating how the new features should be given to and dealt by the compiler from input to output would help make sure there is a consistent understanding of what is expected/needed.
Closing because of lack of activity
