In pyQuil < 2.0, it was possible to simulate postselection when simulating wavefunctions, with codes of this style:
I have not managed to reproduce this type of program with pyQuil 2.3. The most similar solution (that is quite specific) that I have found is the following:
So, ultimately my question is, is there a standard way to access classical registers from outside a Quil program?
Thank you
We changed the quil memory model so that classical registers have names. The second argument to qvm.wavefunction() would specify the addresses of classical memory to return, which used to just be numbers. Now it would have to be (perhaps) a list of tuples of variable names and offsets or we could do something like always return the full classical memory space of the qvm. As you have found out, we just removed the ability to inspect the classical memory with wavefunction methods.
As a workaround, you could use the PyQVM object, which implements a QVM in python. As such, you can peek and poke at classical memory however you want
please note that PyQVM.execute() will not reset the state of the machine before a subsequent call (in contrast to QVMConnection.wavefunction()
Thank you for the information about the actual status and possible workarounds. Regarding this workaround, is it possible to perform noisy computations with it? A bit outside the question I posed, my actual intention was doing runs of the sorts of programs above, but in simulators where I could specify gate and measurement noise levels. Hence my attempts using QVMConnection instead of PyQVM.
One important note that you might already know: QVMConnection's noise models stochastically evolve a wavefunction. Essentially, each time you call wavefunction it will randomly select whether to apply noise or not. Therefore, you must run a given program multiple times and gather statistics in order to draw conclusions about the performance of your circuit under noise.
PyQVM can use a density matrix simulator as a backend which currently has rudimentary support for noise models.
This will apply a dephasing kraus map to each qubit after each gate, which is probably not what you want. But all the building blocks are there if you're willing to tinker with when/how noise operations get applied. Since it's a full density matrix simulation you won't have to be concerned with stochastic evolution, in contrast to the note above.
If you're willing to get your hands dirty, this is one avenue to pursue. I'd highly recommend reading through the code to figure out exactly what the noise model is and modifying it to suit your needs. We'd also love if you wanted to contribute changes to the density matrix simulation code to support better experimentation with noise models. Otherwise, it's on our roadmap to improve the interface for noisy density matrix simulations in the future.
Great, thank you for your comments. Indeed, a stochastic evolution is what I am initially looking for, but thank you for pointing it out. Also, I will start playing around with PyQVM, and see what I can get from it.
