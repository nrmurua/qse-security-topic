Current status:
NB the non-zero helper tags don't go away if we leave the loop for 10s to settle. Not sure if that's an issue with the loop not quite keeping up with the drift in the main DCXO? Anyway, it does lock down to a pretty low jitter so seems to basically work...
I think the residual error is just because the helper PLL isn't designed to be overly tight. In the data set above, you can see that the helper ADPLL (tunes the DCXO frequency with 1LSB =0.1ppb = 12.5mHz for 125MHz f_rtio) are moving in the right direction but the tags (phase difference between the two DCXOs with 1 tag = 50fs) are staying pretty constant. That suggests that what we're seeing is finite phase error due to finite low-frequency gain in the loop filter. The residual phase error there is ~12.5ps. That's potentially quite large since it implies that if the DCXO drift changed (e.g. due to environmental changes) we could get a phase shift by that much. Again, I assume this is just the helper PLL being deliberately a bit weak...let's see what happens with the main DCXO...
Robust phase unwrapping fixed.
Helper DCXO locked to the main DCXO with the filter input gain turned up a bit (bit shift increased from 22 to 28).
That locks with a mean absolute deviation of 7 tags (~1.75ps).
Also confirmed we can lock the helper to the reference (CDR) clock
That locks with a mean abs error of 40 tags (10ps), presumably due to the higher noise floor of the transceiver PLL and/or reference oscillator used here.
Take aways: even during initial lock acquisition transients we don't see any glitches; the lock tracks in nicely and holds lock nicely. Next step is to get the main DCXO locked.
Some thoughts about "phase unwrapping". This is really a misnomer since we now use a 64-bit DDMTD counter so there are strictly no phase wrapping issues (which there were with the N-bit counter). The issue is really now just cycle skip corrections.
These skips happen because the DDMTD "collector" produces one tag difference output per pair of input tags, one from each DDMTD input. If the oscillator frequencies are not locked, one oscillator can lap the other, leading to a cycle of that oscillator being lost (a second tag comes in while we're still waiting for a tag from the other oscillator). When that happens, without a cycle slip correction, we get a large jump in the tag value due to the missed tag.  This gives the loop filters a huge kick and can easily end up with the PLL being unable to lock (these large kicks come in faster than the loop filter can correct for them).
We correct for this by looking for large discontinuities in the tag values and then adding/subtracting on the DDMTD counter period (2^15 tags) as required to remove the discontinuity. If the oscillators are close to locked then the amount we missed during the skip will be close to 2^15 so this will correct for the tag we missed. If we're far from lock (so that the increase in tags each cycle is not 2^15) there will still be a discontinuity, but far smaller than if we hadn't applied a correction.
There are probably better ways of implementing this correction: rather than looking for discontinuities, it's probably easier to just watch for tags arriving while we're in a wait state; rather than applying a blanket correction of 2^N we could base the correction on the tag we missed; etc. However, these glitches only occur during lock acquisition, not once the PLL is locked, and the current implementation gets us to lock as fast as any other and with a decently low resource usage, so I'm not inclined to put any time into improvements. It would be interesting to compare with CERN's approach, but I didn't find their implementation particularly easy to follow when I last looked at it...
Edit/post script: the other big reason I'm not inclined to pursue this any further is that I don't really understand the rules for signed arithmetic in verilog (apparently neither does the migen simulator so I guess I'm in good company to some extent!). The concepts here are simple and if we were working on a soft core the implementation would be too. But, I'm not well-versed enough in migen to get this done quickly in gateware...
