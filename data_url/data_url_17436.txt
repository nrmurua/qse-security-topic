We need to decide here when the circuit becomes "physical". Whether the layout keeps existing in the property set and every pass consults it, or it just gets applied and further passes work with a flat register.
I think this issue is not discussing when the circuit becomes "physical". Both of the circuits above are "semantically" physical. But they are "syntactically" different. Current LookaheadSwap output uses physical qubit register names. Proposed output (same as BasicSwap) uses virtual qubit register names. I like the LookaheadSwap spec since the circuit is "semantically" physical so it is natural to use the physical syntax i.e. physical qubit register names. Using the virtual register name may be confusing. In fact, I think that's the reason why I and @ajavadia misunderstood BasicSwap output a circuit before applying ApplyLayout pass. See also #2044.
@1ucian0 @ajavadia I found an example that shows why LookaheadSwap spec (Spec-A) is the best (we should forget about the virtual quantum register names).
Please look at the arguments of measurements below.
In the original circuit, we specified measurement result of v1 is stored in c1.
However, in the Spec-B, measurement result of v1 is stored in c0. Isn't this confusing? In this sense, "v1" in the output is no more equal to the original v1. It is a physical qubit q1, isn't it?
In the original circuit, there "was" a one-to-one mapping between virtual qubits and classical registers, v0<->c0, v1<->c1, v2<->c2. Each virtual qubit stores computational results and is projected to classical bit at last. But this relation is destroyed by mapping in general. But users will not care about it. Because they can find what they want to compute by classical register names. That's why we can name classical registers. There is no meaning to carry one-to-one relationship between virtual qubits and classical registers after swap mapping. But users might expect it wrongly and be confused (as I did so) if we name the quantum register as virtual qubits. If we name the quantum register as physical qubits, we'll have no such concern. (I guess @kdk is thinking Spec-A is better as well as me.)
@itoko I agree with you, I will go one step further and say that the Swapper passes should also consume physical circuits (i.e. their job is to take a circuit and a coupling map and make them compatible, not to also care about a layout object). In that sense, I think the ApplyLayout pass should be run after layout selection and before swappers. ApplyLayout marks the place where we have embedded a virtual circuit onto a device.
The only downside is that it would be hard to track that for example given a 5 qubit physical circuit, qubits 0, 1, 3 correspond to the original virtual qubits and qubits 2, 4 were added ancilla. This is information that is stored in the layout. So I think we need a way to easily visualize/report the correspondence between a physical circuit and the original virtual qubits.
But I think the benefits are greater. In this process, we simplify passes. They don't have to constantly consult a Layout in order to do their job. They will simply work with the circuit they are given.
A few points related to your terminology:
@ajavadia I agree with your proposal - Swapper passes not only return a physical circuit but also consume a physical circuit.
At first, in our discussion on #2044, I found we used the term ApplyLayout pass in the different meanings. From now on, I'll follow your definition: The ApplyLayout pass will only relabel and permute qubits (rename of qubits from virtual ones to physical ones).
I found one more benefit to ApplyLayout before swapper. In some circuits, ApplyLayout solve the mapping problem. In such a case, no Swapper pass is necessary to be run.
Regarding downside example, I think this is not a downside. In the physical circuit after swap mapping, we cannot say these qubits are ancilla. For example, if qubits 2 is not connected with qubit 1 and we have cx between 1 and 2, we may be swap qubit 2 and the other qubit (say 3). I this case, we cannot say qubit 2 is an ancilla any longer (qubit 3 will act as ancilla afterwards). In order to track such information, we need to store all layout changes during swap mapping (That's why I thought the definition of ApplyLayout more complicated). And I think it's almost impossible. Am I misunderstanding anything?
If we accept your proposal, Layout should be updated to be able to handle mapping of physical qubits to physical qubits. (It may be somewhat difficult since we have no Qubit classes :()
Excuse me for my inaccurate terminology. Regarding physical qubits name. Until we can use integers as names, what should we use? QuantumRegister(n_qubits)? QuantumRegister(n_qubits, '')? Or anything else?
@ajavadia Excuse me, but I had second thought. Swapper passes should consume a virtual circuit and return a physical circuit. More generally, Mapper passes should consume a virtual circuit and return a physical circuit. And ApplyLayout pass can be seen a special Mapper pass that cannot always solve the mapping problem.
I think the definition of physical circuit is circuit with no crossing wires. That means we cannot remove swap gates by replacing swap gates to wire crossing. And a swap gate swaps two virtual qubits between two straight wires (=physical qubits). The definition of virtual circuit is a circuit before physical embedding. So by definition, the input of mapping (=Swapper passes) must be a virtual circuit, whatever it has qubits named like physical qubits. If ApplyLayout cannot solve a mapping problem of a virtual circuit, i.e. fails to provide physical embedding, the circuit should still stay as a virtual circuit. We should forget about wrongly embedded physical circuit.
Layout should represent mapping between virtual qubits and physical ones (no need to support physical<->physical, since it is not a mapping it's just a relabeling).
This is no longer an issue following #2584
