The new “conditionals via control flow” of OpenQASM 3.0 are a strict generalisation of “conditionals per gate” of OpenQASM 2.0 in terms of expressivity and reducing code size in many cases. However, there could be merit in supporting both via different language primitives.
I am not an expert in hardware design, but the incorporation of arbitrary control flow across the controller systems seems like it is much more complicated to support than conditionally killing a pulse from an otherwise fixed pulse schedule generated at compile-time. This kind of conditional could still see usefulness once arbitrary control flow is supported.
Suppose we have an error-correcting code where we have parallelised all measurements and then need to apply corrections across many qubits. Assuming the control flow is a global property (i.e. we have a global instruction pointer, making any jump in control flow act as a global barrier), we can only consider the branches for a single conditional correction at a time when using control flow, meaning correcting different qubits must be done in sequence. Whereas with gate-level conditionals, the conditional is handled locally at the pulse generator, so each conditional correction can be suitably handled in parallel.
If it turns out that the intention of any abstract machine for OpenQASM 3.0 is to determine control flow jumps as soon as possible and allow reordering of gates around the actual jump (e.g. gates that appear in code as before the jump but don't affect the branch condition could be executed in parallel with the first few gates from after the jump), then the distinction between the two types of conditional is irrelevant. In that case, just a clarification in the live specification is sufficient.
