The ARTIQ compiler embeds host Python values into the compiled program (e.g. for class attributes accessed from kernels) by synthesizing an AST fragment that reproduces the value, and then using the usual compiler pipeline just as if that value had been written into the kernel source code.
We currently lower NumPy arrays to a call to array([…]), where the argument is just the result of calling list() on the array: 
This works for virtually all cases of interest in typical kernels, but is not actually a faithful mapping. For instance, explicitly specified data types in the host object are ignored, multi-dimensional empty arrays result in single-dimensional empty arrays instead, and jagged arrays are not properly supported.
Since the initial phase of ndarray support, we already added support for calling array() with an explicit dtype. We should make use of that in the emitted code to ensure matching types. To faithfully represent multidimensional arrays with one or more zero-size dimensions, we will need to implement reshaping support, and emit array([]).reshape(…) instead.
