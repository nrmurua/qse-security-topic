A 30x30 tableau will use 65000 bits instead of 900 bits because the major axis is padded up to a multiple of 256. This padding is not actually necessary. Redesign simd_bit_table to allow an unpadded major axis, and rewrite any code that relies on that assumption. Maybe template the class to allow using smaller words?
OK, been exploring this issue a bit. Just to clarify, here is the issue (inlining is still working, i am compiling with -O0 here):
In theory, we could have data.num_simd_words = 2. This seems fixable assuming that we are OK maintaining the assumption that simd_bit_tables represent square matrices. In that case, we would just have the required padding rows so that columns can be encoded in simd_bits. All the relevent simd_bit_table methods would need to be updated. @Strilanc: am I missing anything dumb?
ah, i am missing something dumb. simd_bit_table does get used for non square data sometimes.
The simd bit table class is templated now, so smaller word sizes could be used for smaller tables, hidden behind the implementation details of a pybind tableau class. But ideally the bit table would be refactored so that the class knew the true desired number of columns and rows, and the padding of the minor axis was a slightly more internal (though not hidden) implementation detail.
OK, i need to ramble about transposing.
First, just some background to make sure we are on the same page. Lets say that a word has W bits and we have a matrix
Aij consists of W words (W * W bits), and it is stored in memory with stride n * W bits. In order to do a bitwise transpose, we need to first bitwise transpose each Aij and then swap Aij with Aji. We have inplace_transpose_square(bitword<W> *data, size_t stride) which handles the first part and std::swap which handles the second part.
Now, suppose that we are in a situation without major axis padding. Now we have a matrix which looks like this
where Aij still consists of W words, but Bnj might have fewer. Now I am imagining that we proceed as follows: for the Aij blocks, transpose them inplace using inplace_transpose_square. Allocate an array C of W words on the stack (and zero it out). Swaps that don't involve the last row can happen in place as before. For swapping Bnj and Ajn, copy Bnj into C. Call inplace_transpose_square on C (with stride 0). Swap C and Ajn, and then copy the required rows from C back into Bnj. For Bnn we just copy it to C, transpose it and then copy the required rows back into Bnn.
I think that all makes sense, but just wanted to write it out to be sure.
I would say it's illegal to call inplace_tramspose on a rectangular table, if there's no longer major axis padding, because it can increase the amount of space required and therefore is not inplace.
In general I find it quite tricky to write the transpose methods and rely heavily on randomized unit tests to ensure correctness.
Yeah definitely don't want to call inplace_transpose_square on something which isn't square. I think I get around this by allocating the square (and aligned) C on the stack, and only transposing the Bnjs after they have been copied into C.
