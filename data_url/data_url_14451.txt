Would be useful to be able to initialize PauliGate() with a Parameter, which can later be bound to specify whether the PauliGate is I, X, Z, or Y. Multiqubit Paulis could be nice too.
For example, a parameterized PauliGate would facilitate building circuits with random/variable Paulis where one may need to generate a large number of circuit instances that are expensive to transpile individually.
Since Parameters are typically bound to numeric values rather than strings, we could define the gate so that binding to [0, 1, 2, 3] produces the gate [I, X, Y, Z] respectively. Or we could do symplectic ordering corresponding to [00, 01, 10, 11] if that's better. Alternatively a Parameter could stand in for each of the bits in the x and y tables, but to me that seems like a lot of Parameters. If it's not too non-standard, we could handle multiqubit paulis by a ParameterVector where each element is bound to one of [0, 1, 2, 3]. I'm not aware of anywhere else a Parameter is expected to take only discrete values, but hopefully that's not a problem (?).
Currently you can partly work around this limitation by using a u gate (U3 gate) and/or series of p and sx gates, where the p gates can be parameterized. However, this 1) is not hardware efficient as it requires 2 sx pulses instead of 1 x pulse (or sometimes 0 x pulses).  And 2) the p gates are not compatible with the stabilizer simulator method.
We can't realistically support this as the problem is stated, sorry, and definitely not through the Parameter model of computation.  Parameter stands in for a floating-point value (sometimes it's complex, but even those cases are buggy), and trying to fit in an integer-like parameter or some other discrete form would play havoc in handling it across the project.
I also don't entirely see how this helps your initial problem.  The transpiler can't reason about or synthesise a gate unless it's known, which means that parameterising PauliGate wouldn't really solve the problem - you'd still have to fix the parameters before the call to transpile.
I do see the underlying value, though.  Right now, I think this sort of issue is closest to on-going work on delayed synthesis of higher-order objects, which is being worked on by @ShellyGarion, @alexanderivrii and @eliarbel (as best I know).  I don't know what those guys have planned, but perhaps this fits into that scheme in some way?
On a longer-term note, it fits into the idea of partial transpilation and isolating separate transpilation units out of a circuit to reduce the cost in algorithms with subroutines, or other common re-used components.  That's definitely on the roadmap, but it's a very complex beast and we don't want to rush into partial support before having a more complete plan.
Thanks for the explanation. Sounds like my suggestion is probably not the way to go then, and the use-case is eventually on the road map, so I'll close this issue for now.
I didn’t totally understand your comment that the Pauli couldn’t remain parameterized during the transpile (probably because I’m ignorant of how Parameters work under the hood). In case I missed anything, or if it’s of any use as a reference, here's a doodle to clarify the use case I have in mind, since I do think it would be nice to have in some form once there's a feasible technical path. Thanks

To explain a little more with the current state: there are a few parts of the transpilation process, and while "unknown Pauli gate" will work with one or two early stages, it will quickly fail after that.  The rough pipeline is:
For hardware backends, we can work with an object that gets us to "unknown Pauli gates on 1q" through the first three stages, but we break down at step 4 - we can't translate something that's effectively an unknown gate into the machine basis.  It is possible in theory to teach Aer to handle a string parameter (and have PauliGate in Aer's basis set), but Terra's not really set up to represent things like that at the moment.  That's where some work on higher-order synthesis is coming in, though.
Another thing coming fairly shortly is better handling of general classical parameters in Terra and Aer, and classical control flow.  It will hopefully be possible within the next couple of Terra releases to have a structure that looks like
pass through the Terra transpiler, and be simulated by Aer (for running on backends, the unknown bit is the interface for how to pass values).  We'll be building from there, but this idea of representing classical types and passing values as circuit inputs is definitely on the roadmap.
@jakelishman Resurrecting this, but instead of using string parameters you would be better to use the binary symplectic vectors of Pauli's which can be (boolean) integer parameters, and handled by all the built parameter expression manipulations that work with floats. Then all the above steps are no different than how you would already handle that for parameterized U gates. Eg something like this:
Tagging along as efforts on implementing the above haven't really died down and we may be close to have a working prototype. @jakelishman could you expand on why it wouldn't be possible to translate the new parametrized gates to the machine basis?
My question is motivated by the following points:
Let me re-open this, since there's still discussion.
The parameterised U gate only works with the basis translator, and we can only define rules for the basis translator for fixed number of parameters (so you can't add a general rule that will work with all parameterisations).  It's technically possible using a similar strategy to what Chris did above, which I hadn't thought of before.  I still don't think that using Parameter with discrete (including integer) values is a sustainable way forwards for Terra, though (which was always my issue here).  I would point out that Chris' method won't solve your problem of not having them supported by stabilizer simulators.
Within Terra, there are already some places which try to hackily use Parameter with complex values, and those have caused us several bugs already.  Parameter doesn't have any typing information available to it, and there are too many assumptions throughout the library that these parameters always represent floating-point values.  I wouldn't be willing to accept code to Terra that tries to put other types into Parameter (I probably wouldn't have accepted the complex-valued Parameter stuff in its current form either).  If Chris' solution works for you, it's perfectly ok for you to do it with a custom gate, without that being in Terra, just bear in mind that Parameter makes no guarantees about its ability to losslessly work with integer values.
I'd also be cautious about adding the equivalence rules Chris suggests above to our internal equivalence libraries - while SessionEquivalenceLibrary does say it in its docstring that the edges are directed, in practice, all the rules in the library are actually bi-directional.  We don't use that information yet (which is why the docstring says they're directed), but I'd be cautious about breaking that without a very strong reason to.
I don't think you need Parameter to achieve what you want, though.  You can have your own custom StandinPauliGate class that contains whatever state you like, such as
and then just add these to the circuit normally.  When you do your first transpile, just make sure that standin_pauli is in the basis_gates (or the BackendV2-ish Target), and it'll get passed through untouched.  You can then write a simple transpiler pass yourself that runs through the DAG (after the circuit has been transpiled), and replaces all your StandinPauliGate instances with whatever you like (including PauliGate), using whatever logic you like.  It gives you way more flexibility, and this sort of thing is absolutely supported within Terra.
I mentioned above what longer-term strategies are for this.  It's also kind of similar to the problem of classically compiling a program against a library that's dynamically loaded in at run-time, in the sense of you have a main "runner" program you want to compile, and within that to be able to swap out certain blocks without needing re-compilation.  The case you describe at the top is a simple subset of this, but for Terra core, we can't maintain hundreds of special cases, we need a nice general way of doing relocatable subroutines (in terms of the register allocations) for everything.  This is something we're working on, though it's complex and we have problems to solve on the way to it.  In the meantime, I think custom transpiler passes when you want to extend the behaviour of the transpiler (as here) are the right way to go.  Those don't need to be in Terra core - it's completely fine for them to be in external libraries.
I have a version of this working now with equivalence library, which requires a single-qubit Pauli gate that you use to register different decompositions, and then an n-qubit gate with a definition in terms of the single-qubit pauli gates, that works with symbolic gates going through transpiler optimizations, and non-symbolic gates going to regular Pauli gates for stabilizer simulation. I'm not planning on making a PR for this to terra though, just using it in our project that needs it.
