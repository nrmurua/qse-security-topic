If the circuit doesn't have rotation gates on a qubit after it has been measured, then the qiskit does not parallelise over shots even when the appropriate backend options are set. However, if we add a rotation gate after a qubit has been measured, then qiskit does parallelise over shots.
Adding a rotation after measurement shouldn't affect whether parallelisation is used.
This is not a bug. Aer has an optimization to save run time: when possible (measurements at the end of the circuit, no noise) it runs only a single shot. In this shot, it calculates the state vector right before the measurements begin. Then it creates the counts according to the induced probability distribution and the number of shots.
Ah, I see! Thanks for clarifying that.
Hi @yaelbh would this optimisation be reconsidered then? Our results show that forcing the parallel behaviour is faster than the default behaviour you described of using the statevector.
The first run is a smaller circuit which falls back to the optimisation you described. The second circuit is larger, yet runs in less time when we force the parallelisation.
@chriseclectic do you have an idea what can cause these results? Can we reproduce the same results?
This seems to make sense. This is a very small example in terms of qubit numbers and the parallel shots is roughly 8x faster. Sampling of such small circuits is done single threaded, so if you forced shot parallelization of sampling it should see a similar speed up. eg:
From a practical point of view this is an edge case that I don't think is particularly worth optimizing. If you are doing enough shots of an ideal circuit for this to be an issue you should probably just compute the exact measurement probabilities using qiskit.quantum_info.Statevector.from_instruction(circuit).probabilities_dict()
@chriseclectic, the key point of this ticket is to say that we are not able to reproduce the behaviour you are demonstrating. We find that unless there are operations after the measurement, we have no control of the multithreading behaviour. This is best demonstrated by the results
despite the fact that we have set 'max_parallel_shots': 0 for both of those runs. As such, I am surprised that your example shows an improvement in runtime. One notable difference between our examples is your use of _parallel_shots instead of max_parallel_shots, which we use with guidance from the qasm simulator docstring.
Could that be responsible?
I can confirm that replacing _parallel_shots with max_parallel_shots in your code @chriseclectic leads to no speedup:
What confuses me is how the max_parallel_shots flag does nothing by default - but if you do an operation after the measurement then it is used?
@bjader "max_parallel_shots" is used to set a maximum allowed value, but that doesn't mean that many threads will be used. Several conditions are checked when choosing how to assign threads for parallelization with the default behavior is chosen to optimize performance for typical usage.  The "_parallel_shots" is a debug method for forcing the number of threads to a specific value.
As @yaelbh mentioned above the automatic default of any noiseless circuit where all measurements can be pushed to the end of the circuit is to only simulate a single shot, and sample all measurement outcomes from the final state vector. Hence in this case there will never be any parallel shots unless you manually override that behavior as I did in my code example. If you add an instruction after measurement this optimization is not possible so it simulates the full shot every shot independently. In this case the max_parallel_shots value is taken into account. Parallel shots are intended for noisy simulation where you need to simulate the full circuit for every shot to average over realizations of the noise.
