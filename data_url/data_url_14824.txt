The TemplateOptimization pass can return circuits that contain Sympy-backed ParameterExpressions even when Symengine is installed and available.  This doesn't immediately seem to pose any troubles, mostly because Symengine can work with Sympy objects and converts them internally, Symengine is supposed to be used if available and ParameterExpression assumes that its types are all Symengine types if it is available.  This can lead to problems when it wants to call Symengine functions that do not have the same arguments / names as their Sympy equivalents.
The output type is some Sympy type, but it should be a Symengine one.
Template optimisation uses sympy internally in order to use sympy.solve, but does not necessarily convert its objects back to the native form before creating ParameterExpression objects.  It should arrange for these objects to be cast back to Symengine ones, if it's playing with ParameterExpression at a low level.
Tbh, the template optimisation code probably doesn't actually need sympy here at all - if we instead restricted the templates to say that parameters can only be used in linearly (templates are just simple), we'd be able to roll our own basic linear simultaneous-equation solver and skip the heavy sympy import and use.
This code isn't used much though, and it could do with a fairly serious refactor, so that's a very low priority.
